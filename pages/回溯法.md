- ## 题目
	- 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有* ***不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。
## 要求
	- `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。
	- 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。
## 分析
	- 使用深搜进行遍历选择树
	- 回溯法+剪枝
	- 调用dfs
		- 判断index是否已经到了最后一位的后面（即index === length）
			- 如果是，则直接返回
		- 判断target是否为0（或者是，相加的和是否等于target）
			- 如果是则将现在的组合combine添加到结果数组中去
			- 如果不是则继续进行
		- 不添加当前index的值，则直接进行下一次dfs，index加一
		- 添加当前的值，更新target和combine的值，进行下一次dfs，index不变
## 需要了解
	- 在使用java时，需要回退
		- 传入的数组combine在dfs结束后，应该恢复原来的数据
	- 在使用javascript时，将数组作为参数一般使用扩展运算符
		- `...arr`用于复制数组，可迭代值
		- 否则则需要用apply，null将作用域替换
	- 在javascript中，函数中是可以声明函数的，所以dfs函数可以声明为const，直接调用就可。
		- 声明的变量是有结果数组result；
		- 整数数组，candidates和target是作为参数传进来的，dfs函数只可以直接访问的
## 代码
	- ```
	  var combinationSum(candidates,target){
	  	const result =[];
	      
	      const dfs = (target,combine,index)=>{
	      	if(index === candidates.length){
	          	return;
	          }
	          if(target === 0){
	          	result.push(combine);
	              return;
	          }
	          
	          //忽略此值
	          dfs(target,combine,index+1);
	          
	          if(target-candidates[index] >= 0){
	          	//小于0时，不需要再做判断
	              //target减一
	              //combine添加此值
	              //由于可以重复添加，则index无需更改
	              dfs(target - cadidates[index],[...combine,cadidates[index]],index);
	          }
	      }
	  }
	  ```