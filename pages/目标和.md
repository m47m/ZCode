tags:: leetcode

- ## 题目
	- 给你一个整数数组 `nums` 和一个整数 `target` 。
	- 向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：
## 要求
	- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。
	  
	  返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。
## 分析
	- 回溯法解决
	- 动态规划
		- 找到一个正子集p和负子集n，有`p - n = target`
		- 有`p - n  + p + n= target + p + n`，即`p = (target + sum )/2`，固定值
		- 方程有 `dp[i][j] = dp[i - 1][j] + dp[i-1][j-nums[i]]`
			- dp[i-1][j]为前i-1个数中的集合数，
			- dp[i-1][j - nums[i]]为前i个数中取出num[i]的集合数
## 需要了解
	- 创建二维数组
		- `const dp = new Array(n+1).fill(0).map(()=> new Array(neg +1).fill(0));`
## 代码
	- ```
	  //回溯法
	  /**
	   * @param {number[]} nums
	   * @param {number} target
	   * @return {number}
	   */
	  var findTargetSumWays = function(nums, target) {
	      let result = 0;
	  
	      const dfs = (target,index) =>{
	              if(index === nums.length){
	                  if(target === 0){
	                      result++;
	                  }
	  
	                  return;
	              }
	  
	              dfs(target+nums[index],index + 1);
	  
	              dfs(target-nums[index],index + 1);
	      }
	  
	      dfs(target,0);
	  
	      return result;
	  };
	  ```
	- ```
	  //动态规划
	  /**
	   * @param {number[]} nums
	   * @param {number} target
	   * @return {number}
	   */
	  var findTargetSumWays = function(nums, target) {
	  	  let sum = 0;
	  
	      for(const num of nums){
	          sum += num;
	      }
	  
	      let diff = sum - target;
	      if(diff < 0 || diff % 2 !== 0){
	          //target比sum还大，或者说差值不为偶数
	          return 0;
	      }
	  
	      const n = nums.length,neg = diff/2;
	      const dp = new Array(n+1).fill(0).map(()=> new Array(neg +1).fill(0));
	  
	      dp[0][0] = 1;
	  
	      for(let i = 1;i<= n;i++)
	      {
	          const num = nums[i - 1];
	          for(let j = 0; j<=neg;j++){
	              dp[i][j] = dp[i-1][j] //继承前i-1的总数
	              if(j >= num){
	                  dp[i][j] += dp[i-1][j-num]
	              }
	          }
	      }
	  
	      return dp[n][neg];
	  
	  }
	  ```