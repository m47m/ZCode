file:: [JavaScript高级程序设计(第4版)_1672654511256_0.pdf](../assets/JavaScript高级程序设计(第4版)_1672654511256_0.pdf)
file-path:: ../assets/JavaScript高级程序设计(第4版)_1672654511256_0.pdf

- Web 浏览器只是 ECMAScript 实现可能存在的一种宿主环境（host environment）
  ls-type:: annotation
  hl-page:: 27
  hl-color:: yellow
  id:: 63b2b207-d821-4358-9f2c-1a21abc9405a
- ECMAScript，即 ECMA-262 定义的语言
  ls-type:: annotation
  hl-page:: 27
  hl-color:: yellow
  id:: 63b2b220-be98-47f6-a69b-2d5681ef2791
- 第 4 版包括强类型变量、新语句和数据结构、真正的类和经典的继承，以及操作数据的新手段。
  ls-type:: annotation
  hl-page:: 28
  hl-color:: yellow
  id:: 63b2b27d-1381-4bc0-9bb7-3012b6aa3b7f
- 原生的解析和序列化 JSON 数据的 JSON 对象、方便继承和高级属性定义的方法，以及新的增强 ECMAScript 引擎解释和执行代码能力的严格模式
  ls-type:: annotation
  hl-page:: 28
  hl-color:: yellow
  id:: 63b2b293-3f7c-4ee4-8905-3342f73d2b4a
- ES6 正式支持了类、模块、迭代器、生成器、箭头函数、期约、反射、代理和众多新的数据类型。
  ls-type:: annotation
  hl-page:: 28
  hl-color:: yellow
  id:: 63b2b2a7-49e4-49a5-9324-1925efcb0a23
- 增加了异步函数（async/ await）、SharedArrayBuffer 及 Atomics API，以及 Object.values()/Object.entries()/Object. getOwnPropertyDescriptors()和字符串填充方法，另外明确支持对象字面量最后的逗号
  ls-type:: annotation
  hl-page:: 29
  hl-color:: yellow
  id:: 63b2b2ce-c93e-4bf2-bd73-6f10128c3291
- 包括异步迭代、剩余和扩展属性、一组新的正则表达式特性、Promise finally()，以及模板字面量修订
  ls-type:: annotation
  hl-page:: 29
  hl-color:: yellow
  id:: 63b2b2de-2166-4887-a3a6-b6d81dc479b9
- 万维网联盟（W3C，World Wide Web Consortium）开始了制定 DOM 标准的进程
  ls-type:: annotation
  hl-page:: 31
  hl-color:: yellow
  id:: 63b2b3d6-9917-43f7-9ee7-7f8392a46259
- 对（DHTML 早就支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM 节点的方法）的支持，而且通过对象接口支持了层叠样式表（CSS）
  ls-type:: annotation
  hl-page:: 32
  hl-color:: yellow
  id:: 63b2b44b-fd8f-48f0-b372-2abcbe6b9554
- DOM Level 2 
  ls-type:: annotation
  hl-page:: 32
  hl-color:: yellow
  id:: 63b2b484-97f7-4a8b-b4c6-6880f7b695e4
- DOM Level 3 
  ls-type:: annotation
  hl-page:: 32
  hl-color:: yellow
  id:: 63b2b4bc-1173-42da-9698-9ae87a9a792e
- JavaScript 是一门用来与网页交互的脚本语言
  ls-type:: annotation
  hl-page:: 35
  hl-color:: yellow
  id:: 63b2b58a-4c56-4694-9957-a327e17f4a46
- <script>元素
  ls-type:: annotation
  hl-page:: 36
  hl-color:: yellow
  id:: 63b2b5b6-7baf-469b-8940-ba9e1feeb5c8
- <script>元素有下列 8 个属性。
  ls-type:: annotation
  hl-page:: 36
  hl-color:: yellow
  id:: 63b2b632-3923-406f-bc11-55d8bef81d2f
- 值是 module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字
  ls-type:: annotation
  hl-page:: 37
  hl-color:: yellow
  id:: 63b2b807-b7a9-4cee-9ae8-21fa39d50bf7
- 在网页中嵌入 JavaScript 代码
  ls-type:: annotation
  hl-page:: 37
  hl-color:: yellow
  id:: 63b2b848-1988-4c32-898c-f89dcc2d7705
- 在网页中包含外部 JavaScript 文件
  ls-type:: annotation
  hl-page:: 37
  hl-color:: yellow
  id:: 63b2b852-0d55-451f-90c1-664c6c8d3b89
- 在<script>元素中的代码被计算完成之前，页面的其余内容不会被加载，也不会被显示。
  ls-type:: annotation
  hl-page:: 37
  hl-color:: yellow
  id:: 63b2b882-4075-4556-8e7e-c0b775e7fce4
- 第二个<script>元素的代码必须在第一个<script>元素的代码解释完毕才能开始解释
  ls-type:: annotation
  hl-page:: 38
  hl-color:: yellow
  id:: 63b2b945-51a9-4d19-83ea-b59de7a0419e
- 异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded（参见第 17 章）之前或之后
  ls-type:: annotation
  hl-page:: 40
  hl-color:: yellow
  id:: 63b2baa2-90fc-4cc9-a5ce-fd06e5e8b8a8
- CDATA 块表示文档中可以包含任意文本的区块，其内容不作为标签来解析
  ls-type:: annotation
  hl-page:: 41
  hl-color:: yellow
  id:: 63b2bce3-96e7-428a-88d8-e466c155377e
- 行内代码与外部文件
  ls-type:: annotation
  hl-page:: 43
  hl-color:: yellow
  id:: 63b2be3b-1da2-4deb-9e8d-caa480fc8785
- 文档模式
  ls-type:: annotation
  hl-page:: 43
  hl-color:: yellow
  id:: 63b2beaf-d402-4c5d-af7d-b81224b2baa6
- <noscript>元素
  ls-type:: annotation
  hl-page:: 44
  hl-color:: yellow
  id:: 63b2bfb2-2199-4581-89bd-f3576abbcc2e
- 小结
  ls-type:: annotation
  hl-page:: 45
  hl-color:: yellow
  id:: 63b2c01d-5344-40be-8f93-efdd431c2850
- 语法
  ls-type:: annotation
  hl-page:: 46
  hl-color:: yellow
  id:: 63b2c02e-5e10-4c6e-bbcc-09781f20d1c8
- 第一个字符必须是一个字母、下划线（_）或美元符号（$
  ls-type:: annotation
  hl-page:: 46
  hl-color:: yellow
  id:: 63b2c143-f380-449a-9d14-1d0111652505
- 剩下的其他字符可以是字母、下划线、美元符号或数字。
  ls-type:: annotation
  hl-page:: 46
  hl-color:: yellow
  id:: 63b2c14b-cdcd-4d85-8bfc-25c5c35f5344
- 字母可以是扩展 ASCII（Extended ASCII）中的字母，也可以是 Unicode 的字母字符
  ls-type:: annotation
  hl-page:: 46
  hl-color:: yellow
  id:: 63b2c159-be86-44a0-81fa-3335a79dad4c
- 关键字与保留字
  ls-type:: annotation
  hl-page:: 48
  hl-color:: yellow
  id:: 63b2c224-ee25-4295-924d-681baeab0bfc
- 变量
  ls-type:: annotation
  hl-page:: 49
  hl-color:: yellow
  id:: 63b2c2af-586d-48d9-b557-ea2945eeb0df
- 不初始化的情况下，变量会保存一个特殊值 undefined
  ls-type:: annotation
  hl-page:: 49
  hl-color:: yellow
  id:: 63b2c6b3-a8e4-43ef-955c-47b90da7a251
- 去掉之前的 var 操作符之后，message 就变成了全局变量
  ls-type:: annotation
  hl-page:: 49
  hl-color:: yellow
  id:: 63b2c71d-72b8-4d0d-9bed-480fb3a1298b
- 在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 ReferenceError
  ls-type:: annotation
  hl-page:: 50
  hl-color:: yellow
  id:: 63b2c780-7808-4dca-b890-89f48372508d
- 暂时性死区
  ls-type:: annotation
  hl-page:: 51
  hl-color:: yellow
  id:: 63b2ca8d-2353-42a7-bc7c-37a67271640d
- 在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone）
  ls-type:: annotation
  hl-page:: 51
  hl-color:: yellow
  id:: 63b2caeb-3bf4-449b-9dc1-d86bf9e74a59
- 全局声明
  ls-type:: annotation
  hl-page:: 52
  hl-color:: yellow
  id:: 63b2cb48-0aa3-4639-9713-5c741bdbefb8
- 使用 let 在全局作用域中声明的变量不会成为 window 对象的属性
  ls-type:: annotation
  hl-page:: 52
  hl-color:: yellow
  id:: 63b2cb56-8354-47b0-8489-541496027a2d
- 条件声明
  ls-type:: annotation
  hl-page:: 52
  hl-color:: yellow
  id:: 63b2cba1-1a8f-4b1d-91d4-500e2e1b8ca6
- let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它
  ls-type:: annotation
  hl-page:: 52
  hl-color:: yellow
  id:: 63b2cbf9-c5a8-49ff-b3ab-65f72bda1b55
- 使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量
  ls-type:: annotation
  hl-page:: 53
  hl-color:: yellow
  id:: 63b2cc82-b07e-45c4-bddd-e57dc456e8fa
- 数据类型
  ls-type:: annotation
  hl-page:: 55
  hl-color:: yellow
  id:: 63b2ce0b-773e-47c9-9a8d-06723ccd57f5
- 包含 undefined 值的变量跟未定义变量是有区别的
  ls-type:: annotation
  hl-page:: 56
  hl-color:: yellow
  id:: 63b2d02b-ee53-4807-908d-42401e383cc3
- undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等
  ls-type:: annotation
  hl-page:: 57
  hl-color:: yellow
  id:: 63b2d116-477f-467a-98c9-73c1f5b063b9
- 将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数
  ls-type:: annotation
  hl-page:: 58
  hl-color:: yellow
  id:: 63b2d164-21ec-463d-b49b-016d43a404de
- 存储浮点值使用的内存空间是存储整数值的两倍
  ls-type:: annotation
  hl-page:: 59
  hl-color:: yellow
  id:: 63b2d236-e39f-4878-ba54-b165e432fc5d
- 在小数点后面没有数字的情况下，数值就会变成整数
  ls-type:: annotation
  hl-page:: 59
  hl-color:: yellow
  id:: 63b2d240-d46f-4644-9efc-382194f42961
- 默认情况下，ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法
  ls-type:: annotation
  hl-page:: 59
  hl-color:: yellow
  id:: 63b2d2a8-dd78-4795-adef-a467920361f3
- 如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值
  ls-type:: annotation
  hl-page:: 60
  hl-color:: yellow
  id:: 63b2d380-b580-4176-b70b-81ad8a00b250
- 要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用 isFinite()函数
  ls-type:: annotation
  hl-page:: 60
  hl-color:: yellow
  id:: 63b2d39a-d584-45bc-bbbb-542e8b30fbea
- 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。
  ls-type:: annotation
  hl-page:: 61
  hl-color:: yellow
  id:: 63b2d5a3-1649-4e5b-8bc4-145523e4dc59
- 专注于字符串是否包含数值模式
  ls-type:: annotation
  hl-page:: 62
  hl-color:: yellow
  id:: 63b2d5bc-6200-4bab-a417-0f0c59494ebb
- 如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN
  ls-type:: annotation
  hl-page:: 62
  hl-color:: yellow
  id:: 63b2d6c1-19cc-49fd-bb17-07aca65763c0
- 如果你不确定一个值是不是 null 或 undefined，可以使用 String()转型函数，它始终会返回表示相应类型值的字符串
  ls-type:: annotation
  hl-page:: 65
  hl-color:: yellow
  id:: 63b2d858-d53a-4a08-a2ca-b840bd80b9c8
- 模板字面量会保持反引号内部的空格
  ls-type:: annotation
  hl-page:: 66
  hl-color:: yellow
  id:: 63b2d8f4-e69e-4943-ba74-0f539beb636e
- 技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式
  ls-type:: annotation
  hl-page:: 66
  hl-color:: yellow
  id:: 63b2d922-fdd9-46d5-8692-ca070c5df4c5
- 直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示
  ls-type:: annotation
  hl-page:: 68
  hl-color:: yellow
  id:: 63b2dac7-5456-4a3b-a568-4cbe18d9b5d1
- 即字符串数组的.raw 属性取得每个字符串的原始内容
  ls-type:: annotation
  hl-page:: 69
  hl-color:: yellow
  id:: 63b2db65-ce96-4e92-a064-93f2a78c0db2
- 符号需要使用 Symbol()函数初始化
  ls-type:: annotation
  hl-page:: 69
  hl-color:: yellow
  id:: 63b2dba6-e1d5-4e16-b16e-506020667547
- 可以传入一个字符串参数作为对符号的描述（description）
  ls-type:: annotation
  hl-page:: 69
  hl-color:: yellow
  id:: 63b2dbc5-4267-4217-9b93-f2286abbf272
- Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dbfb-4f18-48fe-a535-fdd9adcea9af
- 使用全局符号注册表
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dc64-6d9d-4cec-997e-26fc9331f535
- 字符串键都执行幂等操作
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dc7f-b846-4f2e-9258-701ff3d23e95
- 发现存在与该字符串对应的符号，然后就会返回该符号实例
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dc92-fba9-44fe-af62-ddfc416dfb87
- 即使采用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol()定义的符号也并不等同：
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dca3-cc8a-472e-9930-9e815badfcc1
- 作为参数传给 Symbol.for()的任何值都会被
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dcb5-a383-4d3e-b0b2-c3e4bfc7a0c0
- 转换为字符串
  ls-type:: annotation
  hl-page:: 71
  hl-color:: yellow
  id:: 63b2dcb7-e0ac-49b2-9cf1-f8ce05cbf2f6
- 使用符号作为属性
  ls-type:: annotation
  hl-page:: 71
  hl-color:: yellow
  id:: 63b2dd0b-e24e-4223-908b-3519659a88f7
- Object.getOwnPropertyNames()返回对象实例的常规属性数组
  ls-type:: annotation
  hl-page:: 71
  hl-color:: yellow
  id:: 63b2de45-08d5-44cf-961c-8173f779af1d
- Object.getOwnPropertySymbols()返回对象实例的符号属性数组
  ls-type:: annotation
  hl-page:: 71
  hl-color:: yellow
  id:: 63b2de4f-0594-406c-942b-d22c73908ef3
- Reflect.ownKeys()会返回两种类型的键
  ls-type:: annotation
  hl-page:: 71
  hl-color:: yellow
  id:: 63b2df37-528a-41e6-b5d4-81bb8c11c412
- 常用内置符号
  ls-type:: annotation
  hl-page:: 72
  hl-color:: yellow
  id:: 63b2df6e-5853-49cf-849b-42994aa2362d
- 所有内置符号属性都是不可写、不可枚举、不可配置的
  ls-type:: annotation
  hl-page:: 72
  hl-color:: yellow
  id:: 63b2dfcc-3e24-4925-a808-24830df6ae31
- Symbol.asyncIterator
  ls-type:: annotation
  hl-page:: 73
  hl-color:: yellow
  id:: 63b2dfd3-9011-4aaa-b512-0c5373d2068d
- 由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回 Promise 实例
  ls-type:: annotation
  hl-page:: 73
  hl-color:: yellow
  id:: 63b2e04a-bfc5-4d89-ab2b-906c6875b418
- 可以通过显式地调用 next()方法返回，也可以隐式地通过异步生成器函数返回
  ls-type:: annotation
  hl-page:: 73
  hl-color:: yellow
  id:: 63b2e052-4203-493b-918d-78d0aca430dc
- Symbol.hasInstance
  ls-type:: annotation
  hl-page:: 73
  hl-color:: yellow
  id:: 63b2e05d-97d4-46a9-92bd-3da8a822843f
- 以 Symbol. hasInstance 为键的函数会执行同样的操作，只是操作数对调了一下
  ls-type:: annotation
  hl-page:: 74
  hl-color:: yellow
  id:: 63b2e0f1-04d4-4070-a5f9-4a497a591d66
- Symbol.isConcatSpreadable
  ls-type:: annotation
  hl-page:: 74
  hl-color:: yellow
  id:: 63b2e132-c0f1-4bad-b02e-d740bf26ead5
- 数组对象默认情况下会被打平到已有的数组，false 或假值会导致整个对象被追加到数组末尾
  ls-type:: annotation
  hl-page:: 74
  hl-color:: yellow
  id:: 63b2e1b2-385e-4d8c-aaa0-1a9cd9997fec
- 类数组对象默认情况下会被追加到数组末尾，true 或真值会导致这个类数组对象被打平到数组实例
  ls-type:: annotation
  hl-page:: 74
  hl-color:: yellow
  id:: 63b2e1be-0837-46ba-831b-64e18ae16a90
- Symbol.iterator
  ls-type:: annotation
  hl-page:: 75
  hl-color:: yellow
  id:: 63b2e1d8-dabf-4cee-9f24-52cb3c085e07
- Symbol.match
  ls-type:: annotation
  hl-page:: 76
  hl-color:: yellow
  id:: 63b2e278-90d0-43f2-8af2-38243a38b3e6
- 由 String.prototype.match()方法使用
  ls-type:: annotation
  hl-page:: 76
  hl-color:: yellow
  id:: 63b2e291-390a-4201-a6ea-5349d3244fd8
- 给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象
  ls-type:: annotation
  hl-page:: 76
  hl-color:: yellow
  id:: 63b2e2c1-29f4-4c9a-abb8-02ca7b6f8d33
- Symbol.replace
  ls-type:: annotation
  hl-page:: 76
  hl-color:: yellow
  id:: 63b2e303-fad1-4d25-ba7f-5591e4ab3acf
- Symbol.search
  ls-type:: annotation
  hl-page:: 77
  hl-color:: yellow
  id:: 63b2e30c-64e2-4791-a75b-eb1c92f14700
- Symbol.species
  ls-type:: annotation
  hl-page:: 78
  hl-color:: yellow
  id:: 63b2e314-c257-462f-86e2-fd3c1ff6ecc9
- Symbol.split
  ls-type:: annotation
  hl-page:: 78
  hl-color:: yellow
  id:: 63b2e31c-33fe-4383-9c9c-0e563fed4fd0
- Symbol.toPrimitive
  ls-type:: annotation
  hl-page:: 79
  hl-color:: yellow
  id:: 63b2e326-b3f0-4788-8188-c76e467f7669
- Symbol.toStringTag
  ls-type:: annotation
  hl-page:: 80
  hl-color:: yellow
  id:: 63b2e32d-f7b0-40dd-9feb-656a62b5627e
- Symbol.unscopables
  ls-type:: annotation
  hl-page:: 80
  hl-color:: yellow
  id:: 63b2e33a-5c01-49ca-943d-28de5327e640
- 操作符
  ls-type:: annotation
  hl-page:: 81
  hl-color:: yellow
  id:: 63b2e41a-3d2c-4482-9200-950b5f94ac6b
- 语句
  ls-type:: annotation
  hl-page:: 98
  hl-color:: yellow
  id:: 63b2e434-f487-4760-9c5e-4ecaff09863a
- 函数
  ls-type:: annotation
  hl-page:: 105
  hl-color:: yellow
  id:: 63b2e447-e5b9-444f-8f5c-d921d3e0620f
- ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值。
  ls-type:: annotation
  hl-page:: 81
  hl-color:: yellow
  id:: 63b56867-a1cd-41c8-a2a4-ba4bd7a63c5e
- 一元操作符
  ls-type:: annotation
  hl-page:: 81
  hl-color:: yellow
  id:: 63b56880-ea21-4536-81d1-64b24c3bd484
- 递增/递减操作符
  ls-type:: annotation
  hl-page:: 82
  hl-color:: yellow
  id:: 63b5688f-eb0a-402b-8d6c-d2c8489c0952
- 一元加和减
  ls-type:: annotation
  hl-page:: 83
  hl-color:: yellow
  id:: 63b5695c-1e36-4518-b9bb-5d43cedd7bee
- 位操作符
  ls-type:: annotation
  hl-page:: 84
  hl-color:: yellow
  id:: 63b56a1d-2843-482b-bd41-8bdca0730fb2
- ECMAScript中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32 位整数，再进行位操作，之后再把结果转换为 64 位
  ls-type:: annotation
  hl-page:: 84
  hl-color:: yellow
  id:: 63b56a37-f75d-4ff2-a0ab-1b4cbf926723
- 有符号整数使用 32 位的前 31 位表示整数值
  ls-type:: annotation
  hl-page:: 84
  hl-color:: yellow
  id:: 63b56a43-8c13-41ac-be50-ecc34c72141d
- 负值以一种称为二补数（或补码）的二进制编码存储。
  ls-type:: annotation
  hl-page:: 85
  hl-color:: yellow
  id:: 63b56ada-2d40-4978-ac32-6d46adcd9aed
- 无符号整数来说，第 32 位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了
  ls-type:: annotation
  hl-page:: 85
  hl-color:: yellow
  id:: 63b56b2f-fb7e-4790-8596-5730cd210065
- 特殊值 NaN 和 Infinity在位操作中都会被当成 0 处理
  ls-type:: annotation
  hl-page:: 86
  hl-color:: yellow
  id:: 63b56b7e-3f77-4ca4-a68d-5cc958be6033
- 用波浪符（~）表示
  ls-type:: annotation
  hl-page:: 86
  hl-color:: yellow
  id:: 63b56c2a-55d6-4c24-9c5f-9e5bd784fb5d
- 对数值取反并减 1
  ls-type:: annotation
  hl-page:: 86
  hl-color:: yellow
  id:: 63b56c36-f313-4f94-809b-b58a60e7207f
- 用和号（&）表示
  ls-type:: annotation
  hl-page:: 86
  hl-color:: yellow
  id:: 63b56d01-cff7-4faf-8f55-8953bcf4647f
- 用管道符（|）表示
  ls-type:: annotation
  hl-page:: 86
  hl-color:: yellow
  id:: 63b56db9-61e2-45cb-9890-80a782a1f261
- 用脱字符（^）表示
  ls-type:: annotation
  hl-page:: 87
  hl-color:: yellow
  id:: 63b56ed8-794d-422c-94e9-52f44a343250
- 用两个小于号（<<）表示
  ls-type:: annotation
  hl-page:: 87
  hl-color:: yellow
  id:: 63b56ee6-e3ba-49aa-9c3b-55d67a54e72d
- 左移会保留它所操作数值的符号
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b56f28-3254-402d-b871-c687c177f12d
- 有符号右移
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b56f44-9259-4950-a317-2c739e2227f8
- 由两个大于号（>>）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）。
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b56f50-fe08-4cda-ac42-c64dc84126af
- 无符号右移
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b56fae-3f05-4672-abf9-4cd9f33effba
- ECMAScript 会用符号位的值来填充这些空位，以得到完整的数值
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b56fca-0bcc-4e34-acdc-9397c6764441
- 用 3 个大于号表示（>>>）
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b5700a-7f95-4ede-a927-1fe327cca27f
- 布尔操作符
  ls-type:: annotation
  hl-page:: 89
  hl-color:: yellow
  id:: 63b571ab-1933-4e99-bc18-af510e70b1db
- 逻辑非
  ls-type:: annotation
  hl-page:: 89
  hl-color:: yellow
  id:: 63b571c0-0583-4399-939b-23011d3c0b09
- 逻辑与
  ls-type:: annotation
  hl-page:: 89
  hl-color:: yellow
  id:: 63b573cd-6484-4c8f-80b5-9a3e911dff55
- 由两个和号（&&）表示
  ls-type:: annotation
  hl-page:: 89
  hl-color:: yellow
  id:: 63b5746e-f392-47f8-99c7-87da08d949b9
- 逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。
  ls-type:: annotation
  hl-page:: 90
  hl-color:: yellow
  id:: 63b574e0-5cca-49af-85d3-7d5d42270248
- 逻辑或
  ls-type:: annotation
  hl-page:: 90
  hl-color:: yellow
  id:: 63b575ca-9c01-4bac-a479-75d1d22dd7f3
- 由两个管道符（||）表示
  ls-type:: annotation
  hl-page:: 90
  hl-color:: yellow
  id:: 63b575e1-8c58-4769-9372-528e7d96dc84
- let myObject = preferredObject || backupObject;
  ls-type:: annotation
  hl-page:: 91
  hl-color:: yellow
  id:: 63b576d2-48cc-47db-854b-0d1112f997d2
- 乘性操作符
  ls-type:: annotation
  hl-page:: 91
  hl-color:: yellow
  id:: 63b578db-a9c5-4434-9165-464e20ca8815
- 乘法操作符
  ls-type:: annotation
  hl-page:: 91
  hl-color:: yellow
  id:: 63b579e6-8fe0-4217-9801-72ae12bc4bb6
- 除法操作符
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b579fa-4898-4ccd-a12a-7a71b2b0a432
- 取模操作符
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b57a0f-9f3f-45ad-94e0-5c558632e5c7
- 由一个百分比符号（%）表示
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b57a1a-5c4f-4511-b005-c8f617d1336c
- 指数操作符
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b57adf-beb6-4c01-9746-4320ce30c8bf
- 操作符**
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b57af8-d0ad-4a66-98f0-086b290dc163
- 指数赋值操作符**=
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b57aff-38dd-4ce0-8335-f4a0c167564d
- 加性操作符
  ls-type:: annotation
  hl-page:: 93
  hl-color:: yellow
  id:: 63b57b35-eb63-4ec3-843d-1c8a499c46e4
- 加法操作符
  ls-type:: annotation
  hl-page:: 93
  hl-color:: yellow
  id:: 63b57b48-7df0-4a5f-ab16-b9f63052fef7
- 如果是 Infinity 加-Infinity，则返回 NaN；
  ls-type:: annotation
  hl-page:: 93
  hl-color:: yellow
  id:: 63b57bc1-d452-4d08-8f27-b5efa71a3a78
- 如果是-0 加+0，则返回+0；
  ls-type:: annotation
  hl-page:: 93
  hl-color:: yellow
  id:: 63b57c1b-a0a9-4e12-93c5-f80440b5ce97
- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。
  ls-type:: annotation
  hl-page:: 93
  hl-color:: yellow
  id:: 63b57c56-f1e8-4a0c-910f-7bb789cf9d34
- 减法操作符
  ls-type:: annotation
  hl-page:: 94
  hl-color:: yellow
  id:: 63b57ce7-4317-49d8-b6e8-b9570bdd85e2
- 如果是+0 减-0，则返回-0
  ls-type:: annotation
  hl-page:: 94
  hl-color:: yellow
  id:: 63b57cfa-16d3-4d38-8906-054d36ecc82a
- 如果是-0 减-0，则返回+0
  ls-type:: annotation
  hl-page:: 94
  hl-color:: yellow
  id:: 63b57d14-0d4d-4a87-9272-463165868f47
- 如果是-Infinity 减-Infinity，则返回 NaN。
  ls-type:: annotation
  hl-page:: 94
  hl-color:: yellow
  id:: 63b57d27-24e1-4cf9-bc3b-347242195e80
- 关系操作符
  ls-type:: annotation
  hl-page:: 94
  hl-color:: yellow
  id:: 63b57d6f-81a0-452d-874b-df87a4dde944
- 相等操作符
  ls-type:: annotation
  hl-page:: 95
  hl-color:: yellow
  id:: 63b57fa3-3c9c-4908-9597-586c2b0c5cce
- null 和 undefined 相等。
  ls-type:: annotation
  hl-page:: 96
  hl-color:: yellow
  id:: 63b58071-56c1-46a8-a015-c4233a933ab6
- NaN != NaN true
  ls-type:: annotation
  hl-page:: 96
  hl-color:: yellow
  id:: 63b58093-dff1-4302-9b29-f4abb2898109
- let result2 = ("55" === 55); // false，不相等，因为数据类型不同
  ls-type:: annotation
  hl-page:: 96
  hl-color:: yellow
  id:: 63b580c7-fd7c-4818-858d-92356f01b507
- null === undefined 是 false，因为它们不是相同的数据类型。
  ls-type:: annotation
  hl-page:: 97
  hl-color:: yellow
  id:: 63b580d6-05f3-4713-a027-146e5ffc7363
- 条件操作符
  ls-type:: annotation
  hl-page:: 97
  hl-color:: yellow
  id:: 63b580dd-4b0a-44b4-acde-7f378162f9e9
- 赋值操作符
  ls-type:: annotation
  hl-page:: 97
  hl-color:: yellow
  id:: 63b580f3-c054-4223-bc53-f04577b9a8fc
- 逗号操作符
  ls-type:: annotation
  hl-page:: 98
  hl-color:: yellow
  id:: 63b580fb-16f2-4874-bb47-01a959304e3c
- variable = boolean_expression ? true_value : false_value;
  ls-type:: annotation
  hl-page:: 97
  hl-color:: yellow
  id:: 63b5810f-4e1e-4edd-b792-127271bcf3e5
- 使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：
  ls-type:: annotation
  hl-page:: 98
  hl-color:: yellow
  id:: 63b582cf-eb35-4c15-9337-bf4c081f9d2d
- if 语句
  ls-type:: annotation
  hl-page:: 98
  hl-color:: yellow
  id:: 63b58321-da1c-40e8-b506-5e6d7f3339d7
- do-while 语句
  ls-type:: annotation
  hl-page:: 99
  hl-color:: yellow
  id:: 63b58336-fee9-4ce9-920c-b9e67dce1059
- while 语句
  ls-type:: annotation
  hl-page:: 99
  hl-color:: yellow
  id:: 63b5833e-c903-4938-a353-fb73f3789254
- for 语句
  ls-type:: annotation
  hl-page:: 99
  hl-color:: yellow
  id:: 63b58346-c7ce-4857-930a-7dded1639c4f
- for-in 语句
  ls-type:: annotation
  hl-page:: 100
  hl-color:: yellow
  id:: 63b58352-12a2-4b13-9251-ede479c39ec8
- for-of 语句
  ls-type:: annotation
  hl-page:: 101
  hl-color:: yellow
  id:: 63b58361-8f28-463a-ab1f-2a525e5353f0
- 标签语句
  ls-type:: annotation
  hl-page:: 101
  hl-color:: yellow
  id:: 63b5836c-f673-4414-9de3-9309ff40a6b9
- break 和 continue 语句
  ls-type:: annotation
  hl-page:: 101
  hl-color:: yellow
  id:: 63b58376-a637-4872-805c-61cf3504bc11
- with 语句
  ls-type:: annotation
  hl-page:: 103
  hl-color:: yellow
  id:: 63b58387-dd7e-4b5c-bd34-19956c9b66d4
- switch 语句
  ls-type:: annotation
  hl-page:: 103
  hl-color:: yellow
  id:: 63b58395-70fc-4d6c-b5df-6e394204a48b
- for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体。
  ls-type:: annotation
  hl-page:: 101
  hl-color:: yellow
  id:: 63ba22a7-2d98-405a-860f-8ace3b57b7f2
- break 和 continue 都可以与标签语句一起使用，返回代码中特定的位置。这通常是在嵌套循环中
  ls-type:: annotation
  hl-page:: 102
  hl-color:: yellow
  id:: 63ba2626-24a8-4a18-b487-1c2ffac39fa4
- ECMAScript 中的函数不需要指定是否返回值。任何函数在任何时间都可以使用 return 语句来返回函数的值，用法是后跟要返回的值
  ls-type:: annotation
  hl-page:: 106
  hl-color:: yellow
  id:: 63ba2fb8-5815-483f-8c79-07b7ec2e4123
- 原始值与引用值
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc00e6-7457-464c-b735-9fce29da28e7
- 原始值（primitive value）就是最简单的数据
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc00fb-de43-412c-93f2-e5c74c7f8346
- 引用值（reference value）则是由多个值构成的对象
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc0102-b67e-4721-964a-0707147bb228
- JavaScript 不允许直接访问内存位置
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc0123-30e5-4902-b42e-b18b1be1fb87
- 。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc0133-d23b-4dcf-8537-4ac727b24273
- 在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例。
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc0183-6944-43e0-9cd5-de3cadea3c20
- 动态属性
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc018d-50be-4577-917f-7c0f3b8aa5d3
- 原始值不能有属性，尽管尝试给原始值添加属性不会报错
  ls-type:: annotation
  hl-page:: 109
  hl-color:: yellow
  id:: 63bc01c8-546e-4484-8811-6bcbb696e597
- 原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，
  ls-type:: annotation
  hl-page:: 109
  hl-color:: yellow
  id:: 63bc01e8-bef1-4167-bf71-30ab4f9cb180
- 在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象
  ls-type:: annotation
  hl-page:: 110
  hl-color:: yellow
  id:: 63bc0206-c2f8-4455-99ba-ac8b79767fdb
- 参数 num 和变量 count 互不干扰，它们只不过碰巧保存了一样的值
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc0240-8ab0-4374-85ab-e6712dd90fcf
- 果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc0253-1c15-4505-9b70-fc727b7942ec
- 因为 obj 指向的对象保存在全局作用域的堆内存上
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc025c-b408-416c-b4e2-83c2a9e5c353
- 如果 person 是按引用传递的，那么 person 应该自动将指针改为指向 name 为"Greg"的对象。
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc02c7-95ed-43d9-8469-16103eaf13b3
- ECMAScript 中函数的参数就是局部变量。
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc02ca-9e82-45bc-97cb-83f9bd6953d6
- 复制值
  ls-type:: annotation
  hl-page:: 109
  hl-color:: yellow
  id:: 63bc0329-7793-46b6-88a8-74bacb1af594
- 传递参数
  ls-type:: annotation
  hl-page:: 110
  hl-color:: yellow
  id:: 63bc0334-9135-46fa-823d-50197cc6db07
- ECMAScript 中所有函数的参数都是按值传递的
  ls-type:: annotation
  hl-page:: 110
  hl-color:: yellow
  id:: 63bc0347-abea-4a3a-9996-d4c660f72ea8
- 确定类型
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc0350-2c24-4ed9-b206-9e7d7062f6e3
- 如果用 instanceof 检测原始值，则始终会返回 false，因为原始值不是对象
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc0411-ef6d-4a96-ad36-6206d2d6837e
- typeof 操作符在用于检测函数时也会返回"function"
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc0428-bec7-4538-b864-d457a1e4311f
- 在 IE 和 Firefox 中，typeof 对正则表达式返回"object"。
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc0438-ea70-4f0e-845a-aef946d8a7e7
- 执行上下文与作用域
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc0452-9e02-4750-acf8-a591f04e3eca
- 每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc04a4-645c-4661-bfc8-e33a0a0edfaa
- 全局上下文是最外层的上下文
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc05c8-1af4-423b-8be8-d1ddf1ccde6b
- 每个函数调用都有自己的上下文
  ls-type:: annotation
  hl-page:: 113
  hl-color:: yellow
  id:: 63bc0746-f5a1-46b3-a025-1e6d825d0d3b
- 上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）
  ls-type:: annotation
  hl-page:: 113
  hl-color:: yellow
  id:: 63bc079d-1d56-456c-9361-ebf32137318c
- 如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）
  ls-type:: annotation
  hl-page:: 113
  hl-color:: yellow
  id:: 63bc07af-6caa-4ed9-ac8f-1d50b0b85dd9
- 全局上下文的变量对象始终是作用域链的最后一个变量对象。
  ls-type:: annotation
  hl-page:: 113
  hl-color:: yellow
  id:: 63bc07c4-cb75-47f4-8b43-1d688ef70add
- 这个函数内部之所以能够访问变量 color，就是因为可以在作用域链中找到它。
  ls-type:: annotation
  hl-page:: 113
  hl-color:: yellow
  id:: 63bc0863-6127-4217-ae8f-1a0f1858c348
- 全局上下文、changeColor()的局部上下文和 swapColors()的局部上下文。
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc088e-11af-43a8-8ca1-222f83f972da
- 。全局上下文和 changeColor()的局部上下文都无法访问到 tempColor
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc089b-b1a8-4924-89a3-720a4041840f
- 但外部上下文无法访问内部上下文中的任何东西
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc08c4-f2cf-4318-8519-82f41fba50e2
- 作用域链增强
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc08d5-5485-4359-9a24-1f7e7d232c03
- 某些语句会导致在作用域链前端临时添加一个上下文
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc0913-b2b2-4f86-991f-2483259306bd
- try/catch 语句的 catch 块
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc0923-246e-4534-a835-5b45d1adb370
- with 语句
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc0929-a5cc-4993-9d2e-13125171579a
- location 会被添加到作用域链前端
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc097b-86b5-4f3e-8ebe-9735bc15f303
- with 语句中的代码引用变量 href 时，实际上引用的是 location.href，也就是自己变量对象的属性
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc098c-0f66-4e9b-9c2e-7d34d2f7b94b
- 变量声明
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc0a34-2963-402d-ab4c-3ed9c11c6c84
- ES6 不仅增加了 let 和 const 两个关键字，而且还让这两个关键字压倒性地超越 var成为首选。
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc0a47-6c43-4097-9714-6dc2cfded1b8
- 在使用 var 声明变量时，变量会被自动添加到最接近的上下文
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc0ad4-7a11-41bc-9bea-5bd8effd83e5
- 如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc0b02-d799-471d-9f4b-659f64cc4686
- var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。
  ls-type:: annotation
  hl-page:: 116
  hl-color:: yellow
  id:: 63bc0be4-bdca-4f6e-9e89-c813c1010c42
- let 与 var 的另一个不同之处是在同一作用域内不能声明两次
  ls-type:: annotation
  hl-page:: 117
  hl-color:: yellow
  id:: 63bc0c2d-e78e-445e-be5a-8893dcf9e022
- 在其生命周期的任何时候都不能再重新赋予新值
  ls-type:: annotation
  hl-page:: 117
  hl-color:: yellow
  id:: 63bc0c8d-0699-4505-85da-64170ce49791
- ，赋值为对象的 const 变量不能再被重新赋值为其他引用值
  ls-type:: annotation
  hl-page:: 118
  hl-color:: yellow
  id:: 63bc0cdb-1f30-426e-b3b6-31d840880b9e
- 垃圾回收
  ls-type:: annotation
  hl-page:: 119
  hl-color:: yellow
  id:: 63bc0db2-6a64-4939-a798-94f1043416b7
- 标记清理
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc0dc5-d9c7-411d-b66a-55ab13e4625a
- 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc0f52-6311-4d99-9bba-e863b361e33e
- 引用计数
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc0f5e-7bef-4c35-91f6-d02818ac434d
- 如果同一个值又被赋给另一个变量，那么引用数加 1
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc1137-3920-4f59-b512-d471262495f2
- 如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc1140-2c06-4469-b08e-bf62922610a3
- 所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc115c-f35c-42d7-a1e4-8e43fa7d53bf
- 为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接。
  ls-type:: annotation
  hl-page:: 121
  hl-color:: yellow
  id:: 63bc11cf-c53c-4d11-81be-01171fafb985
- 性能
  ls-type:: annotation
  hl-page:: 121
  hl-color:: yellow
  id:: 63bc11d8-86fd-4c8e-82e8-83f8ab1dc595
- 垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。
  ls-type:: annotation
  hl-page:: 121
  hl-color:: yellow
  id:: 63bc1231-86f5-4e72-8ad3-d132f0d86743
- 一次完整的垃圾回收之后，V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收
  ls-type:: annotation
  hl-page:: 121
  hl-color:: yellow
  id:: 63bc127a-7518-4648-b954-a8b05c39fe44
- IE7 发布后，JavaScript 引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值
  ls-type:: annotation
  hl-page:: 122
  hl-color:: yellow
  id:: 63bc1292-b061-4e55-99f8-d4fe3ef100a3
- 内存管理
  ls-type:: annotation
  hl-page:: 122
  hl-color:: yellow
  id:: 63bc1371-87ef-49b5-b7d7-7db45049d022
- 优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作解除引用
  ls-type:: annotation
  hl-page:: 122
  hl-color:: yellow
  id:: 63bc1386-0ce9-4e25-9402-5312e820eda5
- 但 globalPerson 是一个全局变量，应该在不再需要时手动解除其引用，最后一行就是这么做的
  ls-type:: annotation
  hl-page:: 122
  hl-color:: yellow
  id:: 63bc1433-5260-4691-989f-15529ed2a735
- 解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。
  ls-type:: annotation
  hl-page:: 122
  hl-color:: yellow
  id:: 63bc1436-4560-44ea-8fa9-a7454704f510
- ，localPerson 作为函数值被返回，并被赋值给 globalPerson。localPerson 在 createPerson()执行完成超出上下文后会
  ls-type:: annotation
  hl-page:: 122
  hl-color:: green
  id:: 63bc1496-38a9-4e29-b833-e60c51387f89
- 隐藏类和删除操作
  ls-type:: annotation
  hl-page:: 123
  hl-color:: yellow
  id:: 63bc15e5-dfca-4a4e-95b5-31706aa5c48d
- 最佳实践是把不想要的属性设置为 null。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果
  ls-type:: annotation
  hl-page:: 123
  hl-color:: yellow
  id:: 63bc160b-4f6d-46fd-869a-e6e99031f8a5
- 意外声明全局变量是最常见但也最容易修复的内存泄漏问题
  ls-type:: annotation
  hl-page:: 124
  hl-color:: yellow
  id:: 63bc165a-b480-45c0-a458-5a3e3ff096b1
- 定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量
  ls-type:: annotation
  hl-page:: 124
  hl-color:: yellow
  id:: 63bc1676-162a-4c17-a2c9-ce3fca2948dc
- 使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏
  ls-type:: annotation
  hl-page:: 124
  hl-color:: yellow
  id:: 63bc1782-8e34-468e-a63e-a1e014cae268
- 如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行
  ls-type:: annotation
  hl-page:: 125
  hl-color:: yellow
  id:: 63bc17c1-c32e-42ed-bc4c-f36e4f02be04
- 不要动态创建矢量对象，比如可以修改上面的函数，让它使用一个已有的矢量对象
  ls-type:: annotation
  hl-page:: 125
  hl-color:: yellow
  id:: 63bc17e3-4c7e-4cfb-ba38-bb854d518fef
- 一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它
  ls-type:: annotation
  hl-page:: 125
  hl-color:: yellow
  id:: 63bc1808-e17f-4aa7-80ed-fd865338a7ed
- 可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作
  ls-type:: annotation
  hl-page:: 126
  hl-color:: yellow
  id:: 63bc1853-a0b0-4d79-9872-cb88dbb70e15
- 小结
  ls-type:: annotation
  hl-page:: 126
  hl-color:: yellow
  id:: 63bc1876-9120-4818-a83b-7ce170667e05
- 在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”
  ls-type:: annotation
  hl-page:: 128
  hl-color:: yellow
  id:: 63bd5ef7-47b4-4519-a0ef-25e198499ea7
- 引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法
  ls-type:: annotation
  hl-page:: 128
  hl-color:: yellow
  id:: 63bd5f3f-a101-4b6b-86e8-9b427b2a5bdc
- Date
  ls-type:: annotation
  hl-page:: 128
  hl-color:: yellow
  id:: 63bd5f4d-d314-4341-92a2-14522ea031c0
- 创建的对象将保存当前日期和时间
  ls-type:: annotation
  hl-page:: 129
  hl-color:: yellow
  id:: 63bd5f86-b6db-444c-a06c-c050c6b857ed
- 继承的方法
  ls-type:: annotation
  hl-page:: 130
  hl-color:: yellow
  id:: 63bd6093-8db6-4e00-a459-c80320068578
- Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间
  ls-type:: annotation
  hl-page:: 130
  hl-color:: yellow
  id:: 63bd60af-148b-4768-b597-494f86b19a41
- toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的
  ls-type:: annotation
  hl-page:: 130
  hl-color:: yellow
  id:: 63bd60ba-2f68-4c3f-ba46-d3d95815cab6
- Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。
  ls-type:: annotation
  hl-page:: 130
  hl-color:: yellow
  id:: 63bd60c7-b957-485d-b16d-683440657ca6
- 日期格式化方法
  ls-type:: annotation
  hl-page:: 131
  hl-color:: yellow
  id:: 63bd6104-68a8-4f04-a2eb-43c7b50922bc
- 日期/时间组件方法
  ls-type:: annotation
  hl-page:: 131
  hl-color:: yellow
  id:: 63bd6117-1e9b-4b45-9bd3-5a798016310b
- RegExp
  ls-type:: annotation
  hl-page:: 132
  hl-color:: yellow
  id:: 63bd6164-4c6b-47d6-950b-0837a7cdab5d
- 与其他语言中的正则表达式类似，所有元字符在模式中也必须转义
  ls-type:: annotation
  hl-page:: 132
  hl-color:: yellow
  id:: 63bd6233-647d-450b-a7c0-f113e829543f
- 正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串
  ls-type:: annotation
  hl-page:: 133
  hl-color:: yellow
  id:: 63bd629a-232c-4b78-aa1d-0d2b6834b66f
- 所有元字符都必须二次转义，包括转义字符序列
  ls-type:: annotation
  hl-page:: 133
  hl-color:: yellow
  id:: 63bd62d4-33c8-458c-ae9e-638849f676e7
- 使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：
  ls-type:: annotation
  hl-page:: 133
  hl-color:: yellow
  id:: 63bd62fe-148a-497b-8776-72675bf24cf4
- RegExp 实例属性
  ls-type:: annotation
  hl-page:: 134
  hl-color:: yellow
  id:: 63bd6322-68b0-413f-8dc6-150213da96b7
- RegExp 实例方法
  ls-type:: annotation
  hl-page:: 134
  hl-color:: yellow
  id:: 63bd6403-0f59-4930-ab58-1ebaaaff423f
- RegExp 实例的主要方法是 exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串
  ls-type:: annotation
  hl-page:: 134
  hl-color:: yellow
  id:: 63bd6413-93f2-4196-bc7e-a75296d50d5b
- 如果模式设置了全局标记，则每次调用 exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息。
  ls-type:: annotation
  hl-page:: 135
  hl-color:: yellow
  id:: 63bd6493-fbf9-4cd8-ae2c-df77963b1134
- 如果在这个模式上设置了 g 标记，则每次调用 exec()都会在字符串中向前搜索下一个匹配项
  ls-type:: annotation
  hl-page:: 135
  hl-color:: yellow
  id:: 63bd64f1-5131-4966-951e-701a7454ae2e
- 这次模式设置了全局标记，因此每次调用 exec()都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。
  ls-type:: annotation
  hl-page:: 135
  hl-color:: yellow
  id:: 63bd653b-f1c2-4e6c-a8dd-6c6eb5d130bd
- 如果模式设置了粘附标记 y，则每次调用 exec()就只会在 lastIndex 的位置上寻找匹配项
  ls-type:: annotation
  hl-page:: 136
  hl-color:: yellow
  id:: 63bd6544-7206-4ca6-8ec2-f059e9d0cebe
- 包含两个额外的属性：index 和 input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串
  ls-type:: annotation
  hl-page:: 134
  hl-color:: yellow
  id:: 63bd65d2-047d-4cc0-80d4-47a579c66cdb
- 正则表达式的另一个方法是 test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 true，否则返回 false。
  ls-type:: annotation
  hl-page:: 136
  hl-color:: yellow
  id:: 63bd66bf-f9fc-4bb2-af99-799ec906130e
- 正则表达式的 valueOf()方法返回正则表达式本身。
  ls-type:: annotation
  hl-page:: 136
  hl-color:: yellow
  id:: 63bd6711-b721-4cfc-a8a9-b231049b9142
- RegExp 构造函数属性
  ls-type:: annotation
  hl-page:: 136
  hl-color:: yellow
  id:: 63bd6718-34dd-4f80-b598-767393920bf7
- 这些属性名也可以替换成简写形式，只不过要使用中括号语法来访问
  ls-type:: annotation
  hl-page:: 137
  hl-color:: yellow
  id:: 63bd676b-e44a-4767-bc65-921e9b42ef9a
- RegExp 还有其他几个构造函数属性，可以存储最多 9 个捕获组的匹配项。这些属性通过 RegExp.$1~RegExp.$9 来访问，分别包含第 1~9 个捕获组的匹配项
  ls-type:: annotation
  hl-page:: 137
  hl-color:: yellow
  id:: 63bd67aa-2dfc-4afd-8127-b63ef6d2147d
- 模式局限
  ls-type:: annotation
  hl-page:: 138
  hl-color:: yellow
  id:: 63bd67b1-e6ba-4a10-8fa7-8f975400506b
- 原始值包装类型
  ls-type:: annotation
  hl-page:: 138
  hl-color:: yellow
  id:: 63bd67ba-0a2b-482f-9fd5-09c6cb182d81
- 引用类型与原始值包装类型的主要区别在于对象的生命周期。
  ls-type:: annotation
  hl-page:: 139
  hl-color:: yellow
  id:: 63bd6801-621f-408e-959e-d557cbabc10e
- 可以显式地使用 Boolean、Number 和 String 构造函数创建原始值包装对象
  ls-type:: annotation
  hl-page:: 139
  hl-color:: yellow
  id:: 63bd6999-8a01-481c-a537-94228c590cb1
- Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。
  ls-type:: annotation
  hl-page:: 139
  hl-color:: yellow
  id:: 63bd69ac-334b-4451-ba98-a72577a750df
- 使用 new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。
  ls-type:: annotation
  hl-page:: 139
  hl-color:: yellow
  id:: 63bd6a04-7d24-4003-accd-e6665b5d00da
- Boolean
  ls-type:: annotation
  hl-page:: 139
  hl-color:: yellow
  id:: 63bd6a0a-dc55-457c-a315-ec5d89622289
- 理解原始布尔值和 Boolean 对象之间的区别非常重要，强烈建议永远不要使用后者
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6a63-8c6b-4643-aad1-f703c2c085ae
- Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调用时也会被覆盖，返回字符串"true"或"false"。
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6a6d-d599-49b1-8609-bafbd724df91
- Number
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6a7f-15d7-4cc9-a596-b05d2dc03968
- let numberObject = new Number(10);
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6ab1-7547-48a2-95b1-24b1c095c160
- toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6ad1-9fc0-4c28-8865-0c0f13009161
- toFixed()方法返回包含指定小数点位数的数值字符串
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6ae1-44bb-4335-9d78-b47a74738552
- toFixed()方法可以表示有 0~20 个小数位的数值。
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6af4-65ff-4413-9c42-0a6fe884b999
- toExponential()，返回以科学记数法（也称为指数记数法）表示的数值字符串。
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b15-8aa3-48dd-9365-541dfb537a39
- toExponential()也接收一个参数，表示结果中小数的位数
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b32-7871-46d2-a66b-bc35154e7ab8
- toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b4b-d86b-472c-8c8e-b310d49c3326
- 接收一个参数，表示结果中数字的总位数（不包含指数）。
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b52-baf1-4730-8eaa-ffe807fe5cf9
- toPrecision()方法可以表示带 1~21 个小数位的数值
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b60-9df9-4832-862d-f7c178454770
- 处理原始数值和引用数值时，typeof 和 instacnceof操作符会返回不同的结果
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b8a-6d5e-4c3d-9338-974ee41a26b5
- ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6b97-f89a-4c3d-b542-00cf173a604d
- console.log(Number.isInteger(1.00)); // true
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6ba9-591b-4b1c-9e94-f8be14b6ff20
- EEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从 Number.MIN_SAFE_INTEGER（253 + 1）到 Number.MAX_SAFE_INTEGER（253  1）。
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6bcd-c4c1-45e8-8f07-e167a57da4bd
- 为了鉴别整数是否在这个范围内，可以使用 Number.isSafeInteger()方法：
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6bd7-f3ca-4a6a-a949-0ffa19c877f6
- String
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6bde-64c7-40df-8ba0-f7cd7dec0499
- 每个 String 对象都有一个 length 属性，表示字符串中字符的数量
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6bec-9d16-452b-bce3-5ddf99a15753
- avaScript 字符
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6c20-254d-42d7-8326-db85580185cc
- 对多数字符来说，每 16 位码元对应一个字符
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6c28-715e-482f-9088-c5745b3b26dd
- charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6c2f-aead-4706-b12c-96aaeba6f4c4
- charCodeAt()方法可以查看指定码元的字符编码
  ls-type:: annotation
  hl-page:: 143
  hl-color:: yellow
  id:: 63bd6c3e-7be3-402a-8ec4-8621a88b3a21
- fromCharCode()方法用于根据给定的 UTF-16 码元创建字符串中的字符
  ls-type:: annotation
  hl-page:: 143
  hl-color:: yellow
  id:: 63bd6c5a-415c-4b44-b3f0-e20168a19697
- 接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串
  ls-type:: annotation
  hl-page:: 143
  hl-color:: yellow
  id:: 63bd6c61-2370-4f51-a2c1-0024d751bad6
- 为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的策略称为代理对。
  ls-type:: annotation
  hl-page:: 143
  hl-color:: yellow
  id:: 63bd6caf-6935-46b9-b6de-a0d5b1433de4
- fromCharCode()方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串
  ls-type:: annotation
  hl-page:: 144
  hl-color:: yellow
  id:: 63bd6cd9-655f-4508-b7d1-ef8dd8b1299c
- codePointAt()接收 16 位码元的索引并返回该索引位置上的码点（code point）。
  ls-type:: annotation
  hl-page:: 144
  hl-color:: yellow
  id:: 63bd6cef-29c4-49eb-aaa3-2b5bb42ff382
- fromCodePoint()。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串
  ls-type:: annotation
  hl-page:: 144
  hl-color:: yellow
  id:: 63bd6d4a-a946-4bef-a116-48050f3413ff
- normalize()方法
  ls-type:: annotation
  hl-page:: 144
  hl-color:: yellow
  id:: 63bd6d53-05af-46b3-95ed-22115f33b894
- 有的字符既可以通过一个 BMP 字符表示，也可以通过一个代理对表示
  ls-type:: annotation
  hl-page:: 144
  hl-color:: yellow
  id:: 63bd6d86-c8c8-415a-8b58-6376112a0160
- 比较操作符不在乎字符看起来是什么样的
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6dbb-dcb2-48fd-bf49-a1bbfee2bbed
- Unicode 提供了 4 种规范化形式
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6dc4-9925-415b-850b-fb7a3efbc526
- 这 4 种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、 NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6dcb-36b0-4ed3-ae50-66e66593a256
- 通过比较字符串与其调用 normalize()的返回值，就可以知道该字符串是否已经规范化了
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6dfc-9983-4888-af4f-eb90fa30c196
- 字符串操作方法
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6e09-9c6c-42d9-8ef7-292fedfc5629
- concat()，用于将一个或多个字符串拼接成一个新字
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6e17-7faa-4cee-9dd3-b65cd9f72d1c
- 。concat()方法可以接收任意多个参数，因此可以一次性拼接多个字符串
  ls-type:: annotation
  hl-page:: 146
  hl-color:: yellow
  id:: 63bd6e65-1ff3-464a-bab5-f859c16878c2
- slice()
  ls-type:: annotation
  hl-page:: 146
  hl-color:: yellow
  id:: 63bd7722-a298-465e-8c99-c8742c9f5a1d
- substr()
  ls-type:: annotation
  hl-page:: 146
  hl-color:: yellow
  id:: 63bd7728-e259-483f-945d-c140d6e087a7
- substring()
  ls-type:: annotation
  hl-page:: 146
  hl-color:: yellow
  id:: 63bd772e-1e5b-489f-ba2c-583b1abce325
- 字符串位置方法
  ls-type:: annotation
  hl-page:: 147
  hl-color:: yellow
  id:: 63bd79d1-5d12-4a4a-87ff-ee0c2f4b8035
- 在字符串中定位子字符串：indexOf()和 lastIndexOf()
  ls-type:: annotation
  hl-page:: 147
  hl-color:: yellow
  id:: 63bd79e0-2ef0-48e7-85cb-2071f9ad997f
- indexOf()方法从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串
  ls-type:: annotation
  hl-page:: 147
  hl-color:: yellow
  id:: 63bd7a0c-7d13-4289-85f5-faf46e8c0ab7
- 二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；lastIndexOf()则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符
  ls-type:: annotation
  hl-page:: 147
  hl-color:: yellow
  id:: 63bd7a4a-a98d-427f-b2c5-50c70171490b
- 这样使用第二个参数并循环调用 indexOf()或 lastIndexOf()，就可以在字符串中找到所有的目标子字符串
  ls-type:: annotation
  hl-page:: 147
  hl-color:: yellow
  id:: 63bd7ae4-32ac-4452-b895-abdc557b3015
- 字符串包含方法
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63bd7af0-4b4f-44ca-a540-2fd9b9e58f06
- trim()方法
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63bd7bc6-c59b-455f-8c14-d6bb897aa3ba
- repeat()方法
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63bd7bcd-7768-42df-aebd-5a6d82d3e905
- padStart()和 padEnd()方法
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63bd7ca6-4499-49e6-88f4-deb48f02348b
- 字符串迭代与解构
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63bd7cac-89a6-4023-8e8a-0d27def4de0e
- 字符串大小写转换
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63bd7cb2-d62d-406d-a6de-c00467ca637d
- 字符串模式匹配方法
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63bd7cba-5169-4e17-9405-d279b72e1d3d
- localeCompare()方法
  ls-type:: annotation
  hl-page:: 152
  hl-color:: yellow
  id:: 63bd7cc4-786d-4f47-8d66-db2d6d8e1140
- HTML 方法
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63bd7ccb-ad4c-4763-acd7-dee7d5cbbe20
- 单例内置对象
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63bd7cd1-3ee4-40e1-808d-9d20f3a6b150
- startsWith(
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63be2ae9-fdc7-46d9-94f3-7d54480829c2
- endsWith()
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63be2b4d-1e65-472b-8577-8c5e54fd809a
- includes()
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63be2b52-3344-4fcf-b748-b76e00a30b7e
- 表示要将字符串复制多少次，然后返回拼接所有副本后的结果
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63be2c17-349a-426d-aa45-6ea7a5fdd7d6
- padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63be2c8a-7b23-4d95-8504-41d40f5a3d79
- 第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63be2c98-0aaf-4d07-aded-27f9f4cc0aa5
- 字符串的原型上暴露了一个@@iterator 方法，表示可以迭代字符串的每个字符。
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63be2dd2-6e68-416d-990f-c87a9fe48a56
- toLowerCase()
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63be2e0a-cbd5-4229-aef2-ed270f1e84f3
- toLocaleLowerCase(
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63be2e19-6739-4df2-8bd6-9715848bfeb4
- toUpperCase()
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2e23-4251-4e8e-9769-ee822ef38c75
- toLocaleUpperCase(
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2e2a-86cc-4504-ad30-cf959c4c3f4a
- match()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2e88-441b-4bbe-b244-39f3df385e19
- 第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2eba-e3fa-4ab5-9aea-578a521549f7
- search()
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2ecc-09ac-475c-bfd3-cce188b7540e
- 返回模式第一个匹配的位置索引，如果没找到则返回1
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2f00-75f9-4064-a07e-49d3e044fa35
- replace()方法
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2f1d-4a7b-41ca-9942-337cf0d0b9fe
- 第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2f5f-3dd0-45d5-9d36-d330c4bb4b3c
- split(
  ls-type:: annotation
  hl-page:: 151
  hl-color:: yellow
  id:: 63be2fa0-7593-489b-a1eb-33040b3e84b3
- 根据传入的分隔符将字符串拆分
  ls-type:: annotation
  hl-page:: 151
  hl-color:: yellow
  id:: 63be2faa-e1d4-41a0-8a46-8d33ba133610
- 第二个参数，即数组大小，确保返回的数组不会超过指定大
  ls-type:: annotation
  hl-page:: 152
  hl-color:: yellow
  id:: 63be30fa-00a8-4d54-925e-78a73ca3417d
- 比较两个字符串
  ls-type:: annotation
  hl-page:: 152
  hl-color:: yellow
  id:: 63be310f-5468-4c56-a6e6-8edd906a61ad
- 如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值
  ls-type:: annotation
  hl-page:: 152
  hl-color:: yellow
  id:: 63be3147-06d2-48a3-aa8b-512c79f40dc4
- localeCompare()的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串
  ls-type:: annotation
  hl-page:: 152
  hl-color:: yellow
  id:: 63be31c8-f575-42ef-a0a8-c21fe2a3b534
- 何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript程序开始执行时就存在的对象
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be322b-67ca-4c3e-b71a-ad21f7f4f56f
- 内置对象，包括 Object、Array 和 String
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be58df-f3a1-4e5d-9ee5-6514262aeca9
- Global
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be59e9-4919-4e4a-8dfc-82fb95e63f1d
- 在全局作用域中定义的变量和函数都会变成 Global 对象的属性 
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5a1c-b75a-432b-bfc7-59702810f4ff
- 函数，包括 isNaN()、isFinite()、parseInt()和 parseFloat()
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5a39-18ab-4cb0-86dd-e25d5809ffde
- URL 编码方法
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5ad5-2f51-46c4-aca7-771c4c251af6
- encodeURI()和 encodeURIComponent()方法用于编码统一资源标识符（URI），以便传给浏览器
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5af2-9544-48bf-afde-4e44dd9e02fb
- ecnodeURI()方法用于对整个 URI 进行编码
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5b02-3cc1-4f0d-b68c-c5f32fc13fb8
- 而 encodeURIComponent()方法用于编码 URI 中单独的组件，比如前面 URL 中的"illegal value.js"
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5b83-86bb-4872-9549-bb333ad15fc5
- 而 encodeURIComponent()方法将所有非字母字符都替换成了相应的编码形式
  ls-type:: annotation
  hl-page:: 154
  hl-color:: yellow
  id:: 63be5c2c-7742-492a-a077-87954f3a8952
- 用 encodeURIComponent()应该比使用 encodeURI()的频率更高，这是因为编码查询字符串参数比编码基准 URI 的次数更多
  ls-type:: annotation
  hl-page:: 154
  hl-color:: yellow
  id:: 63be5c37-bc4b-4c8d-bfb9-b1b59950fde5
- decodeURI()和 decodeURIComponent
  ls-type:: annotation
  hl-page:: 154
  hl-color:: yellow
  id:: 63be5d96-1618-4940-a73e-dbbc322046e7
- eval()方法
  ls-type:: annotation
  hl-page:: 154
  hl-color:: yellow
  id:: 63be5daf-c659-4aa6-a5e5-195a662dc8fe
- 接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串
  ls-type:: annotation
  hl-page:: 154
  hl-color:: yellow
  id:: 63be5dbb-3a95-43e6-8fe1-ea641aa3bca8
- 在 eval()内部创建的变量和函数无法被外部访问
  ls-type:: annotation
  hl-page:: 155
  hl-color:: yellow
  id:: 63be5ddc-95d0-4aab-bf99-5f0bd7fa85a8
- Global 对象属性
  ls-type:: annotation
  hl-page:: 155
  hl-color:: yellow
  id:: 63be5de7-4030-436e-bb0d-fc0aebd1384f
- window 对象
  ls-type:: annotation
  hl-page:: 156
  hl-color:: yellow
  id:: 63be5e2e-0cf3-40a8-ad3e-98adb55884e5
- window 对象实现为 Global对象的代理
  ls-type:: annotation
  hl-page:: 156
  hl-color:: yellow
  id:: 63be5e36-6b11-4d07-a157-3ec112b076c5
- Math
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5e3d-c43f-4c8d-8c04-73ec445eff13
- Math 对象属性
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5e85-9610-45e5-97de-6866f8260090
- min()和 max()方法
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5e97-1aa4-4eb0-80ff-0f66ef1d394e
- 要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符： let values = [1, 2, 3, 4, 5, 6, 7, 8]; let max = Math.max(...val);
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5ea7-d264-4875-81fc-4a66f17afda3
- 舍入方法
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5eb3-41cc-4eca-999c-23752957789a
- random()方法
  ls-type:: annotation
  hl-page:: 158
  hl-color:: yellow
  id:: 63be5ebd-7214-4a97-a64e-c5f463378358
- 其他方法
  ls-type:: annotation
  hl-page:: 159
  hl-color:: yellow
  id:: 63be5ec4-1654-4aa3-ba2c-6ce691196fac
- Math.ceil()方法始终向上舍入为最接近的整数。
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5ed7-72e9-4d66-b495-017a4dcfc916
- Math.floor()方法始终向下舍入为最接近的整数。
  ls-type:: annotation
  hl-page:: 158
  hl-color:: yellow
  id:: 63be5eea-0dfd-469b-8e88-55937e05c4c4
- Math.round()方法执行四舍五入
  ls-type:: annotation
  hl-page:: 158
  hl-color:: yellow
  id:: 63be5ef2-d47e-484d-9344-55dac5f6db2e
- Math.fround()方法返回数值最接近的单精度（32 位）浮点值表示
  ls-type:: annotation
  hl-page:: 158
  hl-color:: yellow
  id:: 63be5ef7-372d-4b4c-91e6-d398edee49a4
- 返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1
  ls-type:: annotation
  hl-page:: 158
  hl-color:: yellow
  id:: 63be5fbf-7926-4187-b883-730d523b141e
- Object
  ls-type:: annotation
  hl-page:: 161
  hl-color:: green
  id:: 63be5ffb-0403-4793-a0a9-4df65b6dabc1
  hl-stamp:: 1673420799849
- 表达式上下文指的是期待返回值的上下文
  ls-type:: annotation
  hl-page:: 161
  hl-color:: yellow
  id:: 63be61ab-f742-4988-884e-2244fdbfb7f0
- 对象字面量表示法中，属性名可以是字符串或数值
  ls-type:: annotation
  hl-page:: 161
  hl-color:: yellow
  id:: 63be61f0-889b-4835-9c76-54bb2e69091a
- 函数内部会使用 typeof 操作符测试每个属性是否存在，然后根据属性有无构造并显示一条消息
  ls-type:: annotation
  hl-page:: 162
  hl-color:: yellow
  id:: 63be6229-c4ba-4ca8-9cb6-c66eb070d130
- Array
  ls-type:: annotation
  hl-page:: 163
  hl-color:: green
  id:: 63be6267-9bbe-4767-abed-355875869d86
- 创建数组
  ls-type:: annotation
  hl-page:: 163
  hl-color:: green
  id:: 63be62c0-c47a-46da-a1e9-bc013b0b9c6b
  hl-stamp:: 1673421509131
- from()用于将类数组结构转换为数组实例
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be6385-8a48-4253-aabf-b893d03e4d9d
- of()用于将一组参数转换为数组实例
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be638c-129a-4609-91eb-f5e9b7845b1b
- 字符串会被拆分为单字符数组
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be644d-9337-4d0e-ab21-d834b4a155b8
- 可以使用 from()将集合和映射转换为一个新数组
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be6455-ebda-475a-8faf-26e11b1efd6a
- Array.from()对现有数组执行浅复制
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be645c-544b-4f4c-b25d-92a14ca2f754
- 可以使用任何可迭代对象
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be6462-4669-4baf-8497-d15634c33d7f
- arguments 对象可以被轻松地转换为数组
  ls-type:: annotation
  hl-page:: 165
  hl-color:: yellow
  id:: 63be6468-2990-4970-914e-98f5732a0e78
- rom()也能转换带有必要属性的自定义对象
  ls-type:: annotation
  hl-page:: 165
  hl-color:: yellow
  id:: 63be6484-ba49-4c2a-854d-9807df101535
- 数组空位
  ls-type:: annotation
  hl-page:: 165
  hl-color:: green
  id:: 63be64bd-7bba-4547-a690-799f00a62f50
- const options = [,,,,,]; // 创建包含 5 个元素的数组
  ls-type:: annotation
  hl-page:: 165
  hl-color:: yellow
  id:: 63be64e0-9bc8-4dd1-beac-8b2f4800e640
- ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined
  ls-type:: annotation
  hl-page:: 165
  hl-color:: yellow
  id:: 63be64f6-06cf-4ba9-a1a0-f3f2ff2c4301
- 数组索引
  ls-type:: annotation
  hl-page:: 166
  hl-color:: green
  id:: 63be65c2-3cef-4a1f-96b7-3e08982f9348
- 数组 length 属性的独特之处在于，它不是只读的
  ls-type:: annotation
  hl-page:: 166
  hl-color:: yellow
  id:: 63be65e6-2f5b-468e-b6e9-5885c63f6020
- 数组最多可以包含 4 294 967 295 个元素
  ls-type:: annotation
  hl-page:: 167
  hl-color:: yellow
  id:: 63be6612-ae52-49d9-8052-8496625017b1
- 检测数组
  ls-type:: annotation
  hl-page:: 167
  hl-color:: green
  id:: 63be6619-d53d-47c8-a734-adfa5a858c2a
- 在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符
  ls-type:: annotation
  hl-page:: 167
  hl-color:: yellow
  id:: 63be67fa-8b8e-4d98-8ed1-a8dfd366eaab
- Array.isArray()方法
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be680d-867c-45c8-81ae-46116253d9de
- 迭代器方法
  ls-type:: annotation
  hl-page:: 168
  hl-color:: green
  id:: 63be6819-06c4-40a7-b655-124019baf173
- keys()返回数组索引的迭代器
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be682d-0853-4744-844c-777efbcf076d
- values()返回数组元素的迭代器
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be6834-26ad-4fa3-976c-ecbf117e25ac
- entries()返回索引/值对的迭代器
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be683a-5110-4b28-b35e-d445c73535ce
- 使用 ES6 的解构可以非常容易地在循环中拆分键/值对
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be6848-95a1-4015-9984-14fb9ad436ea
- 复制和填充方法
  ls-type:: annotation
  hl-page:: 168
  hl-color:: green
  id:: 63be6850-f1bc-44e8-b76e-aedf880a39f0
  hl-stamp:: 1673422935065
- fill()方法可以向一个已有的数组中插入全部或部分相同的值
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be6860-a1ff-4428-a389-3026daffae0e
- copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置
  ls-type:: annotation
  hl-page:: 169
  hl-color:: yellow
  id:: 63be68a3-53ee-422a-b914-dc7c02dca9fe
- 用 7 填充索引大于等于 1 且小于 3 的元素
  ls-type:: annotation
  hl-page:: 169
  hl-color:: yellow
  id:: 63be6961-64f7-4980-becc-97b6fb07916a
- 转换方法
  ls-type:: annotation
  hl-page:: 170
  hl-color:: green
  id:: 63be69b1-634e-4812-ab69-303f4d211c69
- 栈方法
  ls-type:: annotation
  hl-page:: 172
  hl-color:: green
  id:: 63be69b9-7167-4a3c-b82c-6db9e4d80646
- 队列方法
  ls-type:: annotation
  hl-page:: 172
  hl-color:: green
  id:: 63be69be-cb53-4d8e-b49f-dab7fd687af7
- 排序方法
  ls-type:: annotation
  hl-page:: 173
  hl-color:: green
  id:: 63be69c4-b681-4ad8-b3cc-ab81d331709e
- 操作方法
  ls-type:: annotation
  hl-page:: 175
  hl-color:: green
  id:: 63be69d0-436c-4d19-ac9f-87aeb37c7bb4
- 搜索和位置方法
  ls-type:: annotation
  hl-page:: 176
  hl-color:: green
  id:: 63be69d9-6fe8-4dcd-81d3-208a6b29c739
- 迭代方法
  ls-type:: annotation
  hl-page:: 178
  hl-color:: green
  id:: 63be69e1-882f-4190-8326-70212b9e3937
- 归并方法
  ls-type:: annotation
  hl-page:: 179
  hl-color:: green
  id:: 63be69e7-1040-486d-a71d-d579ec3cbdb1
- 定型数组
  ls-type:: annotation
  hl-page:: 180
  hl-color:: green
  id:: 63be6a08-fb0d-4102-91dc-de90944e1ae6
- Map
  ls-type:: annotation
  hl-page:: 188
  hl-color:: green
  id:: 63be6a22-4b5f-422e-a201-13babab8dd75
- WeakMap
  ls-type:: annotation
  hl-page:: 193
  hl-color:: green
  id:: 63be6a30-3d34-4f5e-a995-cc8d644c6c67
- Set
  ls-type:: annotation
  hl-page:: 198
  hl-color:: green
  id:: 63be6a3f-9238-435f-b044-c399dd08dc80
- WeakSet
  ls-type:: annotation
  hl-page:: 203
  hl-color:: green
  id:: 63be6a52-728f-428b-a100-de15e47fa9dc
- 迭代与扩展操作
  ls-type:: annotation
  hl-page:: 205
  hl-color:: green
  id:: 63be6a5d-63a1-415d-8e5d-b58fda46ccaa
- toLocaleString()方法时，会得到一个逗号分隔的数组值的字符串
  ls-type:: annotation
  hl-page:: 171
  hl-color:: yellow
  id:: 63be6c10-625b-4dd3-b909-401a942f2312
- 会调用数组每个值的 toLocaleString()方法
  ls-type:: annotation
  hl-page:: 171
  hl-color:: yellow
  id:: 63be6c15-490e-4c1d-b7c9-e19afe5338bf
- alert()期待字符串，所以会在后台调用数组的 toString()方法
  ls-type:: annotation
  hl-page:: 171
  hl-color:: yellow
  id:: 63be6c1b-0f91-4b35-9917-d648ca947704
- join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串
  ls-type:: annotation
  hl-page:: 171
  hl-color:: yellow
  id:: 63be6c5d-4be7-4e0c-8f34-48d0f4f48a6e
- push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度
  ls-type:: annotation
  hl-page:: 172
  hl-color:: yellow
  id:: 63be71cd-9d87-4f96-aeea-731b79761aca
- pop()方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项
  ls-type:: annotation
  hl-page:: 172
  hl-color:: yellow
  id:: 63be7332-53b9-4338-a3dd-0c555a2289d6
- shift()，它会删除数组的第一项并返回它，然后数组长度减 1
  ls-type:: annotation
  hl-page:: 172
  hl-color:: yellow
  id:: 63be7366-89d7-4ccd-afc6-fe6769452595
- 使用 shift()和 push()，可以把数组当成队列来使用
  ls-type:: annotation
  hl-page:: 172
  hl-color:: yellow
  id:: 63be7372-1c4f-472b-abd5-4716f2fe3942
- unshift()就是执行跟 shift()相反的操作：在数组开头添加任意多个值，然后返回新的数组长度
  ls-type:: annotation
  hl-page:: 173
  hl-color:: yellow
  id:: 63be76e5-fa0c-4e5b-a317-77fd39ada962
- reverse()方法就是将数组元素反向排列
  ls-type:: annotation
  hl-page:: 173
  hl-color:: yellow
  id:: 63be76f2-9861-408c-88c1-dae1053b0d32
- sort()会按照升序重新排列数组元素
  ls-type:: annotation
  hl-page:: 173
  hl-color:: yellow
  id:: 63be774b-dd42-4a63-b01f-ce071a7f890f
- sort()方法可以接收一个比较函数
  ls-type:: annotation
  hl-page:: 173
  hl-color:: yellow
  id:: 63be776f-de22-435b-8f39-7bd438fda891
- 比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值
  ls-type:: annotation
  hl-page:: 174
  hl-color:: yellow
  id:: 63be77aa-4eef-41e1-b4d9-341814f7a161
- concat()方法
  ls-type:: annotation
  hl-page:: 175
  hl-color:: yellow
  id:: 63be787a-a0f8-41b7-b5a2-752bbe933c73
- Symbol.isConcatSpreadable
  ls-type:: annotation
  hl-page:: 175
  hl-color:: yellow
  id:: 63be78a5-6759-42cb-81a9-5fb204caba7b
- 方法 slice()用于创建一个包含原有数组中一个或多个元素的新数组
  ls-type:: annotation
  hl-page:: 175
  hl-color:: yellow
  id:: 63be7942-cfbc-487e-a1b1-f9bc384307f9
- find()返回第一个匹配的元素
  ls-type:: annotation
  hl-page:: 177
  hl-color:: yellow
  id:: 63be7c46-4081-4b5c-8830-9e94ad4dd4ec
- findIndex()返回第一个匹配元素的索引
  ls-type:: annotation
  hl-page:: 177
  hl-color:: yellow
  id:: 63be7c4e-8b3b-4870-a60d-a0088c3ce20a
- alert(people.find((element, index, array) => element.age < 28));
  ls-type:: annotation
  hl-page:: 177
  hl-color:: yellow
  id:: 63be7ca0-5ded-405a-af45-ad5e49dcd4b1
- 找到匹配后，永远不会检查数组的最后一个元素
  ls-type:: annotation
  hl-page:: 178
  hl-color:: yellow
  id:: 63be7cb9-6d53-426f-b756-7fa27b50eb36
- 每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值
  ls-type:: annotation
  hl-page:: 178
  hl-color:: yellow
  id:: 63be7cd3-abe0-4e38-9373-2c2c86a34721
- 传给每个方法的函数接收 3个参数：数组元素、元素索引和数组本身
  ls-type:: annotation
  hl-page:: 178
  hl-color:: yellow
  id:: 63be7cdc-89aa-4c0e-84ca-8019251a531c
- 返回由每次函数调用的结果构成的数组
  ls-type:: annotation
  hl-page:: 178
  hl-color:: yellow
  id:: 63be7f2d-9234-4923-9654-5a701d25ee23
- let mapResult = numbers.map((item, index, array) => item * 2);
  ls-type:: annotation
  hl-page:: 179
  hl-color:: yellow
  id:: 63be7fc0-eae6-411a-a490-388ff18ab7fd
- forEach()方法。这个方法只会对每一项运行传入的函数，没有返回值
  ls-type:: annotation
  hl-page:: 179
  hl-color:: yellow
  id:: 63be7fdf-bc96-4d9a-9932-fea0980a62ba
- reduce()方法从数组第一项开始遍历到最后一项
  ls-type:: annotation
  hl-page:: 179
  hl-color:: yellow
  id:: 63be800b-f488-4335-8f24-6e0226778428
- reduceRight()从最后一项开始遍历至第一项
  ls-type:: annotation
  hl-page:: 179
  hl-color:: yellow
  id:: 63be8010-73b7-439f-9a06-e832ffc2bfba
- 上一个归并值、当前项、当前项的索引和数组本身
  ls-type:: annotation
  hl-page:: 179
  hl-color:: yellow
  id:: 63be8105-562d-431a-a28c-f0d0879fee48
- ArrayBuffer 是所有定型数组及视图引用的基本单位。
  ls-type:: annotation
  hl-page:: 180
  hl-color:: yellow
  id:: 63bea918-b9a5-494d-8ac1-e1acc48efb6b
- ArrayBuffer 某种程度上类似于 C++的 malloc()
  ls-type:: annotation
  hl-page:: 181
  hl-color:: yellow
  id:: 63bea92c-62f3-4a5a-b63b-818756fe52da
- ArrayBuffer分配的内存不能超过 Number.MAX_SAFE_INTEGER（253  1）字节。
  ls-type:: annotation
  hl-page:: 181
  hl-color:: yellow
  id:: 63bea936-f176-410b-84a8-52e29b8146c8
- 创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。
  ls-type:: annotation
  hl-page:: 184
  hl-color:: yellow
  id:: 63bea9f5-6afa-4353-972e-3f8d28e56a3c
- 可以使用任何 JavaScript 数据类型作为键
  ls-type:: annotation
  hl-page:: 190
  hl-color:: yellow
  id:: 63beac71-af4d-4c45-89c4-66f754545e5f
- 基本 API
  ls-type:: annotation
  hl-page:: 189
  hl-color:: green
  id:: 63beac7e-e044-43cd-8088-6bdbf4d37148
  hl-stamp:: 1673440384071
- 顺序与迭代
  ls-type:: annotation
  hl-page:: 191
  hl-color:: green
  id:: 63beac8c-49fb-4927-ab83-10deec98e9f1
- Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作
  ls-type:: annotation
  hl-page:: 191
  hl-color:: yellow
  id:: 63beacaa-bd51-4299-be85-fb036e40b3a3
- entries()）取得这个迭代器
  ls-type:: annotation
  hl-page:: 191
  hl-color:: yellow
  id:: 63beacc6-cd03-4068-a720-d5564d546571
- 或者 Symbol.iterator 属性
  ls-type:: annotation
  hl-page:: 191
  hl-color:: yellow
  id:: 63beacd4-cd9b-44b1-92a0-3cacc3f37fc1
- keys()和 values()分别返回以插入顺序生成键和值的迭代器
  ls-type:: annotation
  hl-page:: 192
  hl-color:: yellow
  id:: 63bead95-c27a-4a33-a6f9-d929b7667259
- 调用映射的 forEach(callback, opt_thisArg)方法并传入回调，依次迭代每个键/值对
  ls-type:: annotation
  hl-page:: 191
  hl-color:: yellow
  id:: 63beadaa-b7b6-4a0a-aa95-e1a44fcfed1d
- 键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改
  ls-type:: annotation
  hl-page:: 192
  hl-color:: yellow
  id:: 63beaecf-7965-44bb-9b1f-79aca1ef3b3d
- 选择 Object 还是 Ma
  ls-type:: annotation
  hl-page:: 193
  hl-color:: green
  id:: 63beaefe-542d-4db0-a239-f3f754e03111
- 给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对
  ls-type:: annotation
  hl-page:: 193
  hl-color:: yellow
  id:: 63beaf0c-e895-4107-80aa-764f72356357
- 插入 Map 在所有浏览器中一般会稍微快一点儿
  ls-type:: annotation
  hl-page:: 193
  hl-color:: yellow
  id:: 63beafa7-ba78-483f-bac3-4041047eb57d
- 如果代码涉及大量查找操作，那么某些情况下可能选择 Object 更好一些
  ls-type:: annotation
  hl-page:: 193
  hl-color:: yellow
  id:: 63beafb7-443a-40f4-bdfb-0791eed57a3e
- Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map
  ls-type:: annotation
  hl-page:: 193
  hl-color:: yellow
  id:: 63beafcc-b7ba-4a9e-998f-b4fd109b716c
- 基本 API
  ls-type:: annotation
  hl-page:: 193
  hl-color:: green
  id:: 63beafd8-f73f-4426-b8f4-74f44257858a
- const wm = new WeakMap();
  ls-type:: annotation
  hl-page:: 193
  hl-color:: yellow
  id:: 63beb026-805f-4267-b455-f43c5c8180b4
- 弱键
  ls-type:: annotation
  hl-page:: 195
  hl-color:: green
  id:: 63beb1c7-02b5-4070-aecf-68f0a1e98c6b
- 映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收
  ls-type:: annotation
  hl-page:: 195
  hl-color:: yellow
  id:: 63beb1d5-f29a-42e4-8625-eea2a65aba35
- 不可迭代键
  ls-type:: annotation
  hl-page:: 195
  hl-color:: green
  id:: 63beb214-e271-49e3-8655-6b42ec2b15f8
- 使用弱映射
  ls-type:: annotation
  hl-page:: 196
  hl-color:: green
  id:: 63beb294-8369-4334-8bb2-5b932d743636
- WeakMap 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值
  ls-type:: annotation
  hl-page:: 195
  hl-color:: yellow
  id:: 63beb2da-e319-4684-a191-ab8daa677169
- 基本 API
  ls-type:: annotation
  hl-page:: 198
  hl-color:: green
  id:: 63beb368-5074-47f1-90ad-114328dda759
- const m = new Set();
  ls-type:: annotation
  hl-page:: 198
  hl-color:: yellow
  id:: 63beb37c-f64b-4174-8555-a667080690fa
- 顺序与迭代
  ls-type:: annotation
  hl-page:: 200
  hl-color:: green
  id:: 63beb534-1098-42e1-a16b-c595426f301d
  hl-stamp:: 1673442614151
- Set 会维护值插入时的顺序，因此支持按顺序迭代
  ls-type:: annotation
  hl-page:: 200
  hl-color:: yellow
  id:: 63beb573-943c-425c-92c6-a7651807ee96
- 集合的 entries()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现
  ls-type:: annotation
  hl-page:: 200
  hl-color:: yellow
  id:: 63beb591-e55e-4009-8e29-9944a11aa44f
- values()是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组
  ls-type:: annotation
  hl-page:: 200
  hl-color:: yellow
  id:: 63beb5b3-db3a-4018-9837-3159c0a42b7b
- 定义正式集合操作
  ls-type:: annotation
  hl-page:: 201
  hl-color:: green
  id:: 63beb602-dcb6-45b2-bf6e-ed79df318abe
  hl-stamp:: 1673442821913
- 弱集合中的值只能是 Object 或者继承自 Object 的类型，
  ls-type:: annotation
  hl-page:: 203
  hl-color:: yellow
  id:: 63beb6bf-7356-4f24-8af1-16524da3c8c7
- ，container 对象维护着一个对弱集合值的引用，因此这个对象值不会成为垃圾回收的目标
  ls-type:: annotation
  hl-page:: 204
  hl-color:: yellow
  id:: 63beb7de-9134-46b7-90c6-c1239c0959ca
- 只要 WeakSet 中任何元素从 DOM 树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存（假设没有其他地方引用这个对象）。
  ls-type:: annotation
  hl-page:: 205
  hl-color:: yellow
  id:: 63beb83d-ee81-472f-adbe-8ce629cf4acd
- 所有类型都支持顺序迭代，都可以传入 for-of 循环
  ls-type:: annotation
  hl-page:: 206
  hl-color:: yellow
  id:: 63beb8b9-8bc8-406c-b3e5-617884384140
- 对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制
  ls-type:: annotation
  hl-page:: 206
  hl-color:: yellow
  id:: 63beb8fa-a0bd-4313-9aa1-9734ff48394e
- 理解迭代
  ls-type:: annotation
  hl-page:: 208
  hl-color:: green
  id:: 63c7b6f7-8409-4620-999e-f6a0cdfa2c98
- 在 JavaScript 中，计数循环就是一种最简单的迭代
  ls-type:: annotation
  hl-page:: 208
  hl-color:: yellow
  id:: 63c7d77d-5947-49c4-8a94-fd1508cc8d46
- 循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作
  ls-type:: annotation
  hl-page:: 208
  hl-color:: yellow
  id:: 63c7d840-cf6f-44ac-80b6-40423bb0226b
- ES5 新增了 Array.prototype.forEach()方法，向通用迭代需求迈进了一步
  ls-type:: annotation
  hl-page:: 208
  hl-color:: yellow
  id:: 63c7d8d9-52be-4e94-84f7-298891427021
- 没有办法标识迭代何时终
  ls-type:: annotation
  hl-page:: 209
  hl-color:: yellow
  id:: 63c7d934-edb4-4ff8-9d6f-8dc32ff49123
- 迭代器模式
  ls-type:: annotation
  hl-page:: 209
  hl-color:: green
  id:: 63c7d947-e12a-4d13-b77e-d044beacf856
- 它们包含的元素都是有限的，而且都具有无歧义的遍历顺
  ls-type:: annotation
  hl-page:: 209
  hl-color:: yellow
  id:: 63c7db27-2ba2-446e-a723-e7eab2540167
- 可迭代协议
  ls-type:: annotation
  hl-page:: 209
  hl-color:: green
  id:: 63c7db97-e0ef-4c59-922b-ca268a8205d5
- ：支持迭代的自我识别能力和创建实现 Iterator 接口的对象的能力
  ls-type:: annotation
  hl-page:: 209
  hl-color:: yellow
  id:: 63c7dbdd-45f5-486f-98ef-c85b7e04051b
- 必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 Symbol.iterator 作为键
  ls-type:: annotation
  hl-page:: 209
  hl-color:: yellow
  id:: 63c7dbf5-36a1-4d12-b509-48c35dc05528
- 。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性
  ls-type:: annotation
  hl-page:: 210
  hl-color:: yellow
  id:: 63c7dc37-bbe2-400f-aa81-a622b9c9cbd4
- 这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代
  ls-type:: annotation
  hl-page:: 210
  hl-color:: yellow
  id:: 63c7dc3f-1ccb-40e0-b49d-5ffd60051e9e
- 接收可迭代对象的原生语言特性包括：
  ls-type:: annotation
  hl-page:: 210
  hl-color:: yellow
  id:: 63c7dc4f-7e8b-4559-91f1-222929027339
- 迭代器协议
  ls-type:: annotation
  hl-page:: 211
  hl-color:: green
  id:: 63c7dca8-0715-45aa-a45d-1d89c0a2046a
- 。迭代器 API 使用 next()方法在可迭代对象中遍历数据。每次成功调用 next()，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值
  ls-type:: annotation
  hl-page:: 211
  hl-color:: yellow
  id:: 63c7dcb9-333e-459c-a3ff-b83c489aa07a
- 只要迭代器到达 done: true 状态，后续调用 next()就一直返回同样的值了
  ls-type:: annotation
  hl-page:: 212
  hl-color:: yellow
  id:: 63c7dd43-ec40-46f1-b128-c5617af7181f
- 不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象
  ls-type:: annotation
  hl-page:: 212
  hl-color:: yellow
  id:: 63c7dd92-4138-41c7-a004-13b908e543a9
- 如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化
  ls-type:: annotation
  hl-page:: 212
  hl-color:: yellow
  id:: 63c7ddca-417e-4858-a800-59e07590aa64
- 迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象
  ls-type:: annotation
  hl-page:: 212
  hl-color:: yellow
  id:: 63c7ddeb-dc9e-42f0-8c9b-606cd5f783a8
- 自定义迭代器
  ls-type:: annotation
  hl-page:: 213
  hl-color:: green
  id:: 63c7de4b-4e64-4ceb-a3fe-6107134c2421
- 是因为它的每个实例只能被迭代一次
  ls-type:: annotation
  hl-page:: 213
  hl-color:: yellow
  id:: 63c7df22-4bf9-4f2a-b053-617c633522b4
- 因为每个迭代器也实现了 Iterable 接口，所以它们可以用在任何期待可迭代对象的地方，比如 for-of 循环
  ls-type:: annotation
  hl-page:: 214
  hl-color:: yellow
  id:: 63c7df6f-a42a-421f-b01b-b3a469a80d74
- 提前终止迭代器
  ls-type:: annotation
  hl-page:: 215
  hl-color:: green
  id:: 63c7dfda-af10-486a-8bdd-57511caf6895
  hl-stamp:: 1674043356569
- 可选的 return()方法用于指定在迭代器提前关闭时执行的逻辑。
  ls-type:: annotation
  hl-page:: 215
  hl-color:: yellow
  id:: 63c7dfe6-1cba-4007-83d2-67f3c6139cc1
- return()方法必须返回一个有效的 IteratorResult 对象。简单情况下，可以只返回{ done: true }。
  ls-type:: annotation
  hl-page:: 215
  hl-color:: yellow
  id:: 63c7e01f-63b5-45a0-b581-45f8b65d354b
- 调用 return()不会强制迭代器进入关闭状态
  ls-type:: annotation
  hl-page:: 216
  hl-color:: yellow
  id:: 63c7e0bb-57bc-4c1d-b549-d7df7d4fd96f
- 生成器
  ls-type:: annotation
  hl-page:: 217
  hl-color:: green
  id:: 63c7e0d5-25a0-4970-a940-a306aee2fc32
- 拥有在一个函数块内暂停和恢复代码执行的能力
  ls-type:: annotation
  hl-page:: 217
  hl-color:: yellow
  id:: 63c7e0f6-5840-4f36-83f8-c365e3f1e48c
- 使用生成器可以自定义迭代器和实现协程
  ls-type:: annotation
  hl-page:: 217
  hl-color:: yellow
  id:: 63c7e0fe-a75f-46f0-98d2-0de4352004be
- 生成器基础
  ls-type:: annotation
  hl-page:: 217
  hl-color:: green
  id:: 63c7e1ec-785e-4e9b-96d6-36d26f0f5afb
- 只要是可以定义函数的地方，就可以定义生成器
  ls-type:: annotation
  hl-page:: 217
  hl-color:: yellow
  id:: 63c7e1ff-bdbb-4129-9ae6-a6ffbf899c41
- 调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态
  ls-type:: annotation
  hl-page:: 218
  hl-color:: yellow
  id:: 63c7e21e-6c04-45af-956f-2c435b31bdb0
- next()方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性
  ls-type:: annotation
  hl-page:: 218
  hl-color:: yellow
  id:: 63c7e224-8e7e-445e-b0af-0cfbae4512cf
- 生成器函数只会在初次调用 next()方法后开始执行
  ls-type:: annotation
  hl-page:: 218
  hl-color:: yellow
  id:: 63c7e307-ecf5-401d-b30b-22aaf0010079
- 生成器对象实现了 Iterable 接口，它们默认的迭代器是自引用的
  ls-type:: annotation
  hl-page:: 218
  hl-color:: yellow
  id:: 63c7e3b8-85b5-4de3-9488-e5232b70fbd3
- 通过 yield 中断执行
  ls-type:: annotation
  hl-page:: 219
  hl-color:: green
  id:: 63c7e460-596c-47ca-b4ec-1803eb4c8a63
- 生成器函数在遇到 yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留
  ls-type:: annotation
  hl-page:: 219
  hl-color:: yellow
  id:: 63c7e487-d662-41d5-a48e-54e446be2188
- yield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。
  ls-type:: annotation
  hl-page:: 220
  hl-color:: yellow
  id:: 63c7e4d0-ebeb-409d-baf5-5b4dc60e55aa
- 出现在嵌套的非生成器函数中会抛出语法错
  ls-type:: annotation
  hl-page:: 220
  hl-color:: yellow
  id:: 63c7e50d-74cd-420a-ac96-7d3c4e7d2d07
- 生成器对象作为可迭代对象
  ls-type:: annotation
  hl-page:: 220
  hl-color:: yellow
  id:: 63c7e521-748d-48db-9203-2b281fbfc354
- 使用 yield 实现输入和输出
  ls-type:: annotation
  hl-page:: 221
  hl-color:: yellow
  id:: 63c7e5b8-68be-47bb-b0ba-718a0467ccd7
- 下一次调用 next()传入了"bar"，作为交给同一个 yield 的值
  ls-type:: annotation
  hl-page:: 221
  hl-color:: yellow
  id:: 63c7e611-e7f1-4771-9530-edd7b463a16e
- 它会根据配置的值迭代相应次数并产生迭代的索引。初始化一个新数组可以实现这个需求，但不用数组也可以实现同样的行为
  ls-type:: annotation
  hl-page:: 222
  hl-color:: yellow
  id:: 63c7e6db-64b9-41cc-9e49-ca9ef98fafc4
- 产生可迭代对象
  ls-type:: annotation
  hl-page:: 222
  hl-color:: yellow
  id:: 63c7e706-91c4-4030-878d-947e2e5a700a
- 使用星号增强 yield 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值
  ls-type:: annotation
  hl-page:: 222
  hl-color:: yellow
  id:: 63c7e773-14db-47a6-ac7b-1bf2e5c56dea
- 使用 yield*实现递归算法
  ls-type:: annotation
  hl-page:: 224
  hl-color:: yellow
  id:: 63c7e7a6-a6e5-4fc5-849c-99720e501d3e
- 生成器作为默认迭代器
  ls-type:: annotation
  hl-page:: 226
  hl-color:: green
  id:: 63c7e876-91d0-4635-97f1-e2e84e9109c2
- 提前终止生成器
  ls-type:: annotation
  hl-page:: 227
  hl-color:: green
  id:: 63c7e87f-d1cd-4c56-928a-0f8438ce76fa
- return()和 throw()方法都可以用于强制生成器进入关闭状态
  ls-type:: annotation
  hl-page:: 227
  hl-color:: yellow
  id:: 63c7e894-4930-47d3-9a70-4541a97302e0
- throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：
  ls-type:: annotation
  hl-page:: 228
  hl-color:: yellow
  id:: 63c7e937-c50a-4255-935e-7f44e3e34ae0
- 理解对象
  ls-type:: annotation
  hl-page:: 230
  hl-color:: green
  id:: 63c7e9fb-fd45-41cc-a9e4-5cbeedbb9a54
- 属性分两种：数据属性和访问器属性。
  ls-type:: annotation
  hl-page:: 231
  hl-color:: yellow
  id:: 63c7ea13-cfc3-4ecd-923f-93977ada5bed
- [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义
  ls-type:: annotation
  hl-page:: 231
  hl-color:: yellow
  id:: 63c7ea96-b811-431d-b225-f18bed68e8a4
- [[Enumerable]]：表示属性是否可以通过 for-in 循环返回
  ls-type:: annotation
  hl-page:: 231
  hl-color:: yellow
  id:: 63c7eaa5-2e31-49da-a8ca-caac905e8d94
- [Writable]]：表示属性的值是否可以被修改
  ls-type:: annotation
  hl-page:: 231
  hl-color:: yellow
  id:: 63c7eaf8-21f1-4377-864a-1cd308187ba9
- [[Value]]：包含属性实际的值
  ls-type:: annotation
  hl-page:: 231
  hl-color:: yellow
  id:: 63c7eb04-a564-4e20-bb2d-7d73734609ef
- 个例子把 configurable 设置为 false，意味着这个属性不能从对象上删除
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7eb9f-04db-44ac-ba0f-ee6c502b8071
- 包含一个获取（getter）函数和一个设置（setter）函数
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7ed25-8d22-4213-baa9-0744131e61bd
- [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7ed30-998c-4ccb-93bc-555709003ddd
- [[Enumerable]]：表示属性是否可以通过 for-in 循环返回
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7ed38-2b4c-4ee7-b58b-86e749a205fc
- [[Get]]：获取函数，在读取属性时调用。默认值为 undefined。
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7ed42-9895-4d6b-b124-f6776353c15e
- [[Set]]：设置函数，在写入属性时调用。默认值为 undefined。
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7ed4d-f416-427d-8524-e64f3cb70279
- year_中的下划线常用来表示该属性并不希望在对象方法的外部被访问
  ls-type:: annotation
  hl-page:: 233
  hl-color:: yellow
  id:: 63c7eda1-1209-4c0f-bec2-74970771d713
- 定义多个属性
  ls-type:: annotation
  hl-page:: 233
  hl-color:: green
  id:: 63c7ee31-e7fe-4138-87f5-9dff19f27c2d
- 这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。
  ls-type:: annotation
  hl-page:: 233
  hl-color:: yellow
  id:: 63c7eea0-1bee-482b-979d-2b2343ef723d
- 读取属性的特性
  ls-type:: annotation
  hl-page:: 234
  hl-color:: green
  id:: 63c7ef09-5664-46cc-a5cb-ce5057241c5e
- 使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符
  ls-type:: annotation
  hl-page:: 234
  hl-color:: yellow
  id:: 63c7ef54-bbd4-438b-a5a3-35ca1cb49dfd
- Object.getOwnPropertyDescriptors()静态方法
  ls-type:: annotation
  hl-page:: 235
  hl-color:: yellow
  id:: 63c7efc4-843d-47ad-9bb4-de91278230dd
- 合并对象
  ls-type:: annotation
  hl-page:: 235
  hl-color:: green
  id:: 63c7f060-3b20-4c4a-a4c6-dea47a34148c
- 就是把源对象所有的本地属性一起复制到目标对象上
  ls-type:: annotation
  hl-page:: 235
  hl-color:: yellow
  id:: 63c7f070-b079-4030-a514-9f3a13fefff9
- ECMAScript 6 专门为合并对象提供了 Object.assign()方法
  ls-type:: annotation
  hl-page:: 236
  hl-color:: yellow
  id:: 63c7f097-3717-46a2-848c-1db9c31c2a5d
- Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。
  ls-type:: annotation
  hl-page:: 237
  hl-color:: yellow
  id:: 63c7f0bb-53b5-48bc-89e2-02106f01e8c3
- 如果赋值期间出错，则操作会中止并退出，同时抛出错误。Object.assign()没有“回滚”之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。
  ls-type:: annotation
  hl-page:: 237
  hl-color:: yellow
  id:: 63c7f19f-3c83-4260-b87d-a51ac2ed6ae7
- 对象标识及相等判定
  ls-type:: annotation
  hl-page:: 238
  hl-color:: green
  id:: 63c7f1ab-76aa-4a71-acc7-54fee3880cc6
- Object.is()，这个方法与===很像
  ls-type:: annotation
  hl-page:: 238
  hl-color:: yellow
  id:: 63c7f2c4-8707-4222-82eb-c917cad7ea7c
- 要检查超过两个值，递归地利用相等性传递即可：
  ls-type:: annotation
  hl-page:: 238
  hl-color:: yellow
  id:: 63c7f32e-e1fa-43bd-81e0-f0eda9e17bc7
- 增强的对象语法
  ls-type:: annotation
  hl-page:: 238
  hl-color:: green
  id:: 63c7f335-22de-4d85-9320-4f570779a814
- 属性值简写
  ls-type:: annotation
  hl-page:: 239
  hl-color:: yellow
  id:: 63c7f409-a9d3-499c-8299-45a88003fe83
- 可计算属性
  ls-type:: annotation
  hl-page:: 239
  hl-color:: yellow
  id:: 63c7f430-3f34-4695-8145-913c60026db8
- 简写方法名
  ls-type:: annotation
  hl-page:: 240
  hl-color:: yellow
  id:: 63c7f437-8de1-4bee-8a9f-449473c0543e
- 句话说，不能在对象字面量中直接动态命名属性
  ls-type:: annotation
  hl-page:: 239
  hl-color:: yellow
  id:: 63c7f462-70cc-45e5-acf0-cf6c284b761c
- 中括号包围的对象属性键告诉运行时将其作为 JavaScript 表达式而不是字符串来求值：
  ls-type:: annotation
  hl-page:: 240
  hl-color:: yellow
  id:: 63c7f4c0-8b06-4a2f-843d-ea7a9d6cbc3a
- 对象解构
  ls-type:: annotation
  hl-page:: 241
  hl-color:: green
  id:: 63c7f4d1-2bf3-491e-b0fa-e5ea9508efb3
- 创建对象
  ls-type:: annotation
  hl-page:: 245
  hl-color:: green
  id:: 63c7f50a-5a57-4e0d-bf87-700a14aa05f0
- 可以在一条语句中使用嵌套数据实现一个或多个赋值操作
  ls-type:: annotation
  hl-page:: 241
  hl-color:: yellow
  id:: 63c7f53b-719b-4b73-8bc0-5da06313733e
- 使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。
  ls-type:: annotation
  hl-page:: 242
  hl-color:: yellow
  id:: 63c7f5e3-008b-4a22-b9ea-3d98b960ef18
- 也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况
  ls-type:: annotation
  hl-page:: 242
  hl-color:: yellow
  id:: 63c7f6ad-c781-4e06-8d88-82d50aa5f359
- 工厂模式
  ls-type:: annotation
  hl-page:: 245
  hl-color:: green
  id:: 63c9300c-7ca9-46f0-927e-4295c0bd0e6d
- ，函数 createPerson()接收 3 个参数，根据这几个参数构建了一个包含 Person 信息的对象
  ls-type:: annotation
  hl-page:: 246
  hl-color:: yellow
  id:: 63c93021-f848-4d67-b215-d0865dca82ae
- 但没有解决对象标识问题（即新创建的对象是什么类型）
  ls-type:: annotation
  hl-page:: 246
  hl-color:: yellow
  id:: 63c93027-c768-4611-83e2-04f923d95250
- 构造函数模式
  ls-type:: annotation
  hl-page:: 246
  hl-color:: green
  id:: 63c9302b-994a-47f6-9438-445a1503dc0c
- 没有显式地创建对象。
  ls-type:: annotation
  hl-page:: 246
  hl-color:: yellow
  id:: 63c930bd-717e-454c-800c-6ceb56e0c40d
- 属性和方法直接赋值给了 this。
  ls-type:: annotation
  hl-page:: 246
  hl-color:: yellow
  id:: 63c930c0-87f7-424f-84c4-5e5e388786ff
- 没有 return。
  ls-type:: annotation
  hl-page:: 246
  hl-color:: yellow
  id:: 63c930c7-74d7-451b-8322-40ea6c3274d4
- constructor 本来是用于标识对象类型的。
  ls-type:: annotation
  hl-page:: 247
  hl-color:: yellow
  id:: 63c93108-6590-4dc4-a935-336da9f23025
- 前面例子中的每个对象都是 Object 的实例，同时也是 Person 的实例
  ls-type:: annotation
  hl-page:: 247
  hl-color:: yellow
  id:: 63c9310c-aa00-4634-b650-261f49ac93d8
- 构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。
  ls-type:: annotation
  hl-page:: 248
  hl-color:: yellow
  id:: 63c93158-dafa-44bf-9eec-6545b74424f1
- 普通函数的调用方式，这时候没有使用 new 操作符调用 Person()，结果会将属性和方法添加到 window 对象。
  ls-type:: annotation
  hl-page:: 248
  hl-color:: yellow
  id:: 63c931d7-0e29-4215-9506-ce2a665eef72
- 因为都是做一样的事，所以没必要定义两个不同的 Function 实例。况且，this 对象可以把函数与对象的绑定推迟到运行时。
  ls-type:: annotation
  hl-page:: 249
  hl-color:: yellow
  id:: 63c9323d-443a-4041-9604-10fba69c6720
- 原型模式
  ls-type:: annotation
  hl-page:: 249
  hl-color:: green
  id:: 63c9326e-44bd-4e80-9d27-01eed3044446
- 每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。
  ls-type:: annotation
  hl-page:: 249
  hl-color:: yellow
  id:: 63c932ba-ad74-44d0-9d7e-63aab15d7a99
- 在它上面定义的属性和方法可以被对象实例共享
  ls-type:: annotation
  hl-page:: 249
  hl-color:: yellow
  id:: 63c932c1-5e01-4507-ba09-680e029bbabf
- 使用这种原型模式定义的属性和方法是由所有实例共享的。因此 person1 和 person2 访问的都是相同的属性和相同的 sayName()函数
  ls-type:: annotation
  hl-page:: 250
  hl-color:: yellow
  id:: 63c93450-b3ac-4a51-8da2-09d074116dd9
- ，但 Firefox、Safari 和 Chrome会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型
  ls-type:: annotation
  hl-page:: 250
  hl-color:: yellow
  id:: 63c934b6-3bae-43b1-a868-386f4db7079c
- Person.prototype 指向原型对象
  ls-type:: annotation
  hl-page:: 252
  hl-color:: yellow
  id:: 63c9354e-e866-46fb-b419-79fd8583d3d0
- Person.prototype.contructor 指回 Person 构造函数
  ls-type:: annotation
  hl-page:: 252
  hl-color:: yellow
  id:: 63c93556-5b0b-4ab5-9741-da59b26184cf
- Person 的两个实例 person1 和 person2 都只有一个内部属性指回 Person.prototype，而且两者都与构造函数没有直接联系
  ls-type:: annotation
  hl-page:: 252
  hl-color:: yellow
  id:: 63c93563-ad79-4a17-bb11-95d2b7f1cd5d
- Object 类型还有一个 setPrototypeOf()方法，可以向实例的私有特性[[Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系：
  ls-type:: annotation
  hl-page:: 253
  hl-color:: yellow
  id:: 63c93589-66e7-43e8-9daa-0102b9864c1e
- 为避免使用 Object.setPrototypeOf()可能造成的性能下降，可以通过 Object.create()来创建一个新对象，同时为其指定原型
  ls-type:: annotation
  hl-page:: 253
  hl-color:: yellow
  id:: 63c935a5-27ad-4930-949f-e21cc4ede20f
- 面提到的 constructor 属性只存在于原型对象，因此通过实例对象也是可以访问到的
  ls-type:: annotation
  hl-page:: 253
  hl-color:: yellow
  id:: 63c9363e-391d-4412-a4a8-13d0bf863473
- 果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。
  ls-type:: annotation
  hl-page:: 253
  hl-color:: yellow
  id:: 63c93656-000c-4918-9d32-993945caba05
- 使用 delete 操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索原型对象
  ls-type:: annotation
  hl-page:: 254
  hl-color:: yellow
  id:: 63c9367d-b6f5-4837-9a94-d51be252feea
- 通过调用 hasOwnProperty()能够清楚地看到访问的是实例属性还是原型属性。
  ls-type:: annotation
  hl-page:: 255
  hl-color:: yellow
  id:: 63c936d5-3552-4d5e-ba59-2641d7919a14
- 在单独使用时，in 操作符会在可以通过对象访问指定属性时返回 true，无论该属性是在实例上还是在原型上。
  ls-type:: annotation
  hl-page:: 256
  hl-color:: yellow
  id:: 63c936f2-7e07-4976-b34d-3515ef9510b0
- 要获得对象上所有可枚举的实例属性，可以使用 Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。
  ls-type:: annotation
  hl-page:: 257
  hl-color:: yellow
  id:: 63c93798-2d46-4a20-a725-3130ce773ff2
- 如果想列出所有实例属性，无论是否可以枚举，都可以使用 Object.getOwnPropertyNames()：
  ls-type:: annotation
  hl-page:: 257
  hl-color:: yellow
  id:: 63c937e0-ad74-4f60-929e-9865bf8b3341
- 在 ECMAScript 6 新增符号类型之后，相应地出现了增加一个 Object.getOwnPropertyNames()的兄弟方法的需求，
  ls-type:: annotation
  hl-page:: 257
  hl-color:: yellow
  id:: 63c937f0-c415-40c8-8e2a-2dd465b7a5ed
- for-in 循环和 Object.keys()的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。
  ls-type:: annotation
  hl-page:: 258
  hl-color:: yellow
  id:: 63c93863-d77f-48e1-89c0-360d58ad9733
- Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。
  ls-type:: annotation
  hl-page:: 258
  hl-color:: yellow
  id:: 63c9386b-be2e-4453-a7e9-d7d90f2c01dc
- 对象迭代
  ls-type:: annotation
  hl-page:: 258
  hl-color:: green
  id:: 63c93874-505f-4318-874e-548784a873a9
- Object.values()返回对象值的数组
  ls-type:: annotation
  hl-page:: 258
  hl-color:: yellow
  id:: 63c93886-dc4d-4e00-80eb-bad55ec1cf64
- Object.entries()返回键/值对的数组
  ls-type:: annotation
  hl-page:: 258
  hl-color:: yellow
  id:: 63c9388d-ee81-4cfd-ac63-ea4af3a28e9a
- 直接通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法
  ls-type:: annotation
  hl-page:: 259
  hl-color:: yellow
  id:: 63c938f7-b463-4f86-a76e-974d6a55f97e
- 这里，instanceof 仍然对 Object 和 Person 都返回 true。但 constructor 属性现在等于 Object而不是 Person 了。如果 constructor 的值很重要，则可以像下面这样在重写原型对象时专门设置一下它的值
  ls-type:: annotation
  hl-page:: 260
  hl-color:: yellow
  id:: 63c93940-e7c7-49d8-80c3-3fb892f79c7e
- 以这种方式恢复 constructor 属性会创建一个[[Enumerable]]为 true 的属性
  ls-type:: annotation
  hl-page:: 260
  hl-color:: yellow
  id:: 63c93952-5d08-4772-ab7a-686b29db09f8
- 如果你使用的是兼容 ECMAScript 的 JavaScript 引擎，那可能会改为使用 Object.defineProperty()方法来定义 constructor 属性
  ls-type:: annotation
  hl-page:: 260
  hl-color:: yellow
  id:: 63c93974-f787-49bd-9c88-b84ded4a10c1
- 虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两回事
  ls-type:: annotation
  hl-page:: 261
  hl-color:: yellow
  id:: 63c939ec-e29e-43f6-9884-c35a1b1e1837
- 记住，实例只有指向原型的指针，没有指向构造函数的指针。
  ls-type:: annotation
  hl-page:: 261
  hl-color:: yellow
  id:: 63c939f5-2c7d-40c5-95ba-a99a4886490f
- 重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。
  ls-type:: annotation
  hl-page:: 261
  hl-color:: yellow
  id:: 63c93a0f-bf0e-434d-9534-e83ecf56e78a
- 数组实例的 sort()方法就是 Array.prototype 上定义的
  ls-type:: annotation
  hl-page:: 262
  hl-color:: yellow
  id:: 63c93a4b-b06f-424b-a3ee-689ec99de5a2
- 字符串包装对象的 substring()方法也是在 String.prototype 上定义的
  ls-type:: annotation
  hl-page:: 262
  hl-color:: yellow
  id:: 63c93a4f-d758-4c6c-b30d-524d94b9543c
- 不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。
  ls-type:: annotation
  hl-page:: 263
  hl-color:: yellow
  id:: 63c93b03-d859-4d98-9d6b-b90285b92acf
- 继承
  ls-type:: annotation
  hl-page:: 263
  hl-color:: green
  id:: 63c93b09-077e-425f-9edc-1f0d649a740e
- 这就是原型链的基本构想。
  ls-type:: annotation
  hl-page:: 263
  hl-color:: yellow
  id:: 63c93b34-883e-4bd3-bede-3b881d90fcbb
- 由于 SubType.prototype 的 constructor 属性被重写为指向 SuperType，所以 instance.constructor 也指向 SuperType
  ls-type:: annotation
  hl-page:: 264
  hl-color:: yellow
  id:: 63c93c26-f816-4518-991d-45c7dc1b6d4f
- 以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链
  ls-type:: annotation
  hl-page:: 266
  hl-color:: yellow
  id:: 63c93cae-da86-48f3-9da6-c4e04b5e115a
- 在这段代码中，子类的原型在被赋值为 SuperType 的实例后，又被一个对象字面量覆盖了。覆盖后的原型是一个 Object 的实例，而不再是 SuperType 的实例。
  ls-type:: annotation
  hl-page:: 267
  hl-color:: yellow
  id:: 63c93cd0-fba3-42c8-ade3-4442c7bea2dd
- 使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性
  ls-type:: annotation
  hl-page:: 267
  hl-color:: yellow
  id:: 63c93cde-4aa7-45bc-8e14-0c3d482c3921
- 子类型在实例化时不能给父类型的构造函数传参。
  ls-type:: annotation
  hl-page:: 267
  hl-color:: yellow
  id:: 63c93d6a-c1ee-4b4c-9c17-72dbb96b86ba
- 盗用构造函数
  ls-type:: annotation
  hl-page:: 268
  hl-color:: green
  id:: 63c93d7c-c18c-41ff-8682-474ecb8a1ef9
- 在子类构造函数中调用父类构造函数
  ls-type:: annotation
  hl-page:: 268
  hl-color:: yellow
  id:: 63c93d91-3a2d-45ea-9d9c-eb65e4da5d04
- 以使用 apply()和 call()方法以新创建的对象为上下文执行构造函数
  ls-type:: annotation
  hl-page:: 268
  hl-color:: yellow
  id:: 63c93dd7-96df-496a-bf1a-6c184350ca19
- 以在子类构造函数中向父类构造函数传参。
  ls-type:: annotation
  hl-page:: 268
  hl-color:: yellow
  id:: 63c93de4-0dc9-4c70-a144-b04e221bc27a
- 必须在构造函数中定义方法
  ls-type:: annotation
  hl-page:: 268
  hl-color:: yellow
  id:: 63c93df5-2f34-489a-930e-b9a6568dde33
- 组合继承
  ls-type:: annotation
  hl-page:: 269
  hl-color:: green
  id:: 63c93ea9-bb47-43de-a373-9efa13519b82
- 基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。
  ls-type:: annotation
  hl-page:: 269
  hl-color:: yellow
  id:: 63c93eba-a514-4030-8527-4a70497d0107
- 组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力
  ls-type:: annotation
  hl-page:: 269
  hl-color:: yellow
  id:: 63c93ee2-fb44-451d-a025-db30c3d8e071
- 原型式继承
  ls-type:: annotation
  hl-page:: 270
  hl-color:: green
  id:: 63c93efc-604b-41a0-a784-da4555f4df7f
- 这个 object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。
  ls-type:: annotation
  hl-page:: 270
  hl-color:: yellow
  id:: 63c93f54-ac8e-4414-b462-5ebae069680b
- 一次浅复制。
  ls-type:: annotation
  hl-page:: 270
  hl-color:: yellow
  id:: 63c93f57-86dc-4b9b-9daf-0a58282947a6
- 荐的原型式继承适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。
  ls-type:: annotation
  hl-page:: 270
  hl-color:: yellow
  id:: 63c93f71-88db-4bdc-a990-bd5dacce165c
- 过增加 Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）
  ls-type:: annotation
  hl-page:: 270
  hl-color:: yellow
  id:: 63c93fb9-4f9f-4571-9923-4c410d13a7a1
- 寄生式继承
  ls-type:: annotation
  hl-page:: 271
  hl-color:: green
  id:: 63c93fc1-5ee6-45d0-9512-db007023d377
- 寄生式组合继承
  ls-type:: annotation
  hl-page:: 272
  hl-color:: green
  id:: 63c93fe5-7c09-4bea-a6cb-e136f28385e6
- 主要的效率问题就是父类构造函数始终会被调用两次：
  ls-type:: annotation
  hl-page:: 272
  hl-color:: green
  id:: 63c93ff3-113c-41b4-a9fa-02953691ed57
- 寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。
  ls-type:: annotation
  hl-page:: 273
  hl-color:: yellow
  id:: 63c94048-8bf8-4a06-b6b5-440735a1b003
- 用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。
  ls-type:: annotation
  hl-page:: 273
  hl-color:: yellow
  id:: 63c94051-0f11-4e12-8e92-6a067ca52650
- 解决由于重写原型导致默认 constructor 丢失的问题
  ls-type:: annotation
  hl-page:: 273
  hl-color:: yellow
  id:: 63c94062-caa4-435b-95d3-515785d7bfcb
- 类
  ls-type:: annotation
  hl-page:: 274
  hl-color:: green
  id:: 63c9409d-8fda-4a67-b3ee-3b3e42ba8524
- 然函数声明可以提升，但类定义不能
  ls-type:: annotation
  hl-page:: 274
  hl-color:: yellow
  id:: 63c940b3-cc99-4f5d-937b-a238d5d7422b
- 函数受函数作用域限制，而类受块作用域限制：
  ls-type:: annotation
  hl-page:: 274
  hl-color:: yellow
  id:: 63c940c7-81a7-4968-9708-9cf168eaaf1f
- 空的类定义照样有效
  ls-type:: annotation
  hl-page:: 275
  hl-color:: yellow
  id:: 63c940cf-dbad-4233-8658-57c1d1575535
- 类构造函数
  ls-type:: annotation
  hl-page:: 275
  hl-color:: green
  id:: 63c94108-2f54-48bc-b21a-8ca05c63f5b9
- 默认情况下，类构造函数会在执行之后返回 this 对象。
  ls-type:: annotation
  hl-page:: 276
  hl-color:: yellow
  id:: 63c9419e-fd10-4dd8-adb3-b811e8c2e2a2
- 类构造函数与构造函数的主要区别是，调用类构造函数必须使用 new 操作符
  ls-type:: annotation
  hl-page:: 277
  hl-color:: yellow
  id:: 63c942f1-8a06-40b6-b12b-06f7647294a7
- 重点在于，类中定义的 constructor 方法不会被当成构造函数，在对它使用 instanceof 操作符时会返回 false。但是
  ls-type:: annotation
  hl-page:: 278
  hl-color:: yellow
  id:: 63c94327-19f9-40e5-8cf0-6b3924866191
- 实例、原型和类成员
  ls-type:: annotation
  hl-page:: 279
  hl-color:: green
  id:: 63c94392-8623-4584-a1a1-56f9b5b86fb0
- 每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享：
  ls-type:: annotation
  hl-page:: 279
  hl-color:: yellow
  id:: 63c943ce-7829-4b17-823e-0df7da8065a7
- 类定义也支持获取和设置访问器。语法与行为跟普通对象一样：
  ls-type:: annotation
  hl-page:: 280
  hl-color:: yellow
  id:: 63c94401-c316-42c8-b84d-f743cdd6380c
- 静态成员每个类上只能有一个
  ls-type:: annotation
  hl-page:: 281
  hl-color:: yellow
  id:: 63c9440b-e5c7-4920-bd67-d980d317285d
- 虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加：
  ls-type:: annotation
  hl-page:: 281
  hl-color:: yellow
  id:: 63c94456-0517-4f4c-b2bd-5fc7d6956088
- 一般来说，对象实例应该独自拥有通过 this引用的数据
  ls-type:: annotation
  hl-page:: 282
  hl-color:: yellow
  id:: 63c9446b-cd0e-4ab2-96b6-e534f0286d43
- 类定义语法支持在原型和类本身上定义生成器方法
  ls-type:: annotation
  hl-page:: 282
  hl-color:: yellow
  id:: 63c9449a-8604-4a5e-a4c4-d3eaebcf4d51
- 因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象
  ls-type:: annotation
  hl-page:: 282
  hl-color:: yellow
  id:: 63c944ea-afc7-4f19-99da-fd25b957fe46
- 继承
  ls-type:: annotation
  hl-page:: 283
  hl-color:: green
  id:: 63c94502-1b27-428b-8300-66e386c5748e
- ES6 类支持单继承。使用 extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）
  ls-type:: annotation
  hl-page:: 283
  hl-color:: yellow
  id:: 63c9451c-e281-40ad-a62d-6547cdd26c5d
- 构造函数、HomeObject 和 super()
  ls-type:: annotation
  hl-page:: 284
  hl-color:: yellow
  id:: 63c94557-8a59-4825-a6d9-7312a58ef59d
- 派生类的方法可以通过 super 关键字引用它们的原型。
  ls-type:: annotation
  hl-page:: 284
  hl-color:: yellow
  id:: 63c94d6c-200e-463c-813f-e9f1ec1c67c9
- super 始终会定义为[[HomeObject]]的原型
  ls-type:: annotation
  hl-page:: 285
  hl-color:: yellow
  id:: 63c94d83-5fca-4086-9aa0-a3f096eda8f2
- super 只能在派生类构造函数和静态方法中使用
  ls-type:: annotation
  hl-page:: 285
  hl-color:: yellow
  id:: 63c94d8b-cf4d-4026-a216-acc3fadacbd2
- 不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法
  ls-type:: annotation
  hl-page:: 285
  hl-color:: yellow
  id:: 63c94d97-bbd3-4664-bc86-5ccbb3f76d89
- 调用 super()会调用父类构造函数，并将返回的实例赋值给 this
  ls-type:: annotation
  hl-page:: 285
  hl-color:: yellow
  id:: 63c94da1-3bd8-4487-ab2a-4e109c745df3
- super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入
  ls-type:: annotation
  hl-page:: 285
  hl-color:: yellow
  id:: 63c94da7-59a0-43df-ba50-681940eaa0f4
- 如果没有定义类构造函数，在实例化派生类时会调用 super()，而且会传入所有传给派生类的参数。
  ls-type:: annotation
  hl-page:: 285
  hl-color:: yellow
  id:: 63c94dad-6b16-4881-8ba2-0ec3274a8fb4
- 在类构造函数中，不能在调用 super()之前引用 this
  ls-type:: annotation
  hl-page:: 286
  hl-color:: yellow
  id:: 63c94db4-dc37-4254-a8f2-2ea3ff331a26
- 如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象
  ls-type:: annotation
  hl-page:: 286
  hl-color:: yellow
  id:: 63c94dbb-5caa-4f8e-be39-c77e0a2eea65
- 混入模式可以通过在一个表达式中连缀多个混入元素来实现，这个表达式最终会解析为一个可以被继承的类
  ls-type:: annotation
  hl-page:: 288
  hl-color:: yellow
  id:: 63c94e03-3251-4b15-844a-5798494a0efd
- 一个策略是定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式
  ls-type:: annotation
  hl-page:: 289
  hl-color:: yellow
  id:: 63c94e28-816a-4315-a1d8-87bf248cf22d
- 代理是目标对象的抽象
  ls-type:: annotation
  hl-page:: 291
  hl-color:: yellow
  id:: 63ce3b14-0ba4-4a8d-9cf8-b5d0a8877c92
- 代理基础
  ls-type:: annotation
  hl-page:: 291
  hl-color:: green
  id:: 63ce3b1d-c37a-4e88-b47e-74ebc79600c7
- 目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为
  ls-type:: annotation
  hl-page:: 291
  hl-color:: yellow
  id:: 63ce3b72-33f0-47f5-9227-8e4286d27b15
- 创建空代理
  ls-type:: annotation
  hl-page:: 291
  hl-color:: green
  id:: 63ce3c12-b015-41f0-b063-83853c2f88dd
- 代理是使用 Proxy 构造函数创建的
  ls-type:: annotation
  hl-page:: 291
  hl-color:: yellow
  id:: 63ce3c2d-1932-4e69-81d6-466dd3ac82d3
- 接收两个参数：目标对象和处理程序对象
  ls-type:: annotation
  hl-page:: 291
  hl-color:: yellow
  id:: 63ce3c37-fcb0-4cac-aedf-17ee5ceba495
- Proxy.prototype 是 undefined
  ls-type:: annotation
  hl-page:: 292
  hl-color:: yellow
  id:: 63ce3c71-ac03-45a5-912a-24d5beb0ad55
- 因此不能使用 instanceof 操作符
  ls-type:: annotation
  hl-page:: 292
  hl-color:: yellow
  id:: 63ce3c78-56d1-45c1-9852-e5a9297e766c
- 严格相等可以用来区分代理和目标
  ls-type:: annotation
  hl-page:: 292
  hl-color:: yellow
  id:: 63ce3c8f-1d39-4484-82de-db2696e3c399
- 定义捕获器
  ls-type:: annotation
  hl-page:: 292
  hl-color:: green
  id:: 63ce3ca3-2e1f-4e09-9892-7068262c31c3
- 捕获器就是在处理程序对象中定义的“基本操作的拦截器”
  ls-type:: annotation
  hl-page:: 292
  hl-color:: yellow
  id:: 63ce3cb8-d599-4635-987f-f29bc95fc1a3
- 每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。
  ls-type:: annotation
  hl-page:: 292
  hl-color:: yellow
  id:: 63ce3cd9-191c-46f4-a220-0418b0797757
- proxy[property]、proxy.property 或 Object.create(proxy)[property]等操作都会触发基本的 get()操作以获取属性
  ls-type:: annotation
  hl-page:: 293
  hl-color:: yellow
  id:: 63ce3d0e-02ed-436c-a9ff-ce7f994bf54a
- 捕获器参数和反射 API
  ls-type:: annotation
  hl-page:: 293
  hl-color:: green
  id:: 63ce3d2d-fbbf-4ba8-afd8-002840790945
- return trapTarget[property];
  ls-type:: annotation
  hl-page:: 294
  hl-color:: yellow
  id:: 63ce3d8e-a369-4be9-8b29-9a6771cd2f14
- 开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建
  ls-type:: annotation
  hl-page:: 294
  hl-color:: yellow
  id:: 63ce3d9c-9608-4b9a-95c8-3920eb0a646f
- 处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法
  ls-type:: annotation
  hl-page:: 294
  hl-color:: yellow
  id:: 63ce3da9-0c6a-4345-b0ad-1acfb37456a5
- 具有与被拦截方法相同的行为
  ls-type:: annotation
  hl-page:: 294
  hl-color:: yellow
  id:: 63ce3dd2-0e0e-4bf2-860e-a27577556908
- const proxy = new Proxy(target, Reflect);
  ls-type:: annotation
  hl-page:: 295
  hl-color:: yellow
  id:: 63ce3e02-61f9-4ba1-b9d6-94caca25e7b0
- 反射 API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法
  ls-type:: annotation
  hl-page:: 295
  hl-color:: yellow
  id:: 63ce3e1a-de10-434a-946e-c746bf79ac45
- 捕获器不变式
  ls-type:: annotation
  hl-page:: 295
  hl-color:: green
  id:: 63ce3e27-c4b7-4d0e-8783-7b52fe0b5f0c
- 每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（trap invariant）。
  ls-type:: annotation
  hl-page:: 295
  hl-color:: yellow
  id:: 63ce3e36-e6fa-4469-a7bb-ee960efacb6b
- 可撤销代理
  ls-type:: annotation
  hl-page:: 296
  hl-color:: green
  id:: 63ce3e73-7e12-4419-a90c-5278d7eb4cdc
- revocable()方法，这个方法支持撤销代理对象与目标对象的关联
  ls-type:: annotation
  hl-page:: 296
  hl-color:: yellow
  id:: 63ce3e8f-7d03-4ec6-a38f-bb1d184425df
- 撤销函数（revoke()）是幂等的，调用多少次的结果都一样
  ls-type:: annotation
  hl-page:: 296
  hl-color:: yellow
  id:: 63ce3e9d-4d49-4126-91e3-9a3992911785
- 实用反射 API
  ls-type:: annotation
  hl-page:: 296
  hl-color:: green
  id:: 63ce3f06-3470-4ca5-a9d7-5321fa4ad8b3
- Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作
  ls-type:: annotation
  hl-page:: 296
  hl-color:: yellow
  id:: 63ce3f16-e000-4a2a-9335-d612185928eb
- 以下反射方法都会提供状态标记：
  ls-type:: annotation
  hl-page:: 297
  hl-color:: yellow
  id:: 63ce3f68-7b09-4865-a52e-0f5091012788
  hl-stamp:: 1674461034942
- 用一等函数替代操作符
  ls-type:: annotation
  hl-page:: 297
  hl-color:: yellow
  id:: 63ce3f84-304d-4d4c-bef4-c6f68e8994f7
- 安全地应用函数
  ls-type:: annotation
  hl-page:: 297
  hl-color:: yellow
  id:: 63ce3f90-592d-4fb4-b571-d501e628eced
- 代理另一个代理
  ls-type:: annotation
  hl-page:: 298
  hl-color:: green
  id:: 63ce3fbf-1fa0-4c67-bc57-bdb98dac101c
  hl-stamp:: 1674461122136
- 创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网
  ls-type:: annotation
  hl-page:: 298
  hl-color:: yellow
  id:: 63ce3fda-bdec-42f8-af4b-a4f490865d36
- User 实例一开始使用目标对象作为 WeakMap 的键
  ls-type:: annotation
  hl-page:: 299
  hl-color:: yellow
  id:: 63ce405d-4ee3-4cba-bee8-46c2e77a39d4
- 把代理 User 实例改为代理 User 类本身
  ls-type:: annotation
  hl-page:: 299
  hl-color:: yellow
  id:: 63ce4077-b423-43de-a709-7a53433cdb2a
- 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。
  ls-type:: annotation
  hl-page:: 299
  hl-color:: yellow
  id:: 63ce40a6-36fc-46f6-9a7b-dda580811a30
- 代理捕获器与反射方法
  ls-type:: annotation
  hl-page:: 299
  hl-color:: green
  id:: 63ce40b0-c17f-4aed-8693-bcb7a54110a7
- 代理的问题与不足
  ls-type:: annotation
  hl-page:: 298
  hl-color:: green
  id:: 63ce40bd-8df4-466f-966f-526b6ae6f0cf
- 代理可以捕获 13 种不同的基本操作。这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript操作和不变式。
  ls-type:: annotation
  hl-page:: 299
  hl-color:: yellow
  id:: 63ce40f3-9d0f-41d3-aba3-371a7b98faa1
- get()
  ls-type:: annotation
  hl-page:: 300
  hl-color:: green
  id:: 63ce4144-1c63-445b-953a-0a89ba3d0b76
- 如果 target.property 不可写且不可配置，则处理程序返回的值必须与 target.property 匹配。
  ls-type:: annotation
  hl-page:: 300
  hl-color:: yellow
  id:: 63ce414d-6b18-4c36-8f39-e7343cd82c3e
- 如果 target.property 不可配置且[[Get]]特性为 undefined，处理程序的返回值也必须是 undefined。
  ls-type:: annotation
  hl-page:: 300
  hl-color:: yellow
  id:: 63ce4153-80ba-4ab0-abd8-56a31e687c07
- set()
  ls-type:: annotation
  hl-page:: 300
  hl-color:: green
  id:: 63ce415e-b96d-4a62-9cb3-117350a55116
- has()
  ls-type:: annotation
  hl-page:: 301
  hl-color:: green
  id:: 63ce418a-ae9f-4255-ad78-92ae36636e2a
  hl-stamp:: 1674461580188
- has()必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。
  ls-type:: annotation
  hl-page:: 301
  hl-color:: yellow
  id:: 63ce419b-a462-4ab5-a20a-57542392fd9f
- defineProperty()
  ls-type:: annotation
  hl-page:: 302
  hl-color:: green
  id:: 63ce41c5-b272-470c-92a6-7789815f4090
- getOwnPropertyDescriptor()
  ls-type:: annotation
  hl-page:: 302
  hl-color:: green
  id:: 63ce421d-bd57-4845-974d-dadd661495f7
- deleteProperty()
  ls-type:: annotation
  hl-page:: 303
  hl-color:: green
  id:: 63ce4285-f83a-4f94-b6b8-ad907ae5f2bb
- deleteProperty()捕获器会在 delete 操作符中被调用
  ls-type:: annotation
  hl-page:: 303
  hl-color:: yellow
  id:: 63ce428d-26fe-4813-8dbb-1e7922fb5a22
- ownKeys()
  ls-type:: annotation
  hl-page:: 304
  hl-color:: green
  id:: 63ce4298-629c-4564-8f11-aaf6ca4edf72
  hl-stamp:: 1674461850093
- ownKeys()捕获器会在 Object.keys()及类似方法中被调用。
  ls-type:: annotation
  hl-page:: 304
  hl-color:: yellow
  id:: 63ce42a5-582f-4f3e-9d81-62e7424c3e77
- getPrototypeOf()
  ls-type:: annotation
  hl-page:: 304
  hl-color:: green
  id:: 63ce42c3-ac31-41af-923e-a76f58ed5468
- setPrototypeOf()
  ls-type:: annotation
  hl-page:: 305
  hl-color:: green
  id:: 63ce42ff-949a-4365-ad48-aa2ce53e1caa
- isExtensible()
  ls-type:: annotation
  hl-page:: 305
  hl-color:: green
  id:: 63ce430b-506d-4b2e-9c6b-498b470a2879
- preventExtensions()
  ls-type:: annotation
  hl-page:: 306
  hl-color:: green
  id:: 63ce4311-2b48-4fba-91af-2064f5237a1d
- apply()
  ls-type:: annotation
  hl-page:: 306
  hl-color:: green
  id:: 63ce4339-9afb-486e-87d5-6f91bb8a8792
- apply()捕获器会在调用函数时中被调用
  ls-type:: annotation
  hl-page:: 306
  hl-color:: yellow
  id:: 63ce434a-5116-439a-bb65-5d637e8f5ff0
- preventExtensions()必须返回布尔值，表示 target 是否已经不可扩展
  ls-type:: annotation
  hl-page:: 306
  hl-color:: yellow
  id:: 63ce4354-f220-489e-b90d-94e2a48ee26d
- isExtensible()必须返回布尔值，表示 target 是否可扩展。
  ls-type:: annotation
  hl-page:: 306
  hl-color:: yellow
  id:: 63ce4361-540f-4ef3-9af8-a29fb37f2917
- construct()
  ls-type:: annotation
  hl-page:: 307
  hl-color:: green
  id:: 63ce436f-7740-4a82-b2ba-bc9ec7cf93d3
  hl-stamp:: 1674462064929
- 代理模式
  ls-type:: annotation
  hl-page:: 308
  hl-color:: green
  id:: 63ce4378-f6d1-4d15-8618-5248bfe27c43
- 跟踪属性访问
  ls-type:: annotation
  hl-page:: 308
  hl-color:: green
  id:: 63ce438c-ac67-4976-ab85-64b48e88f515
- 隐藏属性
  ls-type:: annotation
  hl-page:: 308
  hl-color:: green
  id:: 63ce43a2-652f-4f11-abac-460a8b021e13
- 理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举
  ls-type:: annotation
  hl-page:: 308
  hl-color:: yellow
  id:: 63ce449d-47e2-48a4-bc9b-4e93d564fecf
- 属性验证
  ls-type:: annotation
  hl-page:: 309
  hl-color:: green
  id:: 63ce44a8-68aa-44b8-83e5-bb468941ddb5
- 因为所有赋值操作都会触发 set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：
  ls-type:: annotation
  hl-page:: 309
  hl-color:: yellow
  id:: 63ce4561-852d-4ba7-879a-68c34871c22a
- 函数与构造函数参数验证
  ls-type:: annotation
  hl-page:: 309
  hl-color:: green
  id:: 63ce4569-9657-4186-b3d8-cc72f8921cce
- 数据绑定与可观察对象
  ls-type:: annotation
  hl-page:: 310
  hl-color:: green
  id:: 63ce463a-9535-4a84-b395-b6ecf477696c
- 可以要求实例化时必须给构造函数传参：
  ls-type:: annotation
  hl-page:: 310
  hl-color:: yellow
  id:: 63ce4649-dbb4-4220-86c3-b675819d620d
- 以让函数只接收某种类型的值
  ls-type:: annotation
  hl-page:: 309
  hl-color:: yellow
  id:: 63ce464f-952c-4183-9d5a-094ceaa109b6
- 通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作
  ls-type:: annotation
  hl-page:: 310
  hl-color:: yellow
  id:: 63ce4680-128a-4354-8720-d29342c88645
- 让所有创建的实例都被添加到这个集合
  ls-type:: annotation
  hl-page:: 310
  hl-color:: yellow
  id:: 63ce468c-3b2d-4035-935f-04fc420d857a
- 还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息
  ls-type:: annotation
  hl-page:: 311
  hl-color:: yellow
  id:: 63ce46ac-43ed-48df-adc7-753af5311f5b
- 每个函数都是 Function类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。
  ls-type:: annotation
  hl-page:: 312
  hl-color:: yellow
  id:: 63ce475c-df80-4276-8974-ed85467ee048
- 函数表达式与函数声明几乎是等价的：
  ls-type:: annotation
  hl-page:: 312
  hl-color:: yellow
  id:: 63ce4791-c39d-4d68-9ad3-4cf294aa8b0c
- “箭头函数”（arrow function
  ls-type:: annotation
  hl-page:: 312
  hl-color:: yellow
  id:: 63ce4880-9e52-4cbb-9dcd-b02434617cdb
- 使用 Function 构造函数。这个构造函数接收任意多个字符串参数，最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数
  ls-type:: annotation
  hl-page:: 312
  hl-color:: yellow
  id:: 63ce48a0-4e1b-493a-b8c4-38a0a7bc2291
- 箭头函数
  ls-type:: annotation
  hl-page:: 313
  hl-color:: green
  id:: 63ce48b1-bb98-4826-871d-e8b9f695efde
- 箭头函数不能使用 arguments、super 和 new.target，也不能用作构造函数
  ls-type:: annotation
  hl-page:: 313
  hl-color:: yellow
  id:: 63ce493d-553d-4a7f-8a0d-b023fac9cea7
- 箭头函数也没有 prototype 属性。
  ls-type:: annotation
  hl-page:: 313
  hl-color:: yellow
  id:: 63ce4944-ff39-4f08-992a-a1f7d655095a
- 函数名
  ls-type:: annotation
  hl-page:: 314
  hl-color:: green
  id:: 63ce494a-7d12-47ac-84c5-a96e6f82ceb0
- 使用不带括号的函数名会访问函数指针，而不会执行函数
  ls-type:: annotation
  hl-page:: 314
  hl-color:: yellow
  id:: 63ce496f-0463-4b45-9d1a-0362770f813b
- let anotherSum = sum;
  ls-type:: annotation
  hl-page:: 314
  hl-color:: yellow
  id:: 63ce4977-7f52-42a8-a2fc-66511700e4b1
- ECMAScript 6 的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息
  ls-type:: annotation
  hl-page:: 314
  hl-color:: yellow
  id:: 63ce4a78-6a38-422d-8fa0-b5a25aec770f
- 理解参数
  ls-type:: annotation
  hl-page:: 315
  hl-color:: green
  id:: 63ce4a83-e615-4d4a-b5d7-11b1a4480d37
- ECMAScript 函数的参数在内部表现为一个数组
  ls-type:: annotation
  hl-page:: 315
  hl-color:: yellow
  id:: 63ce4aaf-57d2-42e3-b220-34f9440f1f69
- 通过 arguments 对象的 length 属性检查传入的参数个数
  ls-type:: annotation
  hl-page:: 315
  hl-color:: yellow
  id:: 63ce4af5-3fe0-4c07-a935-2ee02c55b452
- arguments 对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。
  ls-type:: annotation
  hl-page:: 316
  hl-color:: yellow
  id:: 63ce4b43-c548-49e9-9e63-85600e1b34c3
- arguments 对象可以跟命名参数一起使用
  ls-type:: annotation
  hl-page:: 316
  hl-color:: yellow
  id:: 63ce4b53-152a-4f8e-8eb9-d1cc756c50aa
- 果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问
  ls-type:: annotation
  hl-page:: 316
  hl-color:: yellow
  id:: 63ce4be6-0bef-425a-988a-3a409d369d3e
- 没有重载
  ls-type:: annotation
  hl-page:: 317
  hl-color:: green
  id:: 63ce4c27-1c0d-42c4-9c30-0917702eadaa
- 没有函数签名，自然也就没有重载。
  ls-type:: annotation
  hl-page:: 317
  hl-color:: yellow
  id:: 63ce4c3f-edc6-420a-a383-21d31038f469
- 默认参数值
  ls-type:: annotation
  hl-page:: 318
  hl-color:: green
  id:: 63ce4cec-dfe1-412a-a463-f4b73ae98f73
- 默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值
  ls-type:: annotation
  hl-page:: 318
  hl-color:: yellow
  id:: 63ce4e16-6fe1-42d2-abc9-81493de52513
- 因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数
  ls-type:: annotation
  hl-page:: 319
  hl-color:: yellow
  id:: 63ce4e4f-be60-4efd-b625-3f1fa5678ae6
- 参数扩展与收集
  ls-type:: annotation
  hl-page:: 320
  hl-color:: green
  id:: 63ce4ea3-26e0-4202-8f9d-b84738526342
- 扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数。
  ls-type:: annotation
  hl-page:: 320
  hl-color:: yellow
  id:: 63ce4fda-fb74-4181-9eec-c77b95490a4a
- console.log(getSum(...values)); // 10
  ls-type:: annotation
  hl-page:: 320
  hl-color:: yellow
  id:: 63ce5040-41c4-475d-a3c9-e676e3528275
- 因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参数
  ls-type:: annotation
  hl-page:: 320
  hl-color:: yellow
  id:: 63ce504c-49b4-4429-ac36-bba7e54d1970
- console.log(getSum(-1, ...values)); 
  ls-type:: annotation
  hl-page:: 320
  hl-color:: yellow
  id:: 63ce5052-f49d-4569-b829-9b7c204a63f0
- 收集参数
  ls-type:: annotation
  hl-page:: 321
  hl-color:: green
  id:: 63ce5075-de26-46a0-9425-f226faa85ab9
- 扩展参数
  ls-type:: annotation
  hl-page:: 320
  hl-color:: green
  id:: 63ce507b-24d7-4b20-8e97-c3b47261cdc9
- 函数声明与函数表达式
  ls-type:: annotation
  hl-page:: 322
  hl-color:: green
  id:: 63ce50c1-c3ac-4250-bae7-33af9cf63cfc
- 函数声明提升
  ls-type:: annotation
  hl-page:: 322
  hl-color:: yellow
  id:: 63ce5104-40e0-40af-bd93-01bfbfa4e1b7
- 如果把前面代码中的函数声明改为等价的函数表达式，那么执行的时候就会出错
  ls-type:: annotation
  hl-page:: 322
  hl-color:: yellow
  id:: 63ce5112-41b5-4297-893e-0745fbf342ee
- 函数作为值
  ls-type:: annotation
  hl-page:: 322
  hl-color:: green
  id:: 63ce512e-3777-43dc-a487-3058b6d9d331
- 不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数
  ls-type:: annotation
  hl-page:: 322
  hl-color:: yellow
  id:: 63ce5145-7afa-45d9-99c0-5141844adc06
- 函数内部
  ls-type:: annotation
  hl-page:: 324
  hl-color:: green
  id:: 63ce51d5-3dab-491c-9b77-305d5b516708
- arguments
  ls-type:: annotation
  hl-page:: 324
  hl-color:: green
  id:: 63ce51e3-fb76-4f5f-8641-65b9657f9718
- arguments 对象其实还有一个 callee 属性，是一个指向 arguments 对象所在函数的指针
  ls-type:: annotation
  hl-page:: 324
  hl-color:: yellow
  id:: 63ce5208-7d9f-4a23-8314-476a1df1b6d4
- 使用 arguments.callee 就可以让函数逻辑与函数名解耦
  ls-type:: annotation
  hl-page:: 324
  hl-color:: yellow
  id:: 63ce523f-e112-47ad-b61a-a538d5c2ffef
- this
  ls-type:: annotation
  hl-page:: 325
  hl-color:: green
  id:: 63ce5256-ff61-457b-9914-8b99a90571b8
- 在标准函数中，this 引用的是把函数当成方法调用的上下文对象
  ls-type:: annotation
  hl-page:: 325
  hl-color:: yellow
  id:: 63ce5279-1b85-49b5-bd3b-b5e0a0d85fbc
- 回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的 this 会保留定义该函数时的上下文
  ls-type:: annotation
  hl-page:: 325
  hl-color:: yellow
  id:: 63ce531b-1aa4-4b80-9a80-df39df09189b
- caller
  ls-type:: annotation
  hl-page:: 326
  hl-color:: green
  id:: 63ce5334-7cb4-4f57-b307-da2a9d5c327c
- 这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null
  ls-type:: annotation
  hl-page:: 326
  hl-color:: yellow
  id:: 63ce5348-8505-4bed-98b2-aba0c5ce6461
- 在严格模式下访问 arguments.callee 会报错
  ls-type:: annotation
  hl-page:: 326
  hl-color:: yellow
  id:: 63ce5367-8959-492f-92e9-dcedcdfa9d23
- arguments.caller，但在严格模式下访问它会报错
  ls-type:: annotation
  hl-page:: 326
  hl-color:: yellow
  id:: 63ce5373-9173-45fc-b150-6f1fd3817038
- new.target
  ls-type:: annotation
  hl-page:: 326
  hl-color:: green
  id:: 63ce537d-94e9-41cf-b911-f81399eed7a0
- 检测函数是否使用 new 关键字调用的 new.target 属性
  ls-type:: annotation
  hl-page:: 326
  hl-color:: yellow
  id:: 63ce543d-27be-43d5-808d-39eea77c8728
- 函数属性与方法
  ls-type:: annotation
  hl-page:: 327
  hl-color:: green
  id:: 63ce5445-4053-46e6-ba48-d75a3f614456
- length 属性保存函数定义的命名参数的个数
  ls-type:: annotation
  hl-page:: 327
  hl-color:: yellow
  id:: 63ce54d1-32b7-462f-9761-2ea5b35db90a
- prototype 是保存引用类型所有实例方法的地方
  ls-type:: annotation
  hl-page:: 327
  hl-color:: yellow
  id:: 63ce54e1-bbbd-461b-b6f1-45c81ba49627
- 在严格模式下，调用函数时如果没有指定上下文对象，则 this 值不会指向 window。除非使用 apply()或 call()把函数指定给一个对象，否则 this 的值会变成 undefined
  ls-type:: annotation
  hl-page:: 328
  hl-color:: yellow
  id:: 63ce55c9-5616-4734-acef-f2b969acdbd9
- call()方法与 apply()的作用一样，只是传参的形式不同。
  ls-type:: annotation
  hl-page:: 328
  hl-color:: yellow
  id:: 63ce55d9-f47a-46b4-ae19-78e29284cf62
- apply()和 call()真正强大的地方并不是给函数传参，而是控制函数调用上下文即函数体内 this值的能力
  ls-type:: annotation
  hl-page:: 328
  hl-color:: yellow
  id:: 63ce5628-215a-4604-9c09-2c9ea8e64458
- 使用 call()或 apply()的好处是可以将任意对象设置为任意函数的作用域，这样对象可以不用关心方法
  ls-type:: annotation
  hl-page:: 329
  hl-color:: yellow
  id:: 63ce564c-9816-4d36-ac4b-3677614c9cee
- 。bind()方法会创建一个新的函数实例，其 this 值会被绑定到传给 bind()的对象
  ls-type:: annotation
  hl-page:: 329
  hl-color:: yellow
  id:: 63ce56ab-8bf8-4060-b18c-10ab7eb83b47
- 函数表达式
  ls-type:: annotation
  hl-page:: 329
  hl-color:: green
  id:: 63ce56c3-0808-4a72-a998-405cabc928ae
- 这样创建的函数叫作匿名函数
  ls-type:: annotation
  hl-page:: 330
  hl-color:: yellow
  id:: 63ce5748-4f6f-4e84-bbcc-5e49d932710e
- 如果把上面的函数声明换成函数表达式就没问
  ls-type:: annotation
  hl-page:: 330
  hl-color:: yellow
  id:: 63ce579c-5993-47e1-b7af-b8c9722710e8
- 递归
  ls-type:: annotation
  hl-page:: 331
  hl-color:: green
  id:: 63ce57d9-b8bf-407f-9c80-e6aabf35cc91
- 不过，在严格模式下运行的代码是不能访问 arguments.callee 的，因为访问会出错。此时，可以使用命名函数表达式（named function expression）达到目的
  ls-type:: annotation
  hl-page:: 331
  hl-color:: yellow
  id:: 63ce57f2-15fb-4430-82cb-361162c49bf1
- 尾调用优化
  ls-type:: annotation
  hl-page:: 332
  hl-color:: green
  id:: 63ce580b-f364-4e97-9d24-70baeeef164c
- 这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值
  ls-type:: annotation
  hl-page:: 332
  hl-color:: yellow
  id:: 63ce587a-f2ea-4a95-87ff-5451ef6fc8e1
- 尾调用优化的条件
  ls-type:: annotation
  hl-page:: 332
  hl-color:: green
  id:: 63ce5906-5bae-40df-8a84-0488df2e906f
- 确定外部栈帧真的没有必要存在了
  ls-type:: annotation
  hl-page:: 332
  hl-color:: yellow
  id:: 63ce591a-bca0-49e3-b8f8-3bf9f34f0d25
- 代码在严格模式下执行
  ls-type:: annotation
  hl-page:: 332
  hl-color:: yellow
  id:: 63ce71a9-9f07-4980-8bdf-dd5066d10168
- 外部函数的返回值是对尾调用函数的调用
  ls-type:: annotation
  hl-page:: 332
  hl-color:: yellow
  id:: 63ce71ee-91cb-4828-8a4a-8935578c3072
- 尾调用函数返回后不需要执行额外的逻辑
  ls-type:: annotation
  hl-page:: 333
  hl-color:: yellow
  id:: 63ce7216-34ec-4d4e-a91b-4849ff4123e7
- 尾调用函数不是引用外部函数作用域中自由变量的闭包
  ls-type:: annotation
  hl-page:: 333
  hl-color:: yellow
  id:: 63ce721f-9fe8-4792-9fe1-13339b21b320
- 尾调用优化的代码
  ls-type:: annotation
  hl-page:: 334
  hl-color:: green
  id:: 63ce723c-e9f3-40c4-ab6d-100fa9e9b2a3
- 为此可以使用两个嵌套的函数，外部函数作为基础框架，内部函数执行递归
  ls-type:: annotation
  hl-page:: 334
  hl-color:: yellow
  id:: 63ce726e-12e3-4630-b138-f182e93999d9
- 闭包
  ls-type:: annotation
  hl-page:: 334
  hl-color:: green
  id:: 63ce72b0-faef-4004-9b6e-f3fa76944796
- 闭包指的是那些引用了另一个函数作用域中变量的函
  ls-type:: annotation
  hl-page:: 334
  hl-color:: yellow
  id:: 63ce7308-f609-4e10-8059-814d461afc89
- 全局上下文中的叫变量对象，它会在代码执行期间始终存在
  ls-type:: annotation
  hl-page:: 335
  hl-color:: yellow
  id:: 63ce7399-a96e-4125-9a8b-ef38a9491027
- 活动对象，只在函数执行期间存在
  ls-type:: annotation
  hl-page:: 335
  hl-color:: yellow
  id:: 63ce73a0-2706-408f-b978-fab2dcd7486e
- 。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域
  ls-type:: annotation
  hl-page:: 336
  hl-color:: yellow
  id:: 63ce73dd-c238-49e3-9a09-cc4681392f0d
- this 对象
  ls-type:: annotation
  hl-page:: 337
  hl-color:: green
  id:: 63ce7454-073c-4d83-a673-1d994a342dae
- 么匿名函数没有使用其包含作用域（getIdentityFunc()）的 this 对象呢？
  ls-type:: annotation
  hl-page:: 338
  hl-color:: yellow
  id:: 63ce74a4-1ac8-4f35-91fd-468be88ccb1e
- 在一些特殊情况下，this 值可能并不是我们所期待的值。比如下面这个修改后的例子：
  ls-type:: annotation
  hl-page:: 338
  hl-color:: yellow
  id:: 63ce74e6-6288-4bc3-87e5-f8e1f3eb6e88
- 即使语法稍有不同，也可能影响 this 的值
  ls-type:: annotation
  hl-page:: 338
  hl-color:: yellow
  id:: 63ce7556-5a94-48c6-9d17-de50c830c5d4
- 如果在全局函数中调用，则 this 在非严格模式下等于 window，在严格模式下等于 undefined。如果作为某个对象的方法调用，则 this 等于这个对象。
  ls-type:: annotation
  hl-page:: 337
  hl-color:: yellow
  id:: 63ce7562-1da2-4d32-96a0-c5d669455209
- 内存泄漏
  ls-type:: annotation
  hl-page:: 339
  hl-color:: green
  id:: 63ce75b4-e707-4b2b-81c1-3107967ce08b
- 在这些版本的 IE 中，把 HTML 元素保存在某个闭包的作用域中，就相当于宣布该元素不能被销毁。
  ls-type:: annotation
  hl-page:: 339
  hl-color:: yellow
  id:: 63ce75e3-7dfb-40b7-9b62-a03b0e9106a6
- 立即调用的函数表达式
  ls-type:: annotation
  hl-page:: 339
  hl-color:: green
  id:: 63ce7fd4-4885-4655-a1ef-547b890adbf6
- 立 即 调 用 的 匿 名 函 数 又 被 称 作 立 即 调 用 的 函 数 表 达 式 （ IIFE ， Immediately Invoked Function Expression）。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式
  ls-type:: annotation
  hl-page:: 339
  hl-color:: yellow
  id:: 63ce8049-59c0-43b2-b253-941686f09944
- 在 ECMAScript 6 以后，IIFE 就没有那么必要了，因为块级作用域中的变量无须 IIFE 就可以实现同样的隔离
  ls-type:: annotation
  hl-page:: 340
  hl-color:: yellow
  id:: 63ce807b-8337-4573-961f-d23248e9fc12
- 私有变量
  ls-type:: annotation
  hl-page:: 341
  hl-color:: green
  id:: 63ce80ee-1be1-4581-bcfc-a205a6104af3
- 私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。
  ls-type:: annotation
  hl-page:: 341
  hl-color:: yellow
  id:: 63ce8101-8cbd-4257-948f-6aadba753203
- 特权方法（privileged method）是能够访问函数私有变量（及私有函数）的公有方法。
  ls-type:: annotation
  hl-page:: 341
  hl-color:: yellow
  id:: 63ce811e-9911-4a38-b64a-a02f6cb162c0
- 是因为定义在构造函数中的特权方法其实是一个闭包
  ls-type:: annotation
  hl-page:: 342
  hl-color:: yellow
  id:: 63ce8149-9e7d-4bed-a1b7-914ca210e9a3
- 静态私有变量
  ls-type:: annotation
  hl-page:: 342
  hl-color:: green
  id:: 63ce818f-dac7-4510-bdee-d50c08dc5519
  hl-stamp:: 1674477969543
- 构造函数模式的缺点是每个实例都会重新创建一遍新方法。
  ls-type:: annotation
  hl-page:: 342
  hl-color:: yellow
  id:: 63ce81ac-6423-45f5-a5a2-43df5429e615
- 模块模式
  ls-type:: annotation
  hl-page:: 343
  hl-color:: green
  id:: 63ce821a-5640-4199-9dfa-0847dbfcb7ee
- 模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法
  ls-type:: annotation
  hl-page:: 344
  hl-color:: yellow
  id:: 63ce8239-640f-4f7a-a73d-d99e7da0ae39
- 如果单例对象需要进行某种初始化，并且需要访问私有变量时，那就可以采用这个模式
  ls-type:: annotation
  hl-page:: 344
  hl-color:: yellow
  id:: 63ce829f-8fc5-4cb3-9c1f-d620e1e3b561
- 创建这个对象之后，内部就会创建一个私有的数组 components，然后将一个 BaseComponent 组件的新实例添加到数组
  ls-type:: annotation
  hl-page:: 344
  hl-color:: yellow
  id:: 63ce82e2-12ad-474f-9bb2-f613f5bb1850
- 模块增强模式
  ls-type:: annotation
  hl-page:: 345
  hl-color:: green
  id:: 63ce834d-625e-4729-8bef-c2abeeab91dd
- 例对象作为一个模块，经过初始化可以包含某些私有的数据，而这些数据又可以通过其暴露的公共方法来访问
  ls-type:: annotation
  hl-page:: 345
  hl-color:: yellow
  id:: 63ce8361-f411-44d1-8337-fa2b96fbe31d
- 在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。
  ls-type:: annotation
  hl-page:: 345
  hl-color:: yellow
  id:: 63ce836a-179c-4597-9db1-1a1bc860f105
- 主要区别在于这里创建了一个名为 app 的变量，其中保存了 BaseComponent 组件的实例。这是最终要变成 application 的那个对象的局部版本
  ls-type:: annotation
  hl-page:: 346
  hl-color:: yellow
  id:: 63ce8391-b1c1-41ac-b557-188a3912ffe0
  hl-stamp:: 1674478505464
- 异步编程
  ls-type:: annotation
  hl-page:: 347
  hl-color:: green
  id:: 63ce8478-3ef3-4354-b849-433f84163d2b
- ECMAScript 6 新增了正式的 Promise（期约）引用类型，支持优雅地定义和组织异步逻
  ls-type:: annotation
  hl-page:: 347
  hl-color:: yellow
  id:: 63cfc53f-b92e-412f-a143-49643015aec5
- 接下来几个版本增加了使用 async 和 await 关键字定义异步函数的机制。
  ls-type:: annotation
  hl-page:: 347
  hl-color:: yellow
  id:: 63cfc562-c06d-4053-bc4b-cc7cf727b926
- 此外，浏览器控制台的输出经常能打印出 JavaScript 运行中无法获取的对象信息（比如期约的状态）
  ls-type:: annotation
  hl-page:: 347
  hl-color:: yellow
  id:: 63cfc57d-624c-4b6d-935d-e19807c032aa
- 这两行 JavaScript 代码对应的低级指令（从 JavaScript 到 x86）并不难想象
  ls-type:: annotation
  hl-page:: 348
  hl-color:: yellow
  id:: 63cfc590-e8a1-495c-a81c-5d6f78306290
- 异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行
  ls-type:: annotation
  hl-page:: 348
  hl-color:: yellow
  id:: 63cfc59e-73a6-4266-b138-b9024264c5a2
- 异步操作的例子可以是在定时回调中执行一次简单的数学计算：
  ls-type:: annotation
  hl-page:: 348
  hl-color:: yellow
  id:: 63cfc624-79d6-43da-a671-0bab4845ece9
- 由系统计时器触发
  ls-type:: annotation
  hl-page:: 348
  hl-color:: yellow
  id:: 63cfc662-2d8a-4846-96ec-a81aa2a0e61e
- 成一个入队执行的中断。
  ls-type:: annotation
  hl-page:: 348
  hl-color:: yellow
  id:: 63cfc665-0f18-4593-8904-31dfbedd1249
- 早期的 JavaScript 中，只支持定义回调函数来表明异步操作完成
  ls-type:: annotation
  hl-page:: 348
  hl-color:: yellow
  id:: 63cfc698-b94f-49d8-a1b2-5a2682469269
- setTimeout 可以定义一个在指定时间之后会被调度执行的回调函数
  ls-type:: annotation
  hl-page:: 348
  hl-color:: yellow
  id:: 63cfc6ce-67f2-499b-9e71-9196105298be
- double()函数在 setTimeout 成功调度异步操作之后会立即退出
  ls-type:: annotation
  hl-page:: 348
  hl-color:: yellow
  id:: 63cfc731-6bac-41be-8f09-b4a06d8c8042
- 期约
  ls-type:: annotation
  hl-page:: 350
  hl-color:: green
  id:: 63cfc7bc-7aca-4b18-bbba-6b696432f61c
- 引用类型 Promise，可以通过 new 操作符来实例化
  ls-type:: annotation
  hl-page:: 350
  hl-color:: yellow
  id:: 63cfc8bd-26f4-424c-9f9b-6b13f406f079
- 期约基础
  ls-type:: annotation
  hl-page:: 350
  hl-color:: green
  id:: 63cfc8cb-b693-41fa-b3e6-40e096c47f67
- 创建新期约时需要传入执行器（executor）函数作为参数
  ls-type:: annotation
  hl-page:: 350
  hl-color:: yellow
  id:: 63cfcbd9-11e9-4923-8431-983e38a8abd4
- 期约是一个有状态的对象，可能处于如下 3 种状态
  ls-type:: annotation
  hl-page:: 350
  hl-color:: yellow
  id:: 63cfcdeb-dc28-4def-b890-e5d62202810d
- 只要从待定转换为兑现或拒绝，期约的状态就不再改变
  ls-type:: annotation
  hl-page:: 351
  hl-color:: yellow
  id:: 63cfce35-30a8-4693-9b98-d6a2bfe08aac
- 这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象
  ls-type:: annotation
  hl-page:: 351
  hl-color:: yellow
  id:: 63cfce65-d6ad-48d2-867a-aba9b6e5a2fa
- 期约主要有两大用途。首先是抽象地表示一个异步操作。
  ls-type:: annotation
  hl-page:: 351
  hl-color:: yellow
  id:: 63cfcece-6ed7-40a4-a93a-7c94e10328f6
- 期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值
  ls-type:: annotation
  hl-page:: 351
  hl-color:: yellow
  id:: 63cfceeb-0ba8-4c37-9565-8103568b69ff
- 设期约向服务器发送一个 HTTP 请求并预定会返回一个 JSON
  ls-type:: annotation
  hl-page:: 351
  hl-color:: yellow
  id:: 63cfcef4-7f1c-4850-be36-0dbd3a13b976
- 个期约只要状态切换为兑现，就会有一个私有的内部值（value
  ls-type:: annotation
  hl-page:: 351
  hl-color:: yellow
  id:: 63cfcf14-28b7-455d-b82b-790363f1d2fe
- 每个期约只要状态切换为拒绝，就会有一个私有的内部理由（reason
  ls-type:: annotation
  hl-page:: 351
  hl-color:: yellow
  id:: 63cfcf1c-6c3a-4120-8738-e16dbde0bfdd
- 执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。
  ls-type:: annotation
  hl-page:: 351
  hl-color:: yellow
  id:: 63cfcf40-ad3c-43fd-9f3a-bed0087ac441
- 调用 resolve()会把状态切换为兑现
  ls-type:: annotation
  hl-page:: 351
  hl-color:: yellow
  id:: 63cfcf6a-5469-4bc4-9460-fbbde3eae129
- 调用 reject()会把状态切换为拒绝
  ls-type:: annotation
  hl-page:: 351
  hl-color:: yellow
  id:: 63cfcf70-6ac8-4909-b199-b4b8e8b3bfb0
- 这里的关键在于，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序
  ls-type:: annotation
  hl-page:: 352
  hl-color:: yellow
  id:: 63cfd052-0d28-442f-a4e5-f39b722e5402
- 比如，可以通过 setTimeout 设置一个10 秒钟后无论如何都会拒绝期约的回调：
  ls-type:: annotation
  hl-page:: 352
  hl-color:: yellow
  id:: 63cfd07c-026a-4687-bcc4-bfe9b383108d
- 这个解决的期约的值对应着传给 Promise.resolve()的第一个参数
  ls-type:: annotation
  hl-page:: 352
  hl-color:: yellow
  id:: 63cfd13c-ded7-4f9b-8b7c-235b2e8819fa
- Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误
  ls-type:: annotation
  hl-page:: 353
  hl-color:: yellow
  id:: 63cfd1a4-ef6b-4489-baef-236b97ba4878
- 过调用 Promise.resolve()静态方法，可以实例化一个解决的期约
  ls-type:: annotation
  hl-page:: 352
  hl-color:: yellow
  id:: 63cfd1b7-93f9-4b52-aea9-9e7f6d0d65d3
- 如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由：
  ls-type:: annotation
  hl-page:: 353
  hl-color:: yellow
  id:: 63cfd26e-901e-4276-9068-dcbd9b517e74
- 第一个 try/catch 抛出并捕获了错误，第二个 try/catch 抛出错误却没有捕获到
  ls-type:: annotation
  hl-page:: 354
  hl-color:: yellow
  id:: 63cfd295-b4e6-42a1-9375-8280aa26e73b
- 期约的实例方法
  ls-type:: annotation
  hl-page:: 354
  hl-color:: green
  id:: 63cfd531-34ef-479a-af99-f0b21d9bdad5
- 期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁
  ls-type:: annotation
  hl-page:: 354
  hl-color:: yellow
  id:: 63cfd592-3e44-4ddc-8b7d-bafea929e945
- 实现 Thenable 接口
  ls-type:: annotation
  hl-page:: 354
  hl-color:: green
  id:: 63cfd5aa-fcf3-4ff2-b448-54c584f0313e
  hl-stamp:: 1674566300908
- Promise.prototype.then()
  ls-type:: annotation
  hl-page:: 354
  hl-color:: green
  id:: 63cfd5b3-fd47-483f-babf-eb3e02fd3358
  hl-stamp:: 1674566303305
- 因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。
  ls-type:: annotation
  hl-page:: 355
  hl-color:: yellow
  id:: 63cfd5ed-1986-4076-a831-5df70ca32455
- 如果想只提供 onRejected 参数，那就要在 onResolved 参数的位置上传入 undefined。这样有助于避免在内存中创建多余的对象，对期待函数参数的类型系统也是一个交代。
  ls-type:: annotation
  hl-page:: 355
  hl-color:: yellow
  id:: 63cfd67c-c27f-4c0f-bd1b-7c1548c29d43
- 该处理程序的返回值会通过 Promise.resolve()包装来生成新期约
  ls-type:: annotation
  hl-page:: 355
  hl-color:: yellow
  id:: 63cfd6ca-53dc-411b-a5f3-dd8cccc94328
- 果没有提供这个处理程序，则 Promise.resolve()就会包装上一个期约解决之后的值。
  ls-type:: annotation
  hl-page:: 355
  hl-color:: yellow
  id:: 63cfd7a5-e8ef-4fcf-b947-442194016ff4
- 果没有显式的返回语句，则 Promise.resolve()会包装默认的返回值 undefined
  ls-type:: annotation
  hl-page:: 355
  hl-color:: yellow
  id:: 63cfd7ab-73e5-4920-b344-18378d5c8978
- Promise.resolve()保留返回的期约
  ls-type:: annotation
  hl-page:: 356
  hl-color:: yellow
  id:: 63cfd7e8-b156-43a9-bcf0-42af74d8cfbe
- 抛出异常会返回拒绝的期约：
  ls-type:: annotation
  hl-page:: 356
  hl-color:: yellow
  id:: 63cfd8a8-c384-40d9-975d-2ae6324424d4
- 返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：
  ls-type:: annotation
  hl-page:: 356
  hl-color:: yellow
  id:: 63cfd8af-f34f-4837-92e1-567091e950c2
- 拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约。
  ls-type:: annotation
  hl-page:: 356
  hl-color:: yellow
  id:: 63cfd8c1-747d-4bdf-93db-092a7e871a93
- Promise.prototype.catch()
  ls-type:: annotation
  hl-page:: 357
  hl-color:: green
  id:: 63cfdaa7-c538-4d42-b040-9236574def56
- 为期约实例添加处理程序的主要方法
  ls-type:: annotation
  hl-page:: 354
  hl-color:: yellow
  id:: 63cfdab8-1b1c-4558-9a50-7ee0a8169b6e
- 用于给期约添加拒绝处理程序
  ls-type:: annotation
  hl-page:: 357
  hl-color:: yellow
  id:: 63cfdac3-df32-467c-9042-7866064483fd
- 只接收一个参数： onRejected 处理程序
  ls-type:: annotation
  hl-page:: 357
  hl-color:: yellow
  id:: 63cfdaca-bdaa-4471-b528-4dd1c2fbe783
- 这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype. then(null, onRejected)
  ls-type:: annotation
  hl-page:: 357
  hl-color:: yellow
  id:: 63cfdad4-c3bc-463b-b96a-7d8be5cca330
- Promise.prototype.finally()
  ls-type:: annotation
  hl-page:: 358
  hl-color:: green
  id:: 63cfdb53-9356-421a-b06f-7f69b9edff62
  hl-stamp:: 1674566487338
- 用于给期约添加 onFinally 处理程序
  ls-type:: annotation
  hl-page:: 358
  hl-color:: yellow
  id:: 63cfdb5e-384b-4214-adc5-ccb433460614
- 这个处理程序在期约转换为解决或拒绝状态时都会执行
  ls-type:: annotation
  hl-page:: 358
  hl-color:: yellow
  id:: 63cfdb8a-f2e8-439d-9303-cbdac12bf81b
- 如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝），如下所示：
  ls-type:: annotation
  hl-page:: 358
  hl-color:: yellow
  id:: 63cfdbe6-0d4e-4b47-a7f2-62e729c119de
- 非重入期约方法
  ls-type:: annotation
  hl-page:: 359
  hl-color:: green
  id:: 63cfdc3e-fab8-445d-a6f1-aca824bd8bae
- 当期约进入落定状态时，与该状态相关的处理程序仅仅会被排期，而非立即执行。
  ls-type:: annotation
  hl-page:: 359
  hl-color:: yellow
  id:: 63cfdc49-1ed5-4a39-b9e2-56b25b2c047e
- 这个特性由 JavaScript 运行时保证，被称为“非重入”（non-reentrancy）
  ls-type:: annotation
  hl-page:: 359
  hl-color:: yellow
  id:: 63cfdccc-212f-4beb-819c-554136ca37c9
- 一个解决期约上调用 then()会把 onResolved 处理程序推进消息队列
  ls-type:: annotation
  hl-page:: 359
  hl-color:: yellow
  id:: 63cfddbd-c9b8-46f2-b300-80184e729954
- 非重入适用于 onResolved/onRejected 处理程序、catch()处理程序和 finally()处理程序
  ls-type:: annotation
  hl-page:: 360
  hl-color:: yellow
  id:: 63cfdde5-158b-4bab-8008-a7a6e4119150
- 邻近处理程序的执行顺序
  ls-type:: annotation
  hl-page:: 360
  hl-color:: green
  id:: 63cfdeff-fdc3-4dc5-8036-d9d8662385f2
- 如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执
  ls-type:: annotation
  hl-page:: 360
  hl-color:: yellow
  id:: 63cfdff0-d04f-4e9f-a887-41ba19f28b17
- 传递解决值和拒绝理由
  ls-type:: annotation
  hl-page:: 361
  hl-color:: green
  id:: 63cfdff7-2faf-4f39-a6cb-051a0cd089f8
- 在执行函数中，解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传的
  ls-type:: annotation
  hl-page:: 361
  hl-color:: yellow
  id:: 63cfe0a3-6f34-46e1-aa72-b3f6a3c48e86
- 拒绝期约与拒绝错误处理
  ls-type:: annotation
  hl-page:: 361
  hl-color:: green
  id:: 63cfe0db-290b-4ae6-9c24-697778c747ab
- 在期约的执行函数或处理程序中抛出错误会导致拒绝，对应的错误对象会成为拒绝的理由
  ls-type:: annotation
  hl-page:: 361
  hl-color:: yellow
  id:: 63cfe102-6951-4599-8dd1-e18233143da6
- 这样做主要是因为创建错误对象可以让浏览器捕获错误对象中的栈追踪信息，而这些信息对调试是非常关键的。例如，前面例子中抛出的 4 个错误的栈追踪信息如下：
  ls-type:: annotation
  hl-page:: 362
  hl-color:: yellow
  id:: 63cfe11c-f748-4c9f-a411-2ab546a8fd2d
- 也就是说，在最终抛出未捕获错误之前它还会创建另一个期约
  ls-type:: annotation
  hl-page:: 362
  hl-color:: yellow
  id:: 63cfe12c-bc6e-422d-968c-0426ee5760a7
- 所有错误都是异步抛出且未处理的，通过错误对象捕获的栈追踪信息展示了错误发生的路径
  ls-type:: annotation
  hl-page:: 362
  hl-color:: yellow
  id:: 63cfe167-c5ba-4ab9-a31c-6717a9c0f05f
- 如本章前面的 Promise.reject()示例所示，异步错误只能通过异步的 onRejected 处理程序捕获
  ls-type:: annotation
  hl-page:: 362
  hl-color:: yellow
  id:: 63cfe1b4-d116-457c-a082-cbdec8a9472b
- then()和 catch()的 onRejected 处理程序在语义上相当于 try/catch
  ls-type:: annotation
  hl-page:: 363
  hl-color:: yellow
  id:: 63cfe1fe-3cbd-4260-b25f-e07c9ebfae47
- 此，onRejected 处理程序的任务应该是在捕获异步错误之后返回一个解决的期约
  ls-type:: annotation
  hl-page:: 363
  hl-color:: yellow
  id:: 63cfe20b-135a-4ff7-bb15-8edf5867d3a2
- 期约连锁与期约合成
  ls-type:: annotation
  hl-page:: 363
  hl-color:: green
  id:: 63cfe2c9-2898-4277-9f2d-0e6a938b0bb4
- 个期约实例的方法（then()、catch()和 finally()）都会返回一个新的期约对象，而这个新期约又有自己的实例方
  ls-type:: annotation
  hl-page:: 363
  hl-color:: yellow
  id:: 63cfe2e3-3e4a-4bed-95ec-b5dd0019dfed
- 让每个执行器都返回一个期约实例。这样就可以让每个后续期约都等待之前的期约，也就是串行化异步任务
  ls-type:: annotation
  hl-page:: 364
  hl-color:: yellow
  id:: 63cfe38e-0af5-4b1c-bc1c-2a8842efe6a5
- 然后实例化一个新期约并返回它。这种结构可以简洁地将异步任务串行化，解决之前依赖回调的难题
  ls-type:: annotation
  hl-page:: 365
  hl-color:: yellow
  id:: 63cfe415-16b3-467c-8c57-3d98adb07b81
- 而使用实例方法添加的处理程序则是有向顶点
  ls-type:: annotation
  hl-page:: 365
  hl-color:: yellow
  id:: 63cfe480-c84c-4e6a-be50-83e7c1b3817a
- 期约的处理程序是按照它们添加的顺序执行的
  ls-type:: annotation
  hl-page:: 366
  hl-color:: yellow
  id:: 63cfe4c1-b679-4532-82eb-6591110954f0
- 由于期约的处理程序是先添加到消息队列，然后才逐个执行，因此构成了层序遍历
  ls-type:: annotation
  hl-page:: 366
  hl-color:: yellow
  id:: 63cfe4c8-274b-41d7-a240-d440eefcf2d2
- 所以有向非循环图是体现期约连锁可能性的最准确表达
  ls-type:: annotation
  hl-page:: 366
  hl-color:: yellow
  id:: 63cfe554-5ca8-4941-a910-19669841162e
- Promise.all()静态方法创建的期约会在一组期约全部解决之后再解决
  ls-type:: annotation
  hl-page:: 366
  hl-color:: yellow
  id:: 63cfe55b-06ce-4e81-8008-a6d2afd43753
- 可迭代对象中的元素会通过 Promise.resolve()转换为期约
  ls-type:: annotation
  hl-page:: 366
  hl-color:: yellow
  id:: 63cfe673-d8a7-47a2-b349-a0c934e3409e
- 空的可迭代对象等价于 Promise.resolve()
  ls-type:: annotation
  hl-page:: 366
  hl-color:: yellow
  id:: 63cfe67a-a9a8-4e49-8a71-579a4ac88225
- 如果有一个包含的期约拒绝，则合成的期约也会拒绝
  ls-type:: annotation
  hl-page:: 367
  hl-color:: yellow
  id:: 63cfe6b4-2088-4446-ba09-63e0e36d965d
- 如果所有期约都成功解决，则合成期约的解决值就是所有包含期约解决值的数组
  ls-type:: annotation
  hl-page:: 367
  hl-color:: yellow
  id:: 63cfe74a-3ef2-41f0-90a5-02b35f641d74
- 如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由
  ls-type:: annotation
  hl-page:: 367
  hl-color:: yellow
  id:: 63cfe760-8ebe-40e7-8b11-5ba331f85652
- Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像
  ls-type:: annotation
  hl-page:: 367
  hl-color:: yellow
  id:: 63cfe7c5-8831-42e7-a382-6b788959f6c7
- 可迭代对象中的元素会通过 Promise.resolve()转换为期约
  ls-type:: annotation
  hl-page:: 368
  hl-color:: yellow
  id:: 63cfe88a-8533-4bd5-881e-bf17166c6010
- 空的可迭代对象等价于 new Promise(() => {})
  ls-type:: annotation
  hl-page:: 368
  hl-color:: yellow
  id:: 63cfe8b4-f043-495d-b31f-4b9efdaa0807
- 无论是解决还是拒绝，只要是第一个落定的期约，Promise.race()就会包装其解决值或拒绝理由并返回新期约
  ls-type:: annotation
  hl-page:: 368
  hl-color:: yellow
  id:: 63cfe8c0-9fc2-4877-a09e-d3e544138956
- 解决先发生，超时后的拒绝被忽略
  ls-type:: annotation
  hl-page:: 368
  hl-color:: yellow
  id:: 63cfe90f-c3bc-4ea6-b1c4-5fefcc95c9a3
- 拒绝先发生，超时后的解决被忽略
  ls-type:: annotation
  hl-page:: 368
  hl-color:: yellow
  id:: 63cfe915-e81a-4f1d-90c4-472250f2d751
- 串行期约合成
  ls-type:: annotation
  hl-page:: 368
  hl-color:: green
  id:: 63cfe9b3-cada-4a22-8c82-1f79299fed93
- 可以把任意多个函数作为处理程序合成一个连续传值的期约连锁。
  ls-type:: annotation
  hl-page:: 369
  hl-color:: yellow
  id:: 63cfea32-35ea-459d-b43b-d8b0ce967307
- 期约扩展
  ls-type:: annotation
  hl-page:: 370
  hl-color:: green
  id:: 63cfea69-66d1-4fe6-8d6a-6ac08eead0d6
- 利用这个接口可以取消期约；同时也提供了一个期约的实例，可以用来触发取消后的操作并求值取消状态
  ls-type:: annotation
  hl-page:: 370
  hl-color:: yellow
  id:: 63cfeaf3-6961-4126-838a-72a804490b7e
- 这里期约是令牌类的公共成员，因此可以给它添加处理程序以取消期约
  ls-type:: annotation
  hl-page:: 370
  hl-color:: yellow
  id:: 63cfeb09-b862-4fdb-ba76-1d204dd0ae40
- 期约取消
  ls-type:: annotation
  hl-page:: 370
  hl-color:: yellow
  id:: 63cfebfe-c6bd-473b-b36a-8e7dc7594240
- 期约进度通知
  ls-type:: annotation
  hl-page:: 371
  hl-color:: yellow
  id:: 63cfec25-2c24-434b-87e6-3fe8ae74e649
- 一种实现方式是扩展 Promise 类，为它添加 notify()方法，
  ls-type:: annotation
  hl-page:: 371
  hl-color:: yellow
  id:: 63cfec45-4ef7-47d5-bc06-e2e380d03c77
- 异步函数
  ls-type:: annotation
  hl-page:: 372
  hl-color:: green
  id:: 63cfecc7-c665-4214-ab51-a4be4217018c
- 异步函数
  ls-type:: annotation
  hl-page:: 373
  hl-color:: green
  id:: 63cfed44-a561-4d71-accf-8a1c0fb84de0
- async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上
  ls-type:: annotation
  hl-page:: 373
  hl-color:: yellow
  id:: 63cfeda0-6690-4998-bb9b-0eb000615ec2
- 异步函数如果使用 return 关键字返回了值（如果没有 return 则会返回 undefined），这个值会被 Promise.resolve()包装成一个期约对象
  ls-type:: annotation
  hl-page:: 373
  hl-color:: yellow
  id:: 63cfeddb-f1f7-4629-b55d-8d9ecd8beb3f
- 直接返回一个期约对象也是一样的：
  ls-type:: annotation
  hl-page:: 374
  hl-color:: yellow
  id:: 63cfee20-4b72-43f9-9f59-f114557f0c09
- 与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约：
  ls-type:: annotation
  hl-page:: 375
  hl-color:: yellow
  id:: 63cfeebe-0054-4743-96cb-28454f06a6fa
- 拒绝期约的错误不会被异步函数捕获
  ls-type:: annotation
  hl-page:: 375
  hl-color:: yellow
  id:: 63cfeec4-005e-4e62-b4bb-b3cb5cf62a9f
- 使用 await关键字可以暂停异步函数代码的执行，等待期约解决
  ls-type:: annotation
  hl-page:: 375
  hl-color:: yellow
  id:: 63cfef2c-2a85-4c63-a058-814353472db3
- 这个行为与生成器函数中的 yield 关键字是一样的
  ls-type:: annotation
  hl-page:: 375
  hl-color:: yellow
  id:: 63cfefa1-22c9-49f5-9f65-004d7e0e486d
- 如果不是，则这个值就被当作已经解决的期约。
  ls-type:: annotation
  hl-page:: 376
  hl-color:: yellow
  id:: 63cfefe6-6299-4fb1-9e0d-ba965bf4cc62
- 单独的 Promise.reject()不会被异步函数捕获，而会抛出未捕获错误。
  ls-type:: annotation
  hl-page:: 377
  hl-color:: yellow
  id:: 63cff098-d7eb-4d3d-97b7-9053e5cbf072
- 此，await 关键字也只能直接出现在异步函数的定义中
  ls-type:: annotation
  hl-page:: 377
  hl-color:: yellow
  id:: 63cff0cf-822c-4622-8b69-456589bcfcc2
- 停止和恢复执行
  ls-type:: annotation
  hl-page:: 378
  hl-color:: green
  id:: 63cff0dc-4abd-4b82-8192-084e862944bd
- 异步函数如果不包含 await 关键字，其执行基本上跟普通函数没有什么区别
  ls-type:: annotation
  hl-page:: 378
  hl-color:: yellow
  id:: 63cff197-add3-409f-aadc-2a96f374ecc5
- 等到 await 右边的值可用了，JavaScript 运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。
  ls-type:: annotation
  hl-page:: 379
  hl-color:: yellow
  id:: 63cff1c9-5fb1-4093-a5cd-7aa5465f75bc
- ，即使 await 后面跟着一个立即可用的值，函数的其余部分也会被异步求值
  ls-type:: annotation
  hl-page:: 379
  hl-color:: yellow
  id:: 63cff2f3-d546-405a-a8ae-3cd47c3cccf2
- 异步函数策略
  ls-type:: annotation
  hl-page:: 381
  hl-color:: green
  id:: 63cff341-18db-48c5-bf91-df94981077bc
- 有了异步函数之后，就不一样了。一个简单的箭头函数就可以实现 sleep()：
  ls-type:: annotation
  hl-page:: 381
  hl-color:: yellow
  id:: 63cff353-e60c-4a49-8495-7c904ea0135d
- 实现 sleep()
  ls-type:: annotation
  hl-page:: 381
  hl-color:: yellow
  id:: 63cff368-f20f-4094-b413-3dfb600f2070
- 利用平行执行
  ls-type:: annotation
  hl-page:: 381
  hl-color:: yellow
  id:: 63cff3d8-68db-4ea1-ac1a-4bfa0f703a17
- 就算这些期约之间没有依赖，异步函数也会依次暂停，等待每个超时完成。这样可以保证执行顺序，但总执行时间会变
  ls-type:: annotation
  hl-page:: 382
  hl-color:: yellow
  id:: 63cff40c-2c94-402c-957f-c5e385f306ec
- 串行执行期约
  ls-type:: annotation
  hl-page:: 384
  hl-color:: yellow
  id:: 63cff42e-a020-4869-b7e0-604eeb266524
- 使用 async/await，期约连锁会变得很简单
  ls-type:: annotation
  hl-page:: 384
  hl-color:: yellow
  id:: 63cff4c8-5ca6-4e94-b6eb-82167debe6a6
- 栈追踪与内存管理
  ls-type:: annotation
  hl-page:: 384
  hl-color:: yellow
  id:: 63cff4db-8a08-46a0-9de9-51c4d1fb66bd
  hl-stamp:: 1674573021753
- 这样一改，栈追踪信息就准确地反映了当前的调用栈。fooPromiseExecutor()已经返回
  ls-type:: annotation
  hl-page:: 385
  hl-color:: yellow
  id:: 63cff57a-482f-4390-8537-352920afa822
- window 对象
  ls-type:: annotation
  hl-page:: 386
  hl-color:: green
  id:: 63cff5d6-bed2-40b5-8d78-39ac5bf03ae6
  hl-stamp:: 1674573272143
- 一个是 ECMAScript 中的 Global 对象
  ls-type:: annotation
  hl-page:: 386
  hl-color:: yellow
  id:: 63d0847f-1fde-443f-99fa-32496ee05e95
- 一个就是浏览器窗口的 JavaScript 接口
  ls-type:: annotation
  hl-page:: 386
  hl-color:: yellow
  id:: 63d0848a-3095-4c9b-85a0-2be7fb6174d3
- Global 作用域
  ls-type:: annotation
  hl-page:: 386
  hl-color:: green
  id:: 63d084a9-eafd-4c30-b4cc-681a6909c958
- 通过 var 声明的所有全局变量和函数都会变成 window 对象的属性和方法
  ls-type:: annotation
  hl-page:: 386
  hl-color:: yellow
  id:: 63d084cc-3765-4575-822b-df2c4e8c09ad
- 使用 let 或 const 替代 var，则不会把变量添加给全局对象
  ls-type:: annotation
  hl-page:: 387
  hl-color:: yellow
  id:: 63d084df-c80e-46f2-b969-fdc7ba48529f
- 窗口关系
  ls-type:: annotation
  hl-page:: 387
  hl-color:: green
  id:: 63d08506-f186-464d-a57c-c6c990663fde
- 窗口关系
  ls-type:: annotation
  hl-page:: 387
  hl-color:: green
  id:: 63d08509-7d5e-415d-a4fa-61e20f1408b6
- top 对象始终指向最上层（最外层）窗口，即浏览器窗口本身
  ls-type:: annotation
  hl-page:: 387
  hl-color:: yellow
  id:: 63d0851e-0b14-4bdf-9c18-11bd5b1ac391
- parent 对象则始终指向当前窗口的父窗口
  ls-type:: annotation
  hl-page:: 387
  hl-color:: yellow
  id:: 63d08524-c82b-47af-9fd6-486cc7b17e61
- self 对象，它是终极 window 属性，始终会指向 window
  ls-type:: annotation
  hl-page:: 387
  hl-color:: yellow
  id:: 63d08538-5dee-4ad3-bde3-d8dc542b4e10
- 窗口位置与像素比
  ls-type:: annotation
  hl-page:: 387
  hl-color:: green
  id:: 63d08541-84ec-4e9b-a9d8-d51ea3dfa9c9
- CSS 像素是 Web 开发中使用的统一像素单位
  ls-type:: annotation
  hl-page:: 388
  hl-color:: yellow
  id:: 63d0854b-a040-4746-a4c4-709e5098301c
- window 对象的位置可以通过不同的属性和方法来确定
  ls-type:: annotation
  hl-page:: 387
  hl-color:: yellow
  id:: 63d0855f-b64a-4712-b0f0-46aff2e6e2dc
- 可以使用 moveTo()和 moveBy()方法移动窗口
  ls-type:: annotation
  hl-page:: 387
  hl-color:: yellow
  id:: 63d0857c-43f4-4029-8420-664aa1ef10c2
- screenLeft 和 screenTop 属性，用于表示窗口相对于屏幕左侧和顶部的位置 ，返回值的单位是 CSS 像素
  ls-type:: annotation
  hl-page:: 387
  hl-color:: yellow
  id:: 63d08585-f16b-40b7-83d9-23c9ed2578bd
- 个角度：0.0213°
  ls-type:: annotation
  hl-page:: 388
  hl-color:: yellow
  id:: 63d0858d-f35f-4a46-ab39-8bd20f691a8d
- 这个物理像素与 CSS 像素之间的转换比率由 window.devicePixelRatio 属性提供
  ls-type:: annotation
  hl-page:: 388
  hl-color:: yellow
  id:: 63d085bf-4a93-4b87-b3bb-fda00a73dfbc
- DPI 表示单位像素密度，而 window.devicePixelRatio 表示物理像素与逻辑像素之间的缩放系数。
  ls-type:: annotation
  hl-page:: 388
  hl-color:: yellow
  id:: 63d085d0-dbb7-4afa-860d-1ab934e21f9d
- 窗口大小
  ls-type:: annotation
  hl-page:: 388
  hl-color:: green
  id:: 63d085d7-57f2-4e84-886a-9796bbe428db
- outerWidth 和 outerHeight 返回浏览器窗口自身的大小
  ls-type:: annotation
  hl-page:: 388
  hl-color:: yellow
  id:: 63d08606-c677-46fc-9233-84b37a34c7f8
- innerWidth和 innerHeight 返回浏览器窗口中页面视口的大小
  ls-type:: annotation
  hl-page:: 388
  hl-color:: yellow
  id:: 63d0860e-d9b7-41f2-856f-08fd210fc616
- document.documentElement.clientWidth 和 document.documentElement.clientHeight返回页面视口的宽度和高度
  ls-type:: annotation
  hl-page:: 388
  hl-color:: yellow
  id:: 63d08628-65ca-4e3a-8443-712596461a62
- 在移动设备上，window.innerWidth 和 window.innerHeight 返回视口的大小，也就是屏幕上页面可视区域的大小
  ls-type:: annotation
  hl-page:: 389
  hl-color:: yellow
  id:: 63d0867a-237c-4df3-a53a-cc40a76a8621
- 如果不是则通过 document.compatMode来检查页面是否处于标准模式
  ls-type:: annotation
  hl-page:: 388
  hl-color:: yellow
  id:: 63d086c7-4e15-4b6f-b31f-7c719230bdd6
- 可以使用 resizeTo()和 resizeBy()方法调整窗口大小
  ls-type:: annotation
  hl-page:: 389
  hl-color:: yellow
  id:: 63d08722-9140-48a2-8f42-eb8451ef996a
- 视口位置
  ls-type:: annotation
  hl-page:: 389
  hl-color:: green
  id:: 63d0872d-b11e-48dc-92f5-cea8fcafb021
- 度量文档相对于视口滚动距离的属性有两对，返回相等的值：window.pageXoffset/window. scrollX 和 window.pageYoffset/window.scrollY。
  ls-type:: annotation
  hl-page:: 389
  hl-color:: yellow
  id:: 63d08745-c7ed-4e8f-b6c2-12e6c0fdc8c7
- 可以使用 scroll()、scrollTo()和 scrollBy()方法滚动页面。
  ls-type:: annotation
  hl-page:: 389
  hl-color:: yellow
  id:: 63d0874b-5372-4690-a349-a3a1dfa45b4b
- 可以通过 behavior 属性告诉浏览器是否平滑滚动
  ls-type:: annotation
  hl-page:: 390
  hl-color:: yellow
  id:: 63d08781-b8be-4d0b-9200-9121c7149047
- 导航与打开新窗口
  ls-type:: annotation
  hl-page:: 390
  hl-color:: green
  id:: 63d08794-9a98-4a92-a158-415d27db1421
- window.open()方法可以用于导航到指定 URL，也可以用于打开新浏览器窗口
  ls-type:: annotation
  hl-page:: 390
  hl-color:: yellow
  id:: 63d0879e-7023-4405-bf42-50c67e80add8
- 如果 window.open()的第二个参数不是已有窗口，则会打开一个新窗口或标签页
  ls-type:: annotation
  hl-page:: 390
  hl-color:: yellow
  id:: 63d08841-6284-4807-a044-9dda98e0acc0
- 特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特
  ls-type:: annotation
  hl-page:: 390
  hl-color:: yellow
  id:: 63d0884b-cea9-4260-a357-e3ca42c8f03f
- 这些设置需要以逗号分隔的名值对形式出现，其中名值对以等号连接
  ls-type:: annotation
  hl-page:: 391
  hl-color:: yellow
  id:: 63d08862-f467-4e2f-9afb-4c76f0f0f20c
- 跟使用任何 window 对象一样，可以使用这个对象操纵新打开的窗口
  ls-type:: annotation
  hl-page:: 391
  hl-color:: yellow
  id:: 63d0887c-1819-4683-b408-e586f59c48a4
- 弹出窗口可以调用 top.close()来关闭自己。关闭窗口以后，窗口的引用虽然还在，但只能用于检查其 closed 属性
  ls-type:: annotation
  hl-page:: 391
  hl-color:: yellow
  id:: 63d08884-18b4-494d-b785-cae6af412c28
- 新创建窗口的 window 对象有一个属性 opener，指向打开它的窗口
  ls-type:: annotation
  hl-page:: 391
  hl-color:: yellow
  id:: 63d0889d-4973-433f-9665-b3576aaba8b1
- 。如果一个标签页打开了另一个，而 window对象需要跟另一个标签页通信，那么标签便不能运行在独立的进程中
  ls-type:: annotation
  hl-page:: 392
  hl-color:: yellow
  id:: 63d088b3-71e9-4bd6-9d0b-9035c6358c13
- 把 opener 设置为 null 表示新打开的标签页不需要与打开它的标签页通信，因此可以在独立进程中运行。
  ls-type:: annotation
  hl-page:: 392
  hl-color:: yellow
  id:: 63d088c1-8809-48ca-a822-6aa45176eed8
- 所有现代浏览器都内置了屏蔽弹窗的程序，因此大多数意料之外的弹窗都会被屏蔽
  ls-type:: annotation
  hl-page:: 392
  hl-color:: yellow
  id:: 63d088f8-dd64-4af5-903e-493d31744f12
- 如果浏览器内置的弹窗屏蔽程序阻止了弹窗，那么 window.open()很可能会返回 null
  ls-type:: annotation
  hl-page:: 392
  hl-color:: yellow
  id:: 63d08900-2097-486a-949e-a7a827717a84
- 在浏览器扩展或其他程序屏蔽弹窗时，window.open()通常会抛出错误
  ls-type:: annotation
  hl-page:: 392
  hl-color:: yellow
  id:: 63d0890d-c088-4178-84c7-94ac0c8ccdcb
- 定时器
  ls-type:: annotation
  hl-page:: 393
  hl-color:: green
  id:: 63d08924-f8b7-4007-bcb5-fce364a4189d
- setTimeout()用于指定在一定时间后执行某些代码
  ls-type:: annotation
  hl-page:: 393
  hl-color:: yellow
  id:: 63d08933-70ee-451c-ae7d-366ceea9e52b
- setInterval()用于指定每隔一段时间执行某些代码
  ls-type:: annotation
  hl-page:: 393
  hl-color:: yellow
  id:: 63d08948-339c-4fbd-8aa1-d58c785efccf
- setTimeout()的第二个参数只是告诉 JavaScript 引擎在指定的毫秒数过后把任务添加到这个队列。
  ls-type:: annotation
  hl-page:: 393
  hl-color:: yellow
  id:: 63d08968-5f85-4219-8558-64e7ca637acd
- 要取消等待中的排期任务，可以调用 clearTimeout()方法并传入超时 ID
  ls-type:: annotation
  hl-page:: 393
  hl-color:: yellow
  id:: 63d089a3-95d6-454c-be83-d8223bd3e69b
- setInterval()方法也会返回一个循环定时 ID，可以用于在未来某个时间点上取消循环定时
  ls-type:: annotation
  hl-page:: 394
  hl-color:: yellow
  id:: 63d089ee-fd4b-4db7-8a36-413ac67807a8
- 系统对话框
  ls-type:: annotation
  hl-page:: 395
  hl-color:: green
  id:: 63d08a52-8c8b-4b25-8df6-91084f56a973
- alert()方法在本书示例中经常用到。它接收一个要显示给用户的字符串
  ls-type:: annotation
  hl-page:: 395
  hl-color:: yellow
  id:: 63d08a82-a58a-4f57-aabf-3fc7122e6772
- 第二种对话框叫确认框，通过调用 confirm()来显示
  ls-type:: annotation
  hl-page:: 395
  hl-color:: yellow
  id:: 63d08a96-74ca-46c7-bf1c-3c2afc474c43
- 要知道用户单击了 OK 按钮还是 Cancel 按钮，可以判断 confirm()方法的返回值
  ls-type:: annotation
  hl-page:: 395
  hl-color:: yellow
  id:: 63d08aae-6fc1-43ea-938d-562bbfb1f2e6
- 最后一种对话框是提示框，通过调用 prompt()方法来显示。提示框的用途是提示用户输入消息
  ls-type:: annotation
  hl-page:: 396
  hl-color:: yellow
  id:: 63d08aba-99a5-40ec-85d2-cd118a24b419
- 用户在浏览器菜单上选择“查找”（find）和“打印”（print）时显示的就是这两种对话框。通过在 window 对象上调用 find()和 print()可以显示它
  ls-type:: annotation
  hl-page:: 396
  hl-color:: yellow
  id:: 63d08b03-0d68-4137-8a9c-33bc866ee436
- location 对象
  ls-type:: annotation
  hl-page:: 397
  hl-color:: green
  id:: 63d08b0b-f58b-44f5-9b92-ac4fc407f15f
- location 对象不仅保存着当前加载文档的信息，也保存着把 URL 解析为离散片段后能够通过属性访问的信息
  ls-type:: annotation
  hl-page:: 397
  hl-color:: yellow
  id:: 63d08b82-ded9-4f11-9d4b-abcf1dcb8dba
- 查询字符串
  ls-type:: annotation
  hl-page:: 397
  hl-color:: green
  id:: 63d08b94-abe1-41cc-956b-94687c3ab2eb
- location.search 返回了从问号开始直到 URL 末尾的所有内容
  ls-type:: annotation
  hl-page:: 397
  hl-color:: yellow
  id:: 63d08bad-a8d4-4ba7-9fe4-e06f0ee69fc1
- 接着，先把查询字符串按照&分割成数组，每个元素的形式为 name=value。
  ls-type:: annotation
  hl-page:: 398
  hl-color:: yellow
  id:: 63d08bc2-6e1f-405d-a513-89aba0f76c8d
- URLSearchParams
  ls-type:: annotation
  hl-page:: 398
  hl-color:: yellow
  id:: 63d08bf1-955e-45d4-a81e-847cb3482d36
- 这个实例上暴露了 get()、 set()和 delete()等方法，可以对查询字符串执行相应操作
  ls-type:: annotation
  hl-page:: 398
  hl-color:: yellow
  id:: 63d08bf5-10c3-4dcb-897d-624bee7af7a0
- URLSearchParams 提 供 了 一 组 标 准 API 方 法 ， 通 过 它 们 可 以 检 查 和 修 改 查 询 字 符 串 。 给
  ls-type:: annotation
  hl-page:: 398
  hl-color:: yellow
  id:: 63d08c17-49b2-404e-bbc3-588cc7c07920
- 操作地址
  ls-type:: annotation
  hl-page:: 398
  hl-color:: green
  id:: 63d08c21-8afb-42b0-bfc3-51ae77c187ca
- 使用 assign()方法并传入一个 URL，
  ls-type:: annotation
  hl-page:: 398
  hl-color:: yellow
  id:: 63d08c3d-03a6-484f-a7d4-9a65ecfe82e7
- 这行代码会立即启动导航到新 URL 的操作，同时在浏览器历史记录中增加一条记录
  ls-type:: annotation
  hl-page:: 399
  hl-color:: yellow
  id:: 63d08c4b-3671-4873-93fb-9ec994f1c909
- 果给 location.href 或 window.location 设置一个 URL，也会以同一个 URL 值调用 assign()方法
  ls-type:: annotation
  hl-page:: 399
  hl-color:: yellow
  id:: 63d08c5d-2883-4929-a7ae-14bba9730eb8
- 如果不希望增加历史记录，可以使用 replace()方法。这个方法接收一个 URL 参数，但重新加载后不会增加历史记录
  ls-type:: annotation
  hl-page:: 399
  hl-color:: yellow
  id:: 63d08cac-e2e5-411d-b64f-c71ce8285ba4
- 。调用 replace()之后，用户不能回到前一页
  ls-type:: annotation
  hl-page:: 399
  hl-color:: yellow
  id:: 63d08cb2-d717-47de-b39c-79f515668679
- reload()，它能重新加载当前显示的页面
  ls-type:: annotation
  hl-page:: 400
  hl-color:: yellow
  id:: 63d08cc4-c839-44e8-8d48-2e5712b703b5
- 如果想强制从服务器重新加载，可以像下面这样给 reload()传个 true
  ls-type:: annotation
  hl-page:: 400
  hl-color:: yellow
  id:: 63d08ccd-33de-4a6c-9240-66e94e13f645
- navigator 对象
  ls-type:: annotation
  hl-page:: 400
  hl-color:: green
  id:: 63d08cd7-78f1-4381-9dd0-8322f43fa38b
- 只要浏览器启用 JavaScript，navigator 对象就一定存在
  ls-type:: annotation
  hl-page:: 400
  hl-color:: yellow
  id:: 63d08cec-3ac6-44fa-8f04-d70086b3f444
- 检测插件
  ls-type:: annotation
  hl-page:: 401
  hl-color:: green
  id:: 63d08d3f-35ac-4eb3-a104-2082cdd164a7
- 在这些 IE中检测插件要使用专有的 ActiveXObject，并尝试实例化特定的插
  ls-type:: annotation
  hl-page:: 402
  hl-color:: yellow
  id:: 63d08ec6-96a9-491b-b8aa-1c81f02e1939
- 除 IE10 及更低版本外的浏览器，都可以通过 plugins 数组来确定。这个数组中的每一项都包含如下属性
  ls-type:: annotation
  hl-page:: 401
  hl-color:: yellow
  id:: 63d08ed8-ef26-44b7-a034-08290e74d0ab
- 因为检测插件涉及两种方式，所以一般要针对特定插件写一个函数，而不是使用通常的检测函数
  ls-type:: annotation
  hl-page:: 403
  hl-color:: yellow
  id:: 63d08f24-fdf3-4f91-a87c-efad9eba0576
- 注册处理程序
  ls-type:: annotation
  hl-page:: 403
  hl-color:: green
  id:: 63d08f2b-6f9e-4ea7-9c5e-0b052e8c03d9
- registerProtocolHandler()方法。这个方法可以把一个网站注册为处理某种特定类型信息应用程
  ls-type:: annotation
  hl-page:: 403
  hl-color:: yellow
  id:: 63d08f46-34b0-4f89-94dc-bd852e4a52cd
- screen 对象
  ls-type:: annotation
  hl-page:: 404
  hl-color:: green
  id:: 63d08f55-a620-4c93-bfe1-f61cfa8726c7
- 。这个对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息
  ls-type:: annotation
  hl-page:: 404
  hl-color:: yellow
  id:: 63d08f65-c3d3-4ad2-a3a2-bec84a3fdb61
- history 对象
  ls-type:: annotation
  hl-page:: 404
  hl-color:: green
  id:: 63d08fa2-7b9e-4372-b943-0be9c16a7a38
- history 对象表示当前窗口首次使用以来用户的导航历史记录。因为 history 是 window 的属性
  ls-type:: annotation
  hl-page:: 404
  hl-color:: yellow
  id:: 63d08fb3-7908-495b-b50b-ecfc5b02c9c7
- 导航
  ls-type:: annotation
  hl-page:: 404
  hl-color:: green
  id:: 63d08fda-d39a-497d-b8f5-80bb455edf91
- go()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。
  ls-type:: annotation
  hl-page:: 404
  hl-color:: yellow
  id:: 63d08ff2-3b7a-414b-8ebe-80a26ba060d2
- go()有两个简写方法：back()和 forward()
  ls-type:: annotation
  hl-page:: 405
  hl-color:: yellow
  id:: 63d09001-5d7f-4cef-8634-d58eccbc3ab7
- ，go()方法的参数也可以是一个字符串，这种情况下浏览器会导航到历史中包含该字符串的第一个位置
  ls-type:: annotation
  hl-page:: 405
  hl-color:: yellow
  id:: 63d09007-a3d1-48b1-ba75-ebd08d4177fa
- history 对象还有一个 length 属性，表示历史记录中有多个条目
  ls-type:: annotation
  hl-page:: 405
  hl-color:: yellow
  id:: 63d09024-06fb-46bf-aa5d-2097b5529197
- 历史状态管理
  ls-type:: annotation
  hl-page:: 405
  hl-color:: green
  id:: 63d09048-427b-41b9-bb86-cef1cebfcbf7
- pushState()会创建新的历史记录
  ls-type:: annotation
  hl-page:: 406
  hl-color:: yellow
  id:: 63d0908a-aff6-451f-a2bd-87171c91f92e
- 可 以 通 过 history.state 获 取 当 前 的 状 态 对 象 ，
  ls-type:: annotation
  hl-page:: 406
  hl-color:: yellow
  id:: 63d090d5-5422-4b96-8a57-88c4a4babf5b
- 用 replaceState() 并 传 入 与 pushState()同样的前两个参数来更新状态
  ls-type:: annotation
  hl-page:: 406
  hl-color:: yellow
  id:: 63d090e4-cdf0-4911-87f4-e317c650bcce
- hashchange 会在页面 URL 的散列变化时被触发
  ls-type:: annotation
  hl-page:: 405
  hl-color:: yellow
  id:: 63d09130-59eb-45b2-b357-3a667f947a59
- ：一个 state 对象、一个新状态的标题和一个（可选的）相对 URL。
  ls-type:: annotation
  hl-page:: 405
  hl-color:: yellow
  id:: 63d09182-bf4f-4525-a6d1-4f7b6e99dab8
- 能力检测
  ls-type:: annotation
  hl-page:: 407
  hl-color:: green
  id:: 63d091be-fb58-4864-b4df-b3f6dadf0e47
- 这种方式不要求事先知道特定浏览器的信息，只需检测自己关心的能力是否存在即可
  ls-type:: annotation
  hl-page:: 407
  hl-color:: yellow
  id:: 63d0920f-8aea-494d-98e8-aff92da3b82e
- 安全能力检测
  ls-type:: annotation
  hl-page:: 408
  hl-color:: green
  id:: 63d09262-ca51-4bad-a77b-647a3206b3b1
  hl-stamp:: 1674613347732
- 这个函数尝试通过检测对象上是否有 sort()方法来确定它是否支持排序。问题在于，即使这个对象有一个 sort 属性，这个函数也会返回 true：
  ls-type:: annotation
  hl-page:: 408
  hl-color:: yellow
  id:: 63d09297-5ec0-4dd8-bef5-fe5a4c4a06ca
- 更好的方式是检测 sort 是不是函数：
  ls-type:: annotation
  hl-page:: 408
  hl-color:: yellow
  id:: 63d0929a-34b0-47b1-9cb9-187e0abb97d8
- 进行能力检测时应该尽量使用 typeof 操作符
  ls-type:: annotation
  hl-page:: 408
  hl-color:: yellow
  id:: 63d092b8-425a-4a25-aa94-79747f174e53
- 基于能力检测进行浏览器分析
  ls-type:: annotation
  hl-page:: 409
  hl-color:: green
  id:: 63d092d5-cd9a-48c8-9af3-d3bfe4ccc848
- 使用能力检测而非用户代理检测的优点在于，伪造用户代理字符串很简单，而伪造能够欺骗能力检测的浏览器特性却很难。
  ls-type:: annotation
  hl-page:: 409
  hl-color:: yellow
  id:: 63d09351-0623-4bbd-b105-13c6b57bf146
- 检测特性
  ls-type:: annotation
  hl-page:: 409
  hl-color:: yellow
  id:: 63d09361-bd0b-40b8-8462-034ca9f56583
- 检测浏览器
  ls-type:: annotation
  hl-page:: 409
  hl-color:: yellow
  id:: 63d09389-868d-4959-9da4-2d7645ce10e6
- 能力检测的局限
  ls-type:: annotation
  hl-page:: 410
  hl-color:: yellow
  id:: 63d093a6-b187-4323-a1c5-314541261e96
- 能力检测最适合用于决定下一步该怎么做，而不一定能够作为辨识浏览器的标
  ls-type:: annotation
  hl-page:: 411
  hl-color:: yellow
  id:: 63d093bc-2d25-4830-95d7-aa57fb17e845
- 用户代理检测
  ls-type:: annotation
  hl-page:: 411
  hl-color:: green
  id:: 63d0940d-f35e-4cc5-a3cc-3e95233bdd9e
- 用户代理字符串包含在每个 HTTP 请求的头部，在 JavaScript 中可以通过 navigator.userAgent 访问
  ls-type:: annotation
  hl-page:: 411
  hl-color:: yellow
  id:: 63d0941e-5a60-43c6-93ce-e6f593447060
- 在网景公司准备开发浏览器时，代号确定为“Mozilla”（Mosaic Killer 的简写）。第一个公开发行版 Netscape Navigator 2 的用户代理字符串是这样的：
  ls-type:: annotation
  hl-page:: 411
  hl-color:: red
  id:: 63d0943d-2bfc-4725-8783-85e4625add7c
- 要更好地理解 Gecko 的用户代理字符串，最好是看几个不同的基于 Gecko 的浏览器返回的字符串
  ls-type:: annotation
  hl-page:: 414
  hl-color:: yellow
  id:: 63d0948e-d945-4e4f-8442-0f31c57df63f
- 怎样才能保证浏览器不被排除在流行的站点之外。答案就是在用户代理字符串中添加足够多的信息，让网站知道这个浏览器与其他浏览器是兼容的
  ls-type:: annotation
  hl-page:: 414
  hl-color:: yellow
  id:: 63d094a3-8e9a-4080-982d-447bdd464e8a
- Konqueror 是与 KDE Linux 桌面环境打包发布的浏览器，基于开源渲染引擎 KHTM
  ls-type:: annotation
  hl-page:: 415
  hl-color:: yellow
  id:: 63d094cb-c816-403b-b410-43661d7cb9c2
- 从 Opera 9 开始，Opera 也采用了两个策略改变自己的字符串。一是把自己标识为别的浏览器
  ls-type:: annotation
  hl-page:: 416
  hl-color:: yellow
  id:: 63d094fa-6cd8-49b9-90bb-e3a09de14639
- 另一个策略是伪装成 Firefox 或 IE。这种情况下的用户代理字符串与 Firefox 和 IE 返回的一样，末尾也没有"Opera"及其版本信息。这样就根本没办法区分 Opera 与其他浏览器了
  ls-type:: annotation
  hl-page:: 416
  hl-color:: yellow
  id:: 63d09501-dd7a-4d3e-bbb6-3d2ca6c559f5
- 注意在 iOS 3 以前，操作系统的版本号不会出现在用户代理字符串中。
  ls-type:: annotation
  hl-page:: 417
  hl-color:: yellow
  id:: 63d09520-2ddb-411e-99ea-23b4fbb6afc8
- 浏览器分析
  ls-type:: annotation
  hl-page:: 417
  hl-color:: green
  id:: 63d0952f-b059-4fe2-80e3-55d4485d5e4c
- 伪造用户代理
  ls-type:: annotation
  hl-page:: 417
  hl-color:: yellow
  id:: 63d0954a-b858-462e-981d-3a6e47b6da97
  hl-stamp:: 1674614095300
- 有些浏览器提供伪私有的__defineGetter__方法，利用它可以篡改用户代理字符串
  ls-type:: annotation
  hl-page:: 418
  hl-color:: yellow
  id:: 63d0955e-3490-4878-80a6-0e91db94d5f9
- 软件与硬件检测
  ls-type:: annotation
  hl-page:: 419
  hl-color:: green
  id:: 63d09576-da0c-4626-9e25-29ae6d27bebe
- 可以通过暴露在 window.navigator 上的一组 API 获得。
  ls-type:: annotation
  hl-page:: 419
  hl-color:: yellow
  id:: 63d09589-5cc5-42c6-9863-9e017a97c601
- 建议在使用这些 API 之前先检测它们是否存在
  ls-type:: annotation
  hl-page:: 419
  hl-color:: yellow
  id:: 63d09599-cf89-417e-96b9-da522c007b5d
- 识别浏览器与操作系统
  ls-type:: annotation
  hl-page:: 419
  hl-color:: green
  id:: 63d0959f-c5a5-45ca-9609-e11b9623a2f5
- navigator.oscpu 属性是一个字符串，通常对应用户代理字符串中操作系统/系统架构相关信息。
  ls-type:: annotation
  hl-page:: 419
  hl-color:: yellow
  id:: 63d095c7-46ea-42a8-aaf2-47e7cbd25599
- navigator.vendor 属性是一个字符串，通常包含浏览器开发商信息
  ls-type:: annotation
  hl-page:: 419
  hl-color:: yellow
  id:: 63d095d1-39db-4a77-ab33-5f644fc70a4c
- navigator.platform 属性是一个字符串，通常表示浏览器所在的操作系统
  ls-type:: annotation
  hl-page:: 419
  hl-color:: yellow
  id:: 63d095fc-f9aa-49fd-af51-a6ae38591474
- screen.colorDepth 和 screen.pixelDepth 返回一样的值，即显示器每像素颜色的位深
  ls-type:: annotation
  hl-page:: 420
  hl-color:: yellow
  id:: 63d09606-4fe1-4820-8ad7-5b3aea8ca5ff
- screen.orientation 属性返回一个 ScreenOrientation 对象，其中包含 Screen Orientation API定义的屏幕信息
  ls-type:: annotation
  hl-page:: 420
  hl-color:: yellow
  id:: 63d09611-c823-43f7-90ab-f5372e1c8899
- 浏览器元数据
  ls-type:: annotation
  hl-page:: 420
  hl-color:: green
  id:: 63d0962a-07ca-4b05-a2ad-a8d7b5edead7
- navigator.geolocation 属性暴露了 Geolocation API，可以让浏览器脚本感知当前设备的地理位置。这
  ls-type:: annotation
  hl-page:: 420
  hl-color:: yellow
  id:: 63d09636-9432-4f42-8c81-240213e1fdae
- navigator 对象暴露出一些 API，可以提供浏览器和操作系统的状态信息
  ls-type:: annotation
  hl-page:: 420
  hl-color:: yellow
  id:: 63d0963f-2f18-4b4d-97a7-bb052d7bbab9
- Coordinates 对象包含一个 speed 属性，表示设备每秒移动的速度。还有一个 heading（朝向）属性，表示相对于正北方向移动的角度（0 ≤ heading < 360）
  ls-type:: annotation
  hl-page:: 421
  hl-color:: yellow
  id:: 63d09660-9216-4a37-85d6-cffff8d46cea
- getCurrentPosition() 方 法 。 这 个 方 法 返 回 一 个 Coordinates 对象
  ls-type:: annotation
  hl-page:: 421
  hl-color:: yellow
  id:: 63d0968e-55db-4f0c-8243-45ae984e3c67
- 获取浏览器地理位置并不能保证成功。因此 getCurrentPosition()方法也接收失败回调函数作为第二个参数
  ls-type:: annotation
  hl-page:: 421
  hl-color:: yellow
  id:: 63d0969f-58de-4362-9d3e-e4b7ff7c5d49
- Geolocation API 位置请求可以使用 PositionOptions 对象来配置，作为第三个参数提供
  ls-type:: annotation
  hl-page:: 422
  hl-color:: yellow
  id:: 63d096e5-1c1a-4730-9dde-d77f8d4b77bb
- getCurrentPosition()会以 position 对象为参数调用传入的回调函数
  ls-type:: annotation
  hl-page:: 421
  hl-color:: yellow
  id:: 63d0970e-90bd-4a9f-b9d1-83fdea301647
- 任何时候，都可以通过 navigator. onLine 属性来确定浏览器的联网状态
  ls-type:: annotation
  hl-page:: 423
  hl-color:: yellow
  id:: 63d09730-fb68-45c3-8a8d-7325bcab6873
- navigator 对象还暴露了 NetworkInformation API，可以通过 navigator.connection 属性使用。
  ls-type:: annotation
  hl-page:: 423
  hl-color:: yellow
  id:: 63d0974f-ab2a-4a0e-a96b-0ffb4ec54fcd
- 浏览器可以访问设备电池及充电状态的信息。navigator.getBattery()方法会返回一个期约实例，解决为一个 BatteryManager 对象。
  ls-type:: annotation
  hl-page:: 424
  hl-color:: yellow
  id:: 63d09784-07f5-48da-802b-051e838ff040
- 这个 API 还提供了 4 个事件属性，可用于设置在相应的电池事件发生时调用的回调函数。
  ls-type:: annotation
  hl-page:: 424
  hl-color:: yellow
  id:: 63d097c0-86f6-498f-aadb-39de7c8985de
- 硬件
  ls-type:: annotation
  hl-page:: 425
  hl-color:: yellow
  id:: 63d0981b-f28e-4768-9725-ce80d53397d1
- navigator.hardwareConcurrency 属性返回浏览器支持的逻辑处理器核心数量，包含表示核心数的一个整数值（
  ls-type:: annotation
  hl-page:: 425
  hl-color:: yellow
  id:: 63d09823-c44f-4d4f-a6d7-f572ac2f60ea
- navigator.deviceMemory 属性返回设备大致的系统内存大小，包含单位为 GB 的浮点数
  ls-type:: annotation
  hl-page:: 425
  hl-color:: yellow
  id:: 63d09830-4048-4b4d-a76a-2e16ad24c14a
- navigator.maxTouchPoints 属性返回触摸屏支持的最大关联触点数量，包含一个整数
  ls-type:: annotation
  hl-page:: 425
  hl-color:: yellow
  id:: 63d09836-5c61-4a3e-8628-b26a0011052a
- DOM 表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部
  ls-type:: annotation
  hl-page:: 426
  hl-color:: yellow
  id:: 63d09856-0e2f-4908-82dc-d965d85888aa
- 节点层级
  ls-type:: annotation
  hl-page:: 426
  hl-color:: green
  id:: 63d0987f-5248-4bce-9f86-21d2f88b0ff4
- 在这里，根节点的唯一子节点是<html>元素，我们称之为文档元素（documentElement
  ls-type:: annotation
  hl-page:: 427
  hl-color:: yellow
  id:: 63d0989b-c595-4607-8635-bbf4c33363d0
- DOM 中总共有 12 种节点类型，这些类型都继承一种基本类型。
  ls-type:: annotation
  hl-page:: 427
  hl-color:: yellow
  id:: 63d098c3-1f06-490b-a5f9-a4327564c8c4
- Node 类型
  ls-type:: annotation
  hl-page:: 427
  hl-color:: green
  id:: 63d098ce-85e9-49cd-b9ce-16534ae89bc7
- Node 的接口，这个接口是所有 DOM 节点类型都必须实现的
  ls-type:: annotation
  hl-page:: 427
  hl-color:: yellow
  id:: 63d098d6-b347-4b21-b048-675daecc4ffc
- 每个节点都有 nodeType 属性，表示该节点的类型
  ls-type:: annotation
  hl-page:: 427
  hl-color:: yellow
  id:: 63d098df-f0a0-4cb9-a341-b0ee33686fc2
- 如果两者相等，则意味着 someNode 是一个元素节点。
  ls-type:: annotation
  hl-page:: 428
  hl-color:: yellow
  id:: 63d09c71-909e-4ad0-bdc2-db027edcfbc4
- 在使用这两个属性前，最好先检测节点类型，如下所
  ls-type:: annotation
  hl-page:: 428
  hl-color:: yellow
  id:: 63d09d22-875b-4c14-9aab-42d5f6a383bd
- 文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱
  ls-type:: annotation
  hl-page:: 428
  hl-color:: yellow
  id:: 63d09d52-93ac-4202-aae6-0b2f39e57603
- 每个节点都有一个 childNodes 属性，其中包含一个 NodeList 的实例
  ls-type:: annotation
  hl-page:: 428
  hl-color:: yellow
  id:: 63d09dd7-080c-4c42-9384-634c0084d591
- 。NodeList 对象独特的地方在于，它其实是一个对 DOM 结构的查询，因此 DOM 结构的变化会自动地在 NodeList 中反映出来
  ls-type:: annotation
  hl-page:: 428
  hl-color:: yellow
  id:: 63d09e36-3fec-4cd7-8137-7a0d9e568b33
- 注意，length 属性表示那一时刻 NodeList 中节点的数量
  ls-type:: annotation
  hl-page:: 428
  hl-color:: yellow
  id:: 63d09e78-ffe7-4ffc-b4fc-4642a48bb397
- 使用 ES6 的 Array.from()静态方法，可以替换这种笨拙的方式
  ls-type:: annotation
  hl-page:: 429
  hl-color:: yellow
  id:: 63d09e8a-691e-4f79-a0dd-6f663b74e12f
- 使用 Array.prototype. slice()可以像前面介绍 arguments 时一样把 NodeList 对象转换为数组
  ls-type:: annotation
  hl-page:: 428
  hl-color:: yellow
  id:: 63d09e97-4b68-401f-92ec-b7709dddff30
- 每个节点都有一个 parentNode 属性，指向其 DOM 树中的父元素
  ls-type:: annotation
  hl-page:: 429
  hl-color:: yellow
  id:: 63d09eb0-db8d-4bc7-b3cd-facff8bb1ed7
- childNodes 中的所有节点都有同一个父元素，因此它们的 parentNode 属性都指向同一个节点
  ls-type:: annotation
  hl-page:: 429
  hl-color:: yellow
  id:: 63d09f6e-3b48-40eb-8b2d-7709b7c6fc7d
- 使用 previousSibling 和 nextSibling 可以在这个列表的节点间导航
  ls-type:: annotation
  hl-page:: 429
  hl-color:: yellow
  id:: 63d09f75-3503-470f-a249-fade04e50317
- 父节点和它的第一个及最后一个子节点也有专门属性：firstChild 和 lastChild 分别指向 childNodes 中的第一个和最后一个子节点
  ls-type:: annotation
  hl-page:: 429
  hl-color:: yellow
  id:: 63d09f83-5f14-4351-9113-9cdd0e10821a
- 有了这些关系，childNodes 属性的作用远远不止是必备属性那么简单了
  ls-type:: annotation
  hl-page:: 429
  hl-color:: yellow
  id:: 63d09fc0-e465-4f6d-9d43-e3e55723affa
- 。ownerDocument 属性是一个指向代表整个文档的文档节点的指针。
  ls-type:: annotation
  hl-page:: 429
  hl-color:: yellow
  id:: 63d0a010-4401-457f-b735-35c2c25c9aad
- 操纵节点
  ls-type:: annotation
  hl-page:: 430
  hl-color:: green
  id:: 63d0a051-b265-4275-b362-146c94560b91
- 最常用的方法是 appendChild()，用于在 childNodes 列表末尾添加节点
  ls-type:: annotation
  hl-page:: 430
  hl-color:: yellow
  id:: 63d0a093-51e0-412f-ae20-16d305af497a
- 如果把文档中已经存在的节点传给 appendChild()，则这个节点会从之前的位置被转移到新位置
  ls-type:: annotation
  hl-page:: 430
  hl-color:: yellow
  id:: 63d0a0ca-b8d5-4984-9d8b-009e66beb91f
- 如果想把节点放到 childNodes 中的特定位置而不是末尾，则可以使用 insertBefore()方法
  ls-type:: annotation
  hl-page:: 430
  hl-color:: yellow
  id:: 63d0a124-598c-45c8-911f-cd2bfc1bd8a6
- replaceChild()方法接收两个参数：要插入的节点和要替换的节点
  ls-type:: annotation
  hl-page:: 430
  hl-color:: yellow
  id:: 63d0a21d-9258-4935-8a1f-895187d658e5
- 要移除节点而不是替换节点，可以使用 removeChild()方法。
  ls-type:: annotation
  hl-page:: 431
  hl-color:: yellow
  id:: 63d0c906-53c0-4253-a4ef-f632c3d0d4be
- 。第一个是 cloneNode()，会返回与调用它的节点一模一样的节点
  ls-type:: annotation
  hl-page:: 431
  hl-color:: yellow
  id:: 63d0c930-68c3-4766-b3f1-fd9fe52948e2
- cloneNode()方法接收一个布尔值参数，表示是否深复制
  ls-type:: annotation
  hl-page:: 431
  hl-color:: yellow
  id:: 63d0c939-084c-40ae-8275-577c65ce9294
- 如果传入 false，则只会复制调用该方法的节点。复制返回的节点属于文档所有，但尚未指定父节点，所以可称为孤儿节点（orphan）。
  ls-type:: annotation
  hl-page:: 431
  hl-color:: yellow
  id:: 63d0c94c-1bbf-4e80-a473-8cb0febdb83a
- cloneNode()方法不会复制添加到 DOM 节点的 JavaScript 属性，
  ls-type:: annotation
  hl-page:: 431
  hl-color:: yellow
  id:: 63d0c975-3771-4d36-8b6a-82cd189907a8
- normalize()。这个方法唯一的任务就是处理文档子树中的文本节点
  ls-type:: annotation
  hl-page:: 431
  hl-color:: yellow
  id:: 63d0c9a5-2d74-4870-b629-fcdf25c1ab86
- 在节点上调用 normalize()方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点
  ls-type:: annotation
  hl-page:: 432
  hl-color:: yellow
  id:: 63d0c9cb-f09b-4abb-8b06-ad531d249814
- Document 类型
  ls-type:: annotation
  hl-page:: 432
  hl-color:: green
  id:: 63d0c9d6-2ba5-4b3e-a4f0-9280904c3166
- Document 类型是 JavaScript 中表示文档节点的类型
  ls-type:: annotation
  hl-page:: 432
  hl-color:: yellow
  id:: 63d0c9e3-d413-4205-afdb-182ec18ed6c7
- document 是 window对象的属性，因此是一个全局对象
  ls-type:: annotation
  hl-page:: 432
  hl-color:: yellow
  id:: 63d0c9f0-24c7-413d-a09c-518004063fd6
- document 对象可用于获取关于页面的信息以及操纵其外观和底层结构
  ls-type:: annotation
  hl-page:: 432
  hl-color:: yellow
  id:: 63d0ca18-2357-4892-ba40-ddae8e67fa4b
- 第一个是 documentElement 属性，始终指向 HTML 页面中的<html>元素
  ls-type:: annotation
  hl-page:: 432
  hl-color:: yellow
  id:: 63d0ca25-5f10-4e80-85bb-37feaba9c1ee
- 作为 HTMLDocument 的实例，document 对象还有一个 body 属性，直接指向<body>元素
  ls-type:: annotation
  hl-page:: 432
  hl-color:: yellow
  id:: 63d0ca4b-5fdc-400c-a69c-8a9d1a586f14
- <!doctype>标签是文档中独立的部分，其信息可以通过 doctype 属性（在浏览器中是 document.doctype）来访问
  ls-type:: annotation
  hl-page:: 432
  hl-color:: yellow
  id:: 63d0caac-3a20-4f5b-8754-7ac1b1420b12
- 严格来讲出现在<html>元素外面的注释也是文档的子节点，它们的类型是 Comment
  ls-type:: annotation
  hl-page:: 433
  hl-color:: yellow
  id:: 63d0cadf-f2c2-4260-9358-79820ad7f957
- ，修改后的标题也会反映在浏览器标题栏上。不过，修改 title 属性并不会改变<title>元素
  ls-type:: annotation
  hl-page:: 433
  hl-color:: yellow
  id:: 63d0cb30-e06b-484a-8b92-4ac6aa10b10d
- document 作为 HTMLDocument 的实例，还有一些标准 Document 对象上所没有的属性
  ls-type:: annotation
  hl-page:: 433
  hl-color:: yellow
  id:: 63d0cb3b-b290-406e-a42a-2cd9543a05e1
- 是 title，包含<title>元素中的文本
  ls-type:: annotation
  hl-page:: 433
  hl-color:: yellow
  id:: 63d0cb53-d636-41bb-afa8-0ead27057c0c
- ，URL 包含当前页面的完整 URL（地址栏中的 URL）
  ls-type:: annotation
  hl-page:: 433
  hl-color:: yellow
  id:: 63d0cb5c-c39a-4567-b4bd-4f3db31abe0f
- domain 包含页面的域名
  ls-type:: annotation
  hl-page:: 433
  hl-color:: yellow
  id:: 63d0cb60-724e-40bd-a4e4-e6044699ac86
- eferrer 包含链接到当前页面的那个页面的 URL
  ls-type:: annotation
  hl-page:: 433
  hl-color:: yellow
  id:: 63d0cb67-2930-472a-b6d4-140b5b533c28
- 浏 览 器 对 domain 属 性 还 有 一 个 限 制 ， 即 这 个 属 性 一 旦 放 松 就 不 能 再 收 紧 。 比 如 
  ls-type:: annotation
  hl-page:: 434
  hl-color:: yellow
  id:: 63d0cb96-3c70-45bd-bcaf-ea468364d97b
- 只有 domain 属性是可以设置的
  ls-type:: annotation
  hl-page:: 433
  hl-color:: yellow
  id:: 63d0cba0-c6e4-4385-85df-c0f688982d85
- 使用 DOM 最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作
  ls-type:: annotation
  hl-page:: 434
  hl-color:: yellow
  id:: 63d0cbca-9d88-478d-b19a-ceaa2f17fd38
- getElementById()方法接收一个参数，即要获取元素的 ID，如果找到了则返回这个元素，如果没找到则返回 nul
  ls-type:: annotation
  hl-page:: 434
  hl-color:: yellow
  id:: 63d0cbd6-bc3e-4c74-9a39-1de6196577da
- 如果页面中存在多个具有相同 ID 的元素，则 getElementById()返回在文档中出现的第一个元素
  ls-type:: annotation
  hl-page:: 434
  hl-color:: yellow
  id:: 63d0cbe8-a59f-44b9-86ab-07e151f84c06
- getElementsByTagName()是另一个常用来获取元素引用的方法。这个方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的 NodeList
  ls-type:: annotation
  hl-page:: 434
  hl-color:: yellow
  id:: 63d0cc4b-2745-45ab-bd9f-7a0679a88d4c
- 使用中括号或 item()方法从 HTMLCollection 取得特定的元素。而取得元素的数量同样可以通过 length 属性得知，如下所示：
  ls-type:: annotation
  hl-page:: 435
  hl-color:: yellow
  id:: 63d0cc7d-2b3c-43b5-953b-4c70b1a00c1e
- HTMLCollection 对象还有一个额外的方法 namedItem()，可通过标签的 name 属性取得某一项的引用。
  ls-type:: annotation
  hl-page:: 435
  hl-color:: yellow
  id:: 63d0ccb4-e70c-4c1b-acd8-7f78f196897c
- 对 HTMLCollection 对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台，数值索引会调用 item()，字符串索引会调用 namedItem()。
  ls-type:: annotation
  hl-page:: 435
  hl-color:: yellow
  id:: 63d0ccfa-5061-4f1b-800a-2c2aa4337b47
- 要取得文档中的所有元素，可以给 getElementsByTagName()传入*
  ls-type:: annotation
  hl-page:: 435
  hl-color:: yellow
  id:: 63d0cd07-fdca-4f2b-8afd-9707d13a4622
- HTMLDocument 类型上定义的获取元素的第三个方法是 getElementsByName()。
  ls-type:: annotation
  hl-page:: 435
  hl-color:: yellow
  id:: 63d0cd1a-5229-4c79-81ef-6906fdd11f50
- 这里所有的单选按钮都有名为"color"的 name 属性
  ls-type:: annotation
  hl-page:: 436
  hl-color:: yellow
  id:: 63d0cd34-0629-4e91-bd65-b87d31de021b
- 特殊集合
  ls-type:: annotation
  hl-page:: 436
  hl-color:: green
  id:: 63d0cd71-e1e2-4fe4-a712-1af4a81cdb3e
- DOM 兼容性检测
  ls-type:: annotation
  hl-page:: 436
  hl-color:: green
  id:: 63d0cd88-f0fe-4d31-9d06-19d391ecb1d6
- document.implementation 属性是一个对象，其中提供了与浏览器 DOM 实现相关的信息和能力
  ls-type:: annotation
  hl-page:: 436
  hl-color:: yellow
  id:: 63d0cda6-ff8d-4407-8f18-991f31e32f1d
- 即 hasFeature()。这个方法接收两个参数：特性名称和 DOM 版本。如果浏览器支持指定的特性和版本，则 hasFeature()方法返回 true
  ls-type:: annotation
  hl-page:: 436
  hl-color:: yellow
  id:: 63d0cdc6-964a-4094-9378-a02fa71d427d
- 文档写入
  ls-type:: annotation
  hl-page:: 437
  hl-color:: green
  id:: 63d0cdf7-ae8c-4e7e-af96-98493d890137
- write()和 writeln()方法都接收一个字符串参数，可以将这个字符串写入网页中
  ls-type:: annotation
  hl-page:: 437
  hl-color:: yellow
  id:: 63d0ce0a-0ea6-46b6-bf25-6947899717eb
- write()和 writeln()方法经常用于动态包含外部资源
  ls-type:: annotation
  hl-page:: 437
  hl-color:: yellow
  id:: 63d0ce35-0f9a-4a35-95a5-59e4ee8793e4
- 前面的例子展示了在页面渲染期间通过 document.write()向文档中输出内容。如果是在页面加载完之后再调用 document.write()，则输出的内容会重写整个页面
  ls-type:: annotation
  hl-page:: 438
  hl-color:: yellow
  id:: 63d0ce5c-9335-42ba-9b44-9dc406a40222
- Element 类型
  ls-type:: annotation
  hl-page:: 439
  hl-color:: green
  id:: 63d0ce6e-0b2d-4095-9079-5f441276d07e
- 在 HTML 中，元素标签名始终以全大写表示；在 XML（包括 XHTML）中，标签名始终与源代码中的大小写一致。如果不确定脚本是在 HTML 文档还是 XML 文档中运行，最好将标签名转换为小写形式，以便于比较
  ls-type:: annotation
  hl-page:: 439
  hl-color:: yellow
  id:: 63d0ceb0-689c-4515-8641-ffa9f8e7fcd6
- 并非所有这些属性的修改都会对页面产生影响。比
  ls-type:: annotation
  hl-page:: 440
  hl-color:: yellow
  id:: 63d0ceea-d3c3-4228-a2a0-8a41eddefeb8
- 修改 className 会立即反映应用到新类名的 CSS 样式（如果定义了不同的样式）
  ls-type:: annotation
  hl-page:: 440
  hl-color:: yellow
  id:: 63d0cf1c-4b3c-4cb1-b495-ca679c99167f
- 取得属性
  ls-type:: annotation
  hl-page:: 441
  hl-color:: green
  id:: 63d0cf28-0ff6-4d46-8be2-782aada5f351
- 注意传给 getAttribute()的属性名与它们实际的属性名是一样的，因此这里要传"class"而非
  ls-type:: annotation
  hl-page:: 441
  hl-color:: yellow
  id:: 63d0cf70-0279-43ee-8180-cf9dc5d2e2a3
- getAttribute()方法也能取得不是 HTML 语言正式属性的自定义属性的值
  ls-type:: annotation
  hl-page:: 442
  hl-color:: yellow
  id:: 63d0cfb3-fef6-487d-a960-8e5a22742bf4
- 属性名不区分大小写
  ls-type:: annotation
  hl-page:: 442
  hl-color:: yellow
  id:: 63d0cfe4-19bd-47ad-8c99-e8434b4d2725
- 通过 DOM 对象访问的属性中有两个返回的值跟使用 getAttribute()取得的值不一样
  ls-type:: annotation
  hl-page:: 442
  hl-color:: yellow
  id:: 63d0d02e-9a5e-456d-99f7-caa60cf8fbbd
- 使用 getAttribute()访问 style 属性时，返回的是 CSS 字符串。而在通过 DOM 对象的属性访问时，style 属性返回的是一个（CSSStyleDeclaration）对象
  ls-type:: annotation
  hl-page:: 442
  hl-color:: yellow
  id:: 63d0d03a-3257-4e2b-ac0c-36a49a874b39
- 在元素上使用事件属性时（比如 onclick），属性的值是一段 JavaScript 代码。如果使用 getAttribute()访问事件属性，则返回的是字符串形式的源代码。而通过 DOM 对象的属性访问事件属性时返回的则是一个 JavaScript函数（未指定该属性则返回 null）。这是因为 onclick 及其他事件属性是可以接受函数作为值的
  ls-type:: annotation
  hl-page:: 442
  hl-color:: yellow
  id:: 63d0d055-878d-4f0a-b22c-091bd8c0140a
- 设置属性
  ls-type:: annotation
  hl-page:: 442
  hl-color:: green
  id:: 63d0d07a-4a2c-4adf-831d-9c54cb23c5ac
- 法接收两个参数：要设置的属性名和属性的值
  ls-type:: annotation
  hl-page:: 442
  hl-color:: yellow
  id:: 63d0d083-93ba-4099-aebe-de6abd94f368
- 最后一个方法 removeAttribute()用于从元素中删除属性。这样不单单是清除属性的值，而是会把整个属性完全从元素中去掉，如下所示：
  ls-type:: annotation
  hl-page:: 443
  hl-color:: yellow
  id:: 63d0d0f6-b170-4f10-a7ab-ee357afe4e92
- attributes 属性
  ls-type:: annotation
  hl-page:: 443
  hl-color:: green
  id:: 63d0d142-7b80-4b2e-883e-70e938778627
- ttributes 属性包含一个 NamedNodeMap 实例，是一个类似 NodeList 的“实时”集合。元
  ls-type:: annotation
  hl-page:: 443
  hl-color:: yellow
  id:: 63d0d150-de22-4196-8fab-39427b836b8e
- attributes 属性中的每个节点的 nodeName 是对应属性的名字，nodeValue 是属性的值
  ls-type:: annotation
  hl-page:: 443
  hl-color:: yellow
  id:: 63d0d167-138a-4513-bc09-5310cf4c350d
- 同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其 nodeValue 设置为新值
  ls-type:: annotation
  hl-page:: 443
  hl-color:: yellow
  id:: 63d0d197-4779-45ac-91c0-beea10fa1504
- ，就是 removeNamedItem()返回表示被删除属性的 Attr节点
  ls-type:: annotation
  hl-page:: 443
  hl-color:: yellow
  id:: 63d0d1b0-ea49-4f5b-9307-3108719f75c3
- attributes 属性最有用的场景是需要迭代元素上所有属性的时候
  ls-type:: annotation
  hl-page:: 443
  hl-color:: yellow
  id:: 63d0d213-d855-4201-93f8-c4cac7659293
- 创建元素
  ls-type:: annotation
  hl-page:: 444
  hl-color:: green
  id:: 63d0d222-c6c4-4cf8-ba83-e60179f8959c
- 可以使用 document.createElement()方法创建新元素
  ls-type:: annotation
  hl-page:: 444
  hl-color:: yellow
  id:: 63d0d23c-a44e-4d0b-8674-264008e46b5b
- 使用 createElement()方法创建新元素的同时也会将其 ownerDocument 属性设置为 document。
  ls-type:: annotation
  hl-page:: 444
  hl-color:: yellow
  id:: 63d0d249-e310-4d29-83af-b64e90722ff4
- 要把元素添加到文档树，可以使用 appendChild()、insertBefore()或 replaceChild()。比如，以下代码会把刚才创建的元素添加到文档的<body>元素中
  ls-type:: annotation
  hl-page:: 444
  hl-color:: yellow
  id:: 63d0d257-97f5-4fb5-b542-1e706c7b8449
- 元素后代
  ls-type:: annotation
  hl-page:: 444
  hl-color:: green
  id:: 63d0d273-c0ca-4de3-aae5-3e432a91f1d0
- 通常在执行某个操作之后需要先检测一下节点的 nodeType，
  ls-type:: annotation
  hl-page:: 445
  hl-color:: yellow
  id:: 63d0d29b-7f23-4c15-8582-2a9f14f10864
- 要取得某个元素的子节点和其他后代节点，可以使用元素的 getElementsByTagName()方法。
  ls-type:: annotation
  hl-page:: 445
  hl-color:: yellow
  id:: 63d0d2ea-29c8-4df9-beb6-dee04c60ecd7
- Text 类型
  ls-type:: annotation
  hl-page:: 445
  hl-color:: green
  id:: 63d0d2fc-43c6-44dc-9af2-385ee226abfd
- Text 节点中包含的文本可以通过 nodeValue 属性访问，也可以通过 data 属性访问，
  ls-type:: annotation
  hl-page:: 445
  hl-color:: yellow
  id:: 63d0d315-20bf-41a8-ac82-1e3989181935
- 默认情况下，包含文本内容的每个元素最多只能有一个文本节点
  ls-type:: annotation
  hl-page:: 445
  hl-color:: yellow
  id:: 63d0d327-feeb-4ca7-a099-1eb24173a329
- document.createTextNode()可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。
  ls-type:: annotation
  hl-page:: 446
  hl-color:: yellow
  id:: 63d0d3b9-34b7-48c1-b7c5-31ef4af30b78
- 创建文本节点
  ls-type:: annotation
  hl-page:: 446
  hl-color:: green
  id:: 63d0d3c3-55d0-421b-a9e8-ce36bf6f81b8
- 规范化文本节点
  ls-type:: annotation
  hl-page:: 447
  hl-color:: green
  id:: 63d0d3ce-9259-450b-9b6f-756a74fd664f
- 在包含两个或多个相邻文本节点的父节点上调用 normalize()时，所有同胞文本节点会被合并为一个文本节点
  ls-type:: annotation
  hl-page:: 447
  hl-color:: yellow
  id:: 63d0d3f0-8483-4d5d-9ff5-8fb9a05118b1
- 拆分文本节点
  ls-type:: annotation
  hl-page:: 447
  hl-color:: green
  id:: 63d0d42a-e21b-491b-a8fa-e55504624ab9
- splitText()。这个方法可以在指定的偏移位置拆分 nodeValue，将一个文本节点拆分成两个文本节点
  ls-type:: annotation
  hl-page:: 447
  hl-color:: yellow
  id:: 63d0d43c-e7a0-4a48-8f8b-6b9ca0169fd5
- Comment 类型
  ls-type:: annotation
  hl-page:: 448
  hl-color:: green
  id:: 63d0d45c-61a4-4d38-9905-db4f93bc6de3
- Comment 类型与 Text 类型继承同一个基类（CharacterData），
  ls-type:: annotation
  hl-page:: 448
  hl-color:: yellow
  id:: 63d0d471-2da5-4773-b618-f54b034e8e46
- 注释节点可以作为父节点的子节点来访问。
  ls-type:: annotation
  hl-page:: 448
  hl-color:: yellow
  id:: 63d0d47e-47c6-42a9-89a8-fe940025fc82
- CDATASection 类型
  ls-type:: annotation
  hl-page:: 448
  hl-color:: green
  id:: 63d0d495-3bc8-4aa0-90e5-57769d5faed3
- CDATASection 类型表示 XML 中特有的 CDATA 区块
  ls-type:: annotation
  hl-page:: 448
  hl-color:: yellow
  id:: 63d0d63f-c47f-434e-a045-7323cb6d4b30
- CDATASection 类型继承 Text 类型，因此拥有包括 splitText()在内的所有字符串操作方法
  ls-type:: annotation
  hl-page:: 448
  hl-color:: yellow
  id:: 63d0d648-9e43-4eae-aea0-803de757ee87
- DocumentType 类型
  ls-type:: annotation
  hl-page:: 449
  hl-color:: green
  id:: 63d0d692-5fbe-4eef-8043-55eb50a7b371
- DocumentType 类型的节点包含文档的文档类型（doctype）信息
  ls-type:: annotation
  hl-page:: 449
  hl-color:: yellow
  id:: 63d0d6a1-1ea8-44f1-ae53-1afa77d5519c
- DocumentType 对象保存在 document.doctype 属性中
  ls-type:: annotation
  hl-page:: 449
  hl-color:: yellow
  id:: 63d0d6bb-2958-400a-83ac-30ba521da37f
- name 是文档类型的名称
  ls-type:: annotation
  hl-page:: 449
  hl-color:: yellow
  id:: 63d0d6e6-809d-4ead-8215-37986fe12bed
- entities 是这个文档类型描述的实体的 NamedNodeM
  ls-type:: annotation
  hl-page:: 449
  hl-color:: yellow
  id:: 63d0d6fb-a1ec-4e4e-a835-199293c816b2
- notations 是这个文档类型描述的表示法的 NamedNodeMap
  ls-type:: annotation
  hl-page:: 449
  hl-color:: yellow
  id:: 63d0d70e-6a84-4a17-8b28-242188936fea
- DocumentFragment 类型
  ls-type:: annotation
  hl-page:: 449
  hl-color:: green
  id:: 63d0d730-6304-47cb-b86d-15ac5e7d15db
- 不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库
  ls-type:: annotation
  hl-page:: 449
  hl-color:: yellow
  id:: 63d0d751-6984-48b1-ba00-325d7e2c3672
- 可以通过 appendChild()或 insertBefore()方法将文档片段的内容添加到文档
  ls-type:: annotation
  hl-page:: 449
  hl-color:: yellow
  id:: 63d0d77a-eebf-4651-9f3e-f2e90f5055ba
- 下面的代码示例使用文档片段创建了所有列表项，然后一次性将它们添加到了<ul>元素
  ls-type:: annotation
  hl-page:: 450
  hl-color:: yellow
  id:: 63d0d7d8-c8f1-487b-aaf3-ef178d23c28d
- 文档片段本身永远不会被添加到文档树
  ls-type:: annotation
  hl-page:: 449
  hl-color:: yellow
  id:: 63d0d7ec-e85c-411d-8e12-bfa45296de31
- Attr 类型
  ls-type:: annotation
  hl-page:: 450
  hl-color:: green
  id:: 63d0d7f6-f28d-4e96-b7ee-0a5ba9e9c92c
- 元素数据在 DOM 中通过 Attr 类型表示
  ls-type:: annotation
  hl-page:: 450
  hl-color:: yellow
  id:: 63d0d869-83a3-4da8-a82d-a7576b3bc85a
- 属性节点尽管是节点，却不被认为是 DOM 文档树的一部分。
  ls-type:: annotation
  hl-page:: 450
  hl-color:: yellow
  id:: 63d0d895-7bf0-420d-9bac-ced25bf4e760
- 可以使用 document.createAttribute()方法创建新的 Attr 节点，参数为属性名。
  ls-type:: annotation
  hl-page:: 450
  hl-color:: yellow
  id:: 63d0d8aa-3583-4e74-a187-508081874806
- DOM 编程
  ls-type:: annotation
  hl-page:: 451
  hl-color:: green
  id:: 63d0d909-8fa3-4b30-a624-bc7633176d2d
- 动态脚本
  ls-type:: annotation
  hl-page:: 451
  hl-color:: green
  id:: 63d0d91b-4144-418b-9f90-f3cb1c81779b
- 注意，在上面最后一行把<script>元素添加到页面之前，是不会开始下载外部文件的。当然也可以把它添加到<head>元素，同样可以实现动态脚本加载
  ls-type:: annotation
  hl-page:: 451
  hl-color:: yellow
  id:: 63d0d94d-5232-475d-9266-cbf248a28edf
- 有两种方式通过<script>动态为网页添加脚本：引入外部文件和直接插入源代码
  ls-type:: annotation
  hl-page:: 451
  hl-color:: yellow
  id:: 63d0d95b-55ca-4bb5-ac97-91c0f9443d61
- 但<script>元素上有一个 text 属性，可以用来添加 JavaScript 代码，
  ls-type:: annotation
  hl-page:: 452
  hl-color:: yellow
  id:: 63d0d9ca-77fa-405a-a1e2-570ac5641af5
- 以这种方式加载的代码会在全局作用域中执行，并在调用返回后立即生
  ls-type:: annotation
  hl-page:: 452
  hl-color:: yellow
  id:: 63d0da30-7fbc-4eb6-bda2-fc6c66e93d6b
- 通过 innerHTML 属性创建的<script>元素永远不会执行
  ls-type:: annotation
  hl-page:: 452
  hl-color:: yellow
  id:: 63d0da4b-1135-4efe-b608-d6a9a3285df3
- 动态样式
  ls-type:: annotation
  hl-page:: 453
  hl-color:: green
  id:: 63d0da52-c3c2-4777-9945-05e747adc0a8
- CSS 样式在 HTML 页面中可以通过两个元素加载。<link>元素用于包含 CSS 外部文件，而<style>元素用于添加嵌入样式
  ls-type:: annotation
  hl-page:: 453
  hl-color:: yellow
  id:: 63d0da8f-5972-467d-952c-35738a89ccb0
- IE，解决方案是访问元素的 styleSheet 属性，这个属性又有一个 cssText 属性
  ls-type:: annotation
  hl-page:: 453
  hl-color:: yellow
  id:: 63d0db27-44c8-435d-bebe-abf80df2df3e
- 操作表格
  ls-type:: annotation
  hl-page:: 454
  hl-color:: green
  id:: 63d0db43-e9ad-432e-a46d-da1367562c9b
- 为了方便创建表格，HTML DOM 给<table>、<tbody>和<tr>元素添加了一些属性和方法
  ls-type:: annotation
  hl-page:: 455
  hl-color:: yellow
  id:: 63d0db5c-e269-4913-9311-0a6dc3e28512
- 使用 NodeList
  ls-type:: annotation
  hl-page:: 456
  hl-color:: green
  id:: 63d0dbb6-9ca4-440d-9710-b833e02b44fb
- 理解 NodeList 对象和相关的 NamedNodeMap、HTMLCollection，是理解 DOM 编程的关键。这3 个集合类型都是“实时的
  ls-type:: annotation
  hl-page:: 456
  hl-color:: yellow
  id:: 63d0dbc8-b87b-40e0-9d45-1ce43386e94f
- 任何时候要迭代 NodeList，最好再初始化一个变量保存当时查询时的长度，然后用循环变量与这个变量进行比较
  ls-type:: annotation
  hl-page:: 457
  hl-color:: yellow
  id:: 63d0dc09-000f-42c4-87e8-2419880380e3
- MutationObserver 接口
  ls-type:: annotation
  hl-page:: 457
  hl-color:: green
  id:: 63d0dc32-25e5-4c52-9271-81bb71e1eb74
- MutationObserver 接口，可以在 DOM 被修改时异步执行回调
  ls-type:: annotation
  hl-page:: 457
  hl-color:: yellow
  id:: 63d0dc41-fc21-462a-8bab-c48e49e6a954
- 基本用法
  ls-type:: annotation
  hl-page:: 458
  hl-color:: green
  id:: 63d0dc4e-3de7-4187-be7f-684f7ede7ed2
- observe()方法
  ls-type:: annotation
  hl-page:: 458
  hl-color:: green
  id:: 63d0dc92-017b-4477-83bc-680f5a523045
- 要把这个 observer 与 DOM 关联起来，需要使用 observe()方法
  ls-type:: annotation
  hl-page:: 458
  hl-color:: yellow
  id:: 63d0dca4-9309-45b5-8182-d547fae854a9
- 接收两个必需的参数：要观察其变化的 DOM 节点，以及一个 MutationObserverInit 对象
  ls-type:: annotation
  hl-page:: 458
  hl-color:: yellow
  id:: 63d0dcbb-e728-4dba-a41b-4c76c62b234d
- <body>元素后代的修改或其他非属性修改都不会触发回调进入任务队列
  ls-type:: annotation
  hl-page:: 458
  hl-color:: yellow
  id:: 63d0dd19-e0bc-446d-8400-b420b3eb787e
  hl-stamp:: 1674632519111
- observer.observe(document.body, { attributes: true });
  ls-type:: annotation
  hl-page:: 458
  hl-color:: yellow
  id:: 63d0dd3f-9127-4503-8705-40c3c72ffbb6
- 回调与 MutationRecord
  ls-type:: annotation
  hl-page:: 458
  hl-color:: green
  id:: 63d0dd63-a1e0-4ea6-8961-5be74b0494ae
- 每个回调都会收到一个 MutationRecord 实例的数组
  ls-type:: annotation
  hl-page:: 458
  hl-color:: yellow
  id:: 63d0dd80-9ff3-4dd7-a14e-259a9847e013
- MutationRecord 实例包含的信息包括发生了什么变化，以及 DOM 的哪一部分受到了影响
  ls-type:: annotation
  hl-page:: 458
  hl-color:: yellow
  id:: 63d0dd87-1527-4f77-be0d-2f002c79cfb6
- 连续修改会生成多个 MutationRecord 实例，下次回调执行时就会收到包含所有这些实例的数组，顺序为变化事件发生的顺序：
  ls-type:: annotation
  hl-page:: 459
  hl-color:: yellow
  id:: 63d0ddb1-5e22-400d-8424-698155b2d8cb
- 传给回调函数的第二个参数是观察变化的 MutationObserver 的实例
  ls-type:: annotation
  hl-page:: 460
  hl-color:: yellow
  id:: 63d0ddc0-3a8a-4403-8577-010e3c8c9cf1
- disconnect()方法
  ls-type:: annotation
  hl-page:: 460
  hl-color:: green
  id:: 63d0de66-0c18-4272-ae28-1a93dcfa04f0
- 要提前终止执行回调，可以调用 disconnect()方法。
  ls-type:: annotation
  hl-page:: 460
  hl-color:: yellow
  id:: 63d0e1af-1aaa-41f3-8f4d-ce6cb1555bfa
- 要想让已经加入任务队列的回调执行，可以使用 setTimeout()让已经入列的回调执行完毕再调用 disconnect()：
  ls-type:: annotation
  hl-page:: 460
  hl-color:: yellow
  id:: 63d0e21d-d1a4-48e6-a47d-f16ed890f881
- 复用 MutationObserver
  ls-type:: annotation
  hl-page:: 461
  hl-color:: green
  id:: 63d0e31b-eb5b-408c-849f-f130557ddbe2
- 。此时，MutationRecord 的 target 属性可以标识发生变化事件的目标节点
  ls-type:: annotation
  hl-page:: 461
  hl-color:: yellow
  id:: 63d0e40f-473e-4a41-8c08-f7287039a998
- 多次调用 observe()方法，可以复用一个 MutationObserver 对象观察多个不同的目标节点
  ls-type:: annotation
  hl-page:: 461
  hl-color:: yellow
  id:: 63d0e417-a382-4ea3-a988-1678de716891
- disconnect()方法是一个“一刀切”的方案，调用它会停止观察所有目标：
  ls-type:: annotation
  hl-page:: 461
  hl-color:: yellow
  id:: 63d0e422-2c0d-43b3-8d7e-2e555ab41f8e
- 重用 MutationObserver
  ls-type:: annotation
  hl-page:: 462
  hl-color:: green
  id:: 63d0e481-466c-440d-8c86-1dbaf8fc19b2
- MutationObserverInit 与观察范围
  ls-type:: annotation
  hl-page:: 462
  hl-color:: green
  id:: 63d0e48e-e982-4f77-94cc-1cebfefc9892
  hl-stamp:: 1674634384145
- MutationObserverInit 对象用于控制对目标节点的观察范围
  ls-type:: annotation
  hl-page:: 462
  hl-color:: yellow
  id:: 63d0e49b-bc2d-4fbe-8670-1d6f2096e613
- 观察属性
  ls-type:: annotation
  hl-page:: 463
  hl-color:: green
  id:: 63d0e74a-d12b-4857-810d-c28c1faa04c6
  hl-stamp:: 1674635090133
- 观察字符数据
  ls-type:: annotation
  hl-page:: 464
  hl-color:: green
  id:: 63d0e7b7-3cc4-4aed-b458-03335d2c0d1a
  hl-stamp:: 1674635197146
- MutationObserver 可以观察文本节点（如 Text、Comment 或 ProcessingInstruction 节点）中字符的添加、删除和修改
  ls-type:: annotation
  hl-page:: 464
  hl-color:: yellow
  id:: 63d0e7c6-c30c-49cd-a225-cac783f3a021
- 需要在 MutationObserverInit 对象中将 characterData 属性设置为 true，
  ls-type:: annotation
  hl-page:: 464
  hl-color:: yellow
  id:: 63d0e833-3b62-40b2-a0e0-f2b9c93f2791
- 如果想在变化记录中保存原来的字符数据，可以将 characterDataOldValue 属性设置为 true：
  ls-type:: annotation
  hl-page:: 464
  hl-color:: yellow
  id:: 63d0e841-4086-480e-ad28-67ed8125697d
- 观察子节点
  ls-type:: annotation
  hl-page:: 465
  hl-color:: green
  id:: 63d0eaad-45b2-4b14-a896-690d566260f0
- 需要在 MutationObserverInit 对象中将 childList 属性设置为 true。
  ls-type:: annotation
  hl-page:: 465
  hl-color:: yellow
  id:: 63d0eabd-d8d0-414d-ad83-2a164466f675
- 观察子树
  ls-type:: annotation
  hl-page:: 466
  hl-color:: green
  id:: 63d0ec1c-1fdb-4d23-9b64-48fe31c15e35
- 这需要在 MutationObserverInit 对象中将 subtree属性设置为 true。
  ls-type:: annotation
  hl-page:: 466
  hl-color:: yellow
  id:: 63d0ec24-d377-4945-b0f2-e862870b2f93
- 被观察子树中的节点被移出子树之后仍然能够触发变化事件
  ls-type:: annotation
  hl-page:: 467
  hl-color:: yellow
  id:: 63d0ec33-d8a6-476a-b3ae-53c54b2a780a
- 异步回调与记录队列
  ls-type:: annotation
  hl-page:: 467
  hl-color:: green
  id:: 63d0ee6f-ed0f-4049-bc2c-15db706ebac4
- 。为了在大量变化事件发生时不影响性能，每次变化的信息（由观察者实例决定）会保存在 MutationRecord实例中，然后添加到记录队列
  ls-type:: annotation
  hl-page:: 467
  hl-color:: yellow
  id:: 63d0ee91-0ee6-469e-aad9-1b48826f5e20
- 记录队列
  ls-type:: annotation
  hl-page:: 468
  hl-color:: green
  id:: 63d0eec4-6f93-4bb2-8d8a-c7a22aea7efe
- takeRecords()方法
  ls-type:: annotation
  hl-page:: 468
  hl-color:: green
  id:: 63d0ef54-7e4d-4c19-8f3d-bb7b9ca9373c
  hl-stamp:: 1674637146601
- 调用 MutationObserver 实例的 takeRecords()方法可以清空记录队列，取出并返回其中的所有 MutationRecord 实例
  ls-type:: annotation
  hl-page:: 468
  hl-color:: yellow
  id:: 63d0ef5e-2611-438e-8764-62aed7023fb0
- 性能、内存与垃圾回收
  ls-type:: annotation
  hl-page:: 468
  hl-color:: green
  id:: 63d0ef66-8d28-44cf-b3e9-68709a4b03ab
- 。MutationObserver 拥有对要观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节
  ls-type:: annotation
  hl-page:: 468
  hl-color:: yellow
  id:: 63d0f052-127b-4d48-aef5-ec646d2d7805
- ，目标节点却拥有对 MutationObserver 的强引用。如果目标节点从 DOM 中被移除，随后被垃圾回收，则关联的 MutationObserver 也会被垃圾回收。
  ls-type:: annotation
  hl-page:: 468
  hl-color:: yellow
  id:: 63d0f106-d9e0-4daf-a17a-dde297f4a9fd
- 。如果需要尽快地释放内存，建议从每个 MutationRecord中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 MutationRecord。
  ls-type:: annotation
  hl-page:: 469
  hl-color:: yellow
  id:: 63d0f115-4368-4560-866c-3cb3f15299ac
- Selectors API
  ls-type:: annotation
  hl-page:: 470
  hl-color:: green
  id:: 63d0f12c-1689-4c47-bad8-8dc5f6b87917
- JavaScript 库中最流行的一种能力就是根据 CSS 选择符的模式匹配 DOM 元素
  ls-type:: annotation
  hl-page:: 470
  hl-color:: yellow
  id:: 63d0f56a-9f02-4bda-84b2-e726de804610
- querySelector()
  ls-type:: annotation
  hl-page:: 470
  hl-color:: green
  id:: 63d0f8dd-c5ba-40bf-b112-c1b544d0002c
- querySelector()方法接收 CSS 选择符参数，返回匹配该模式的第一个后代元素
  ls-type:: annotation
  hl-page:: 470
  hl-color:: yellow
  id:: 63d0f8e9-7592-4e57-af4a-5c466ad75854
- querySelectorAll()
  ls-type:: annotation
  hl-page:: 471
  hl-color:: green
  id:: 63d0f95d-80bd-4a26-9b3a-65251dc5fc0a
- 也接收一个用于查询的参数，但它会返回所有匹配的节点
  ls-type:: annotation
  hl-page:: 471
  hl-color:: yellow
  id:: 63d0f96c-794e-436d-bead-4260713f372c
- 这个方法返回的是一个 NodeList 的静态实例
  ls-type:: annotation
  hl-page:: 471
  hl-color:: yellow
  id:: 63d0f975-f971-4a34-a306-c56e9d9f418f
- 与 querySelector()一样，querySelectorAll()也可以在 Document、DocumentFragment 和 Element 类型上使用
  ls-type:: annotation
  hl-page:: 471
  hl-color:: yellow
  id:: 63d0fa4d-abc0-44b1-914e-3096d4b664b6
- 返回的 NodeList 对象可以通过 for-of 循环、item()方法或中括号语法取得个别元素
  ls-type:: annotation
  hl-page:: 471
  hl-color:: yellow
  id:: 63d0fb20-70f4-4793-b68f-e0973a24bb49
- 取得所有是<p>元素子元素的<strong>元素
  ls-type:: annotation
  hl-page:: 471
  hl-color:: yellow
  id:: 63d0fb26-bff0-42fe-9981-d59b9bd41e7b
- 与 querySelector()方法一样，如果选择符有语法错误或碰到不支持的选择符，则 querySelectorAll()方法会抛出错误
  ls-type:: annotation
  hl-page:: 471
  hl-color:: yellow
  id:: 63d0fb35-ef74-4e98-8ff3-8ab822ed489a
- let strongs = document.querySelectorAll("p strong");
  ls-type:: annotation
  hl-page:: 471
  hl-color:: red
  id:: 63d0fb83-9378-4cdb-ad92-15d5e5c076cf
- matches()
  ls-type:: annotation
  hl-page:: 472
  hl-color:: green
  id:: 63d0fb8b-f6bc-4ce6-b091-234ae64a1bef
  hl-stamp:: 1674640270185
- 使用这个方法可以方便地检测某个元素会不会被 querySelector()或 querySelectorAll()方法返回。
  ls-type:: annotation
  hl-page:: 472
  hl-color:: yellow
  id:: 63d0fba1-5b4b-4a67-aaf1-77fd439e162d
- 元素遍历
  ls-type:: annotation
  hl-page:: 472
  hl-color:: green
  id:: 63d0fba7-c1c4-4979-a21e-ee1021004780
- E9 之前的版本不会把元素间的空格当成空白节点，而其他浏览器则会
  ls-type:: annotation
  hl-page:: 472
  hl-color:: yellow
  id:: 63d10b4a-48e0-4c04-b88b-5ab8ec0f6816
- Element Traversal API 为 DOM 元素添加了 5 个属性：
  ls-type:: annotation
  hl-page:: 472
  hl-color:: yellow
  id:: 63d10b54-1e19-4eef-a94c-a49bc2c36cd7
- childElementCount，返回子元素数量（不包含文本节点和注释）；
  ls-type:: annotation
  hl-page:: 472
  hl-color:: yellow
  id:: 63d10b93-59b4-43a6-8be7-c486d95d4b1a
- firstElementChild，指向第一个 Element 类型的子元素
  ls-type:: annotation
  hl-page:: 472
  hl-color:: yellow
  id:: 63d10ba1-c837-4f64-a6d7-73958a157bee
- astElementChild，指向最后一个 Element 类型的子元素
  ls-type:: annotation
  hl-page:: 472
  hl-color:: yellow
  id:: 63d10ba8-1302-4b2d-bc51-fb9b1922fdf6
- previousElementSibling ， 指 向 前 一 个 Element 类 型 的 同 胞 元 素 
  ls-type:: annotation
  hl-page:: 472
  hl-color:: yellow
  id:: 63d10bb0-e8c4-4951-b06f-d85ff23dc9fe
- nextElementSibling，指向后一个 Element 类型的同胞元素
  ls-type:: annotation
  hl-page:: 472
  hl-color:: yellow
  id:: 63d10bb7-41ae-4b64-92e4-ef03e6f29baf
- HTML5
  ls-type:: annotation
  hl-page:: 473
  hl-color:: green
  id:: 63d10d98-c8ac-4136-aa8e-20e406ade9bc
- CSS 类扩展
  ls-type:: annotation
  hl-page:: 473
  hl-color:: green
  id:: 63d10db7-a968-4a9b-a365-6b0b7703a60a
- 包括动态修改类名，以及根据给定的一个或一组类名查询元素
  ls-type:: annotation
  hl-page:: 473
  hl-color:: yellow
  id:: 63d10e3e-66fb-48b7-977a-ff19033decfe
- getElementsByClassName()
  ls-type:: annotation
  hl-page:: 473
  hl-color:: green
  id:: 63d10e46-5e9e-4541-b2fa-268c76afc0fb
- getElementsByClassName()方法接收一个参数，即包含一个或多个类名的字符串，返回类名中包含相应类的元素的 NodeList
  ls-type:: annotation
  hl-page:: 473
  hl-color:: yellow
  id:: 63d10e6e-3ba1-4940-a079-b438a722f453
- 在特定元素上调用 getElementsByClassName()则返回该元素后代中匹配的元素
  ls-type:: annotation
  hl-page:: 473
  hl-color:: yellow
  id:: 63d10ea1-ee83-4dcc-8a1d-8391885e5920
- classList 属性
  ls-type:: annotation
  hl-page:: 474
  hl-color:: green
  id:: 63d10ed6-d5d4-45f1-af0c-f6dbc382e7f6
- 但 className 是一个字符串
  ls-type:: annotation
  hl-page:: 474
  hl-color:: yellow
  id:: 63d10f17-1635-4b3f-8a94-92b26de5a9e1
- 再把包含剩余类的字符串设置回去
  ls-type:: annotation
  hl-page:: 474
  hl-color:: yellow
  id:: 63d10f3f-2bee-4a0e-aa9d-82c5e6f3ca7f
- 这就是从<div>元素的类名中删除"user"类要写的代码
  ls-type:: annotation
  hl-page:: 474
  hl-color:: yellow
  id:: 63d10f6d-859b-479a-9781-0d310c75a17c
- 通过给所有元素增加 classList 属性为这些操作提供了更简单也更安全的实现方式
  ls-type:: annotation
  hl-page:: 474
  hl-color:: yellow
  id:: 63d10fae-5d96-4aec-a493-ce3f5d6edcd2
- 焦点管理
  ls-type:: annotation
  hl-page:: 475
  hl-color:: green
  id:: 63d1101a-666b-49e1-a8c5-b5b17cce172a
- 首先是 document.activeElement，始终包含当前拥有焦点的 DOM 元素
  ls-type:: annotation
  hl-page:: 475
  hl-color:: yellow
  id:: 63d11027-1935-4f41-8a46-b8d080402d11
- document.activeElement 在页面刚加载完之后会设置为 document.body
  ls-type:: annotation
  hl-page:: 475
  hl-color:: yellow
  id:: 63d1105d-f8d8-4dee-99bf-38faf36e3aad
- document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点
  ls-type:: annotation
  hl-page:: 475
  hl-color:: yellow
  id:: 63d11074-9805-44a8-a62d-91c7648a63af
- HTMLDocument 扩展
  ls-type:: annotation
  hl-page:: 475
  hl-color:: green
  id:: 63d110a3-3744-4936-8a4c-d5e23e52fed4
- readyState 属性
  ls-type:: annotation
  hl-page:: 475
  hl-color:: yellow
  id:: 63d110cb-18b0-4271-b6e7-6584feca73e8
- loading，表示文档正在加载
  ls-type:: annotation
  hl-page:: 475
  hl-color:: yellow
  id:: 63d11126-e68b-4224-aee1-bfc73dd63d07
- complete，表示文档加载完成
  ls-type:: annotation
  hl-page:: 475
  hl-color:: yellow
  id:: 63d1112d-f1f3-4928-bf80-9cbb4de50ffe
- compatMode 属性
  ls-type:: annotation
  hl-page:: 476
  hl-color:: yellow
  id:: 63d11142-5153-4d77-b3be-b7aafcfed731
- 唯一的任务是指示浏览器当前处于什么渲染模式
  ls-type:: annotation
  hl-page:: 476
  hl-color:: yellow
  id:: 63d11191-9d3c-4634-85a8-7b9283a013f5
- head 属性
  ls-type:: annotation
  hl-page:: 476
  hl-color:: yellow
  id:: 63d1119d-d656-460e-85a0-9d11a5a0b206
- 直接取得<head>元素
  ls-type:: annotation
  hl-page:: 476
  hl-color:: yellow
  id:: 63d111ac-140c-4548-aa07-6fd478f8ccd1
- 字符集属性
  ls-type:: annotation
  hl-page:: 476
  hl-color:: green
  id:: 63d111b5-8cb2-4f54-8aa1-4a90cfb5959d
- ，characterSet 属性表示文档实际使用的字符集，也可以用来指定新字符集
  ls-type:: annotation
  hl-page:: 476
  hl-color:: yellow
  id:: 63d111ef-b6d3-4f8d-a4b0-aa58c98c62a4
- 自定义数据属性
  ls-type:: annotation
  hl-page:: 476
  hl-color:: green
  id:: 63d111fa-6c9a-4d73-9856-47d0b8ae445c
- dataset 属 性 是 一 个 DOMStringMap 的实例，包含一组键/值对映射
  ls-type:: annotation
  hl-page:: 476
  hl-color:: yellow
  id:: 63d1123f-928e-4f18-870b-20be94bce28f
- 自定义数据属性非常适合需要给元素附加某些数据的场景，比如链接追踪和在聚合应用程序中标识页面的不同部分
  ls-type:: annotation
  hl-page:: 477
  hl-color:: yellow
  id:: 63d112b0-d49b-4cca-9cb0-8393c673d83a
- 插入标记
  ls-type:: annotation
  hl-page:: 477
  hl-color:: green
  id:: 63d112de-58a8-4a30-b689-bb5966835a02
- 但向文档中一次性插入大量 HTML 时还是比较麻烦。相比先创建一堆节点
  ls-type:: annotation
  hl-page:: 477
  hl-color:: yellow
  id:: 63d11316-e931-47f7-9d25-4a45cc902794
- innerHTML 属性
  ls-type:: annotation
  hl-page:: 477
  hl-color:: green
  id:: 63d11321-4211-494a-a552-6ebb2314ae06
- 在读取 innerHTML 属性时，会返回元素所有后代的 HTML 字符串，包括元素、注释和文本节点
  ls-type:: annotation
  hl-page:: 477
  hl-color:: yellow
  id:: 63d11342-5bed-46dd-aba1-da095eef37e6
- 在写入模式下，赋给 innerHTML 属性的值会被解析为 DOM 子树，并替代元素之前的所有节点
  ls-type:: annotation
  hl-page:: 477
  hl-color:: yellow
  id:: 63d11375-c8a3-4773-9013-fa6ba5f4dc4c
- 这是因为返回的字符串是将原始字符串对应的 DOM 子树序列化之后的结果。
  ls-type:: annotation
  hl-page:: 478
  hl-color:: yellow
  id:: 63d113b8-8501-421e-ae32-7d6bdf66b2fe
- 只要这样插入的<script>元素指定了 defer 属性，且<script>之前是“受控元素”（scoped element），那就是可以执行的
  ls-type:: annotation
  hl-page:: 478
  hl-color:: yellow
  id:: 63d113fd-045c-4c03-9f4e-c73f07713a88
- 。为了达到目的，必须在<script>前面加上一个受控元素，例如文本节点或没有结束标签的元素（如<input>）。
  ls-type:: annotation
  hl-page:: 478
  hl-color:: yellow
  id:: 63d1143b-1779-46b6-98b4-15b455de1499
- 第三行使用了一个隐藏的<input>字段来达成同样的目的
  ls-type:: annotation
  hl-page:: 478
  hl-color:: yellow
  id:: 63d11463-5011-4e66-84b8-7030e29ac9e8
- outerHTML 属性
  ls-type:: annotation
  hl-page:: 479
  hl-color:: green
  id:: 63d11493-b520-432e-bca6-acdb865c18e8
- 读取 outerHTML 属性时，会返回调用它的元素（及所有后代元素）的 HTML 字符串。
  ls-type:: annotation
  hl-page:: 479
  hl-color:: yellow
  id:: 63d114cc-7d5b-4178-bb2a-54668ec13480
- ，浏览器因解析和解释 HTML 代码的机制不同，返回的字符串也可能不同。（跟 innerHTML 的情况是一样的。）
  ls-type:: annotation
  hl-page:: 479
  hl-color:: yellow
  id:: 63d114df-12de-4f7b-9e7b-170b39ff50ab
- insertAdjacentHTML()与 insertAdjacentText()
  ls-type:: annotation
  hl-page:: 479
  hl-color:: green
  id:: 63d115f9-70e2-4c94-9814-ecd5aac8fbbd
- insertAdjacentHTML()和 insertAdjacentText()。这两个方法最早源自 IE，它们都接收两个参数：要插入标记的位置和要插入的 HTML 或文本
  ls-type:: annotation
  hl-page:: 479
  hl-color:: yellow
  id:: 63d11633-2a64-4941-b356-6c660241062a
- 内存与性能问题
  ls-type:: annotation
  hl-page:: 480
  hl-color:: green
  id:: 63d116f6-e0e3-408e-9d11-cc17d78d903a
- 在使用 innerHTML、 outerHTML 和 insertAdjacentHTML()之前，最好手动删除要被替换的元素上关联的事件处理程序和 JavaScript 对象。
  ls-type:: annotation
  hl-page:: 480
  hl-color:: yellow
  id:: 63d11744-ff81-4d38-8c22-112fd1f13966
- 一般来讲，插入大量的新 HTML 使用 innerHTML 比使用多次 DOM 操作创建节点再插入来得更便捷
  ls-type:: annotation
  hl-page:: 480
  hl-color:: yellow
  id:: 63d11758-0386-4933-83ac-3fc58c3b3b76
- 跨站点脚本
  ls-type:: annotation
  hl-page:: 480
  hl-color:: green
  id:: 63d1178b-3a59-46f6-91ce-e4f9092b16d3
- scrollIntoView()
  ls-type:: annotation
  hl-page:: 481
  hl-color:: green
  id:: 63d11806-9785-4266-b358-ef1a5b22cbf6
- scrollIntoView()方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口
  ls-type:: annotation
  hl-page:: 481
  hl-color:: yellow
  id:: 63d11834-3d41-443a-98e5-8d2185f2d20e
- alignToTop 是一个布尔值。
  ls-type:: annotation
  hl-page:: 481
  hl-color:: yellow
  id:: 63d1187d-2b8b-45e1-a675-ee50bedcd372
- scrollIntoViewOptions 是一个选项对象。
  ls-type:: annotation
  hl-page:: 481
  hl-color:: yellow
  id:: 63d11890-7871-4ea7-88fc-3a36c4139879
- 专有扩展
  ls-type:: annotation
  hl-page:: 481
  hl-color:: green
  id:: 63d1190a-6bf7-4324-9f00-4c4b9ee9981c
- children 属性
  ls-type:: annotation
  hl-page:: 481
  hl-color:: green
  id:: 63d1191b-b59c-4930-9fb1-dcdf16d4b213
- children 属性是一个 HTMLCollection，只包含元素的 Element 类型的子节点
  ls-type:: annotation
  hl-page:: 481
  hl-color:: yellow
  id:: 63d11932-7861-4752-a6d8-931b4bad7a2f
- contains()方法
  ls-type:: annotation
  hl-page:: 482
  hl-color:: green
  id:: 63d1198a-e467-44f8-91d0-5b3ecba0c24e
- 。contains()方法应该在要搜索的祖先元素上调用，参数是待确定的目标节点
  ls-type:: annotation
  hl-page:: 482
  hl-color:: yellow
  id:: 63d1199b-f1d3-4de8-8f6d-babfa339aec9
- compareDocumentPosition()方法也可以确定节点间的关系
  ls-type:: annotation
  hl-page:: 482
  hl-color:: yellow
  id:: 63d11a03-e0cc-421e-860b-21a5479cac59
- 插入标记
  ls-type:: annotation
  hl-page:: 482
  hl-color:: green
  id:: 63d11a89-4d83-4d01-940b-a2b70000aacf
- innerText 属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。
  ls-type:: annotation
  hl-page:: 482
  hl-color:: yellow
  id:: 63d11aa0-aad4-47e6-9ae8-850aee4e349b
- 设置 innerText 会移除元素之前所有的后代节点，完全改变 DOM 子树。
  ls-type:: annotation
  hl-page:: 483
  hl-color:: yellow
  id:: 63d11ad5-5cbd-474f-8ab0-82055fa0ddaa
- 通过将 innerText 设置为等于 innerText，可以去除所有 HTML 标签而只剩文本，
  ls-type:: annotation
  hl-page:: 483
  hl-color:: yellow
  id:: 63d11b0b-d874-400b-bc90-ee5f29d18df0
- outerText 与 innerText 是类似的，只不过作用范围包含调用它的节点
  ls-type:: annotation
  hl-page:: 483
  hl-color:: yellow
  id:: 63d11b2c-e847-419d-80b7-7c3be6b742b1
- 写入文本值时，outerText 不止会移除所有后代节点，而是会替换整个元素
  ls-type:: annotation
  hl-page:: 483
  hl-color:: yellow
  id:: 63d11b4c-618e-4be3-89e1-2830d505fa80
- 滚动
  ls-type:: annotation
  hl-page:: 484
  hl-color:: green
  id:: 63d11b5c-ad39-4961-b460-96cba18ab2fe
- 。实际上，DOM2和 DOM3 是按照模块化的思路来制定标准的，每个模块之间有一定关联，但分别针对某个 DOM 子集。
  ls-type:: annotation
  hl-page:: 485
  hl-color:: yellow
  id:: 63d11c35-c38d-4ab8-b22a-9673898d7c57
- XML 命名空间
  ls-type:: annotation
  hl-page:: 486
  hl-color:: green
  id:: 63d11caa-d8e4-4bf5-b194-6036109e0783
- 可以使用 xmlns 给命名空间创建一个前缀，格式为“xmlns: 前缀”
  ls-type:: annotation
  hl-page:: 486
  hl-color:: yellow
  id:: 63d11d8c-681a-4f87-9307-0c4ab8508c80
- 在这个例子中，通过给<svg>元素设置自己的命名空间，将其标识为当前文档的外来元素
  ls-type:: annotation
  hl-page:: 487
  hl-color:: yellow
  id:: 63d11e2f-9ec3-4829-988c-81dea3c60a9c
- 在节点使用命名空间前缀的情况下，nodeName 等于 prefix + ":" + localName。
  ls-type:: annotation
  hl-page:: 487
  hl-color:: yellow
  id:: 63d11ef3-b484-4ec7-a09e-d5d9bb31cdd7
- NamedNodeMap 也增加了以下处理命名空间的方法。因为 NamedNodeMap 主要表示属性，所以这些方法大都适用于属性：
  ls-type:: annotation
  hl-page:: 488
  hl-color:: yellow
  id:: 63d12088-f443-4855-a272-9574afa065c1
- publicId、 systemId 属性表示文档类型声明中有效但无法使用 DOM1 API 访问的数据
  ls-type:: annotation
  hl-page:: 489
  hl-color:: yellow
  id:: 63d12154-d159-4998-a0e0-2dcdd7eebfd2
- DOM2 Core 还针对 document.implementation 对象增加了两个新方法：createDocumentType()和 createDocument()
  ls-type:: annotation
  hl-page:: 490
  hl-color:: yellow
  id:: 63d121cc-845e-4e69-9d38-c5289b8f2c59
- DOM3 新增了两个用于比较节点的方法：isSameNode()和 isEqualNode()
  ls-type:: annotation
  hl-page:: 490
  hl-color:: yellow
  id:: 63d12275-7780-4f4f-83c4-933c8f6f666d
- 。setUserData()方法接收 3 个参数：键、值、处理函数，用于给节点追加数据
  ls-type:: annotation
  hl-page:: 491
  hl-color:: yellow
  id:: 63d1234d-b374-4723-a7bb-62c63ad1bf85
- contentDocument。这个属性包含代表子内嵌窗格中内容的 document 对象的指针
  ls-type:: annotation
  hl-page:: 491
  hl-color:: yellow
  id:: 63d123e5-dac8-4ca6-926d-6180f27323a0
- contentWindow，返回相应窗格的 window 对象
  ls-type:: annotation
  hl-page:: 491
  hl-color:: yellow
  id:: 63d1240e-f5c0-4063-8d68-19d3c1fcc381
- 样式
  ls-type:: annotation
  hl-page:: 492
  hl-color:: green
  id:: 63d12460-9bd0-4b4d-92ed-459bc24b753a
- DOM2 Style 为这 3 种应用样式的机制都提供了 API。
  ls-type:: annotation
  hl-page:: 492
  hl-color:: yellow
  id:: 63d124c7-7031-4990-8e41-ecad2d7b0289
- 存取元素样式
  ls-type:: annotation
  hl-page:: 492
  hl-color:: green
  id:: 63d12550-d146-40e2-9a9f-d9620b77b297
- 任何支持 style 属性的 HTML 元素在 JavaScript 中都会有一个对应的 style 属性。
  ls-type:: annotation
  hl-page:: 492
  hl-color:: yellow
  id:: 63d12558-a19b-4aad-b02c-e7c4271655c3
- 。因为 CSS 属性名使用连字符表示法（用连字符分隔两个单词 ， 如 background-image ）， 所 以 在 JavaScript 中 这 些 属 性 必 须 转 换 为 驼 峰 大 小 写 形 式 （ 如
  ls-type:: annotation
  hl-page:: 492
  hl-color:: yellow
  id:: 63d125f1-e07c-4eec-8bed-f7fde7dd93b0
- DOM2 Style 规定它在 style 对象中对应的属性应该是 cssFloat。
  ls-type:: annotation
  hl-page:: 492
  hl-color:: yellow
  id:: 63d12744-b0d2-4b3c-a500-8cb8ae679756
- 实践中，最好一直加上单位
  ls-type:: annotation
  hl-page:: 492
  hl-color:: yellow
  id:: 63d12793-7108-48ca-b40c-12f8081106cb
- cssText，包含 style 属性中的 CSS 代码。
  ls-type:: annotation
  hl-page:: 493
  hl-color:: yellow
  id:: 63d127e1-8661-4fc0-963d-8176715db82c
- 在写模式下，给 cssText 赋值会重写整个 style 属性的值，意味着之前通过 style 属性设置的属性都会丢失。
  ls-type:: annotation
  hl-page:: 493
  hl-color:: yellow
  id:: 63d12810-5c22-4dee-bdca-5ed92667dbf2
- getPropertyValue()方法返回 CSS 属性值的字符串表示。
  ls-type:: annotation
  hl-page:: 494
  hl-color:: yellow
  id:: 63d12830-12c8-4fb6-9d63-3f9a1a1509a3
- 。这个对象有两个属性：cssText 和 cssValueType。
  ls-type:: annotation
  hl-page:: 494
  hl-color:: yellow
  id:: 63d1283b-1847-4f90-8b29-a5b3d7d3aa86
- getPropertyCSSValue()获取 CSSValue 对象
  ls-type:: annotation
  hl-page:: 494
  hl-color:: yellow
  id:: 63d1289d-b682-4991-a6ed-95ed106d7bb4
- 。DOM2 Style 在 document.defaultView 上增加了 getComputedStyle()
  ls-type:: annotation
  hl-page:: 494
  hl-color:: yellow
  id:: 63d128c6-7248-4272-823b-3404b665762f
- 即使 computedStyle.border 在所有浏览器中都不会返回值，computedStyle.borderLeftWidth 也一定会返回值。
  ls-type:: annotation
  hl-page:: 495
  hl-color:: yellow
  id:: 63d128ff-13bb-4e67-b5da-773ef37b423b
- 关于计算样式要记住一点，在所有浏览器中计算样式都是只读的
  ls-type:: annotation
  hl-page:: 495
  hl-color:: yellow
  id:: 63d1294d-e796-4ce9-87e4-5cf664e5ef00
- style 对象中包含支持 style 属性的元素为这个属性设置的样式信息，但不包含从其他样式表层叠继承的同样影响该元素的样式信息
  ls-type:: annotation
  hl-page:: 494
  hl-color:: red
  id:: 63d129c6-ab66-4099-8dcb-a90022bb3ffe
  hl-stamp:: 1674652109072
- 操作样式表
  ls-type:: annotation
  hl-page:: 495
  hl-color:: green
  id:: 63d129d2-3cff-428e-807e-e07341a43d21
- CSSStyleSheet 类型表示 CSS 样式表，包括使用<link>元素和通过<style>元素定义的样式表。注意，这两个元素本身分别是 HTMLLinkElement 和 HTMLStyleElement
  ls-type:: annotation
  hl-page:: 495
  hl-color:: yellow
  id:: 63d129df-8579-4fd4-9771-ff572a2b9986
- document.styleSheets 表示文档中可用的样式表集合。
  ls-type:: annotation
  hl-page:: 496
  hl-color:: yellow
  id:: 63d12b29-355a-43c4-95f4-b1a8b8a34ab5
- 。IE、Opera、Chrome 也包含 rel 属性设置为"alternate stylesheet"的<link>元素。
  ls-type:: annotation
  hl-page:: 496
  hl-color:: yellow
  id:: 63d12b57-bcc8-43c1-af08-4c66351fd8e4
- CSSRule 类型表示样式表中的一条规则。这个类型也是一个通用基类
  ls-type:: annotation
  hl-page:: 496
  hl-color:: yellow
  id:: 63d12c08-c1ff-4f4d-9356-38fbcf5488d7
- CSS 规则
  ls-type:: annotation
  hl-page:: 496
  hl-color:: green
  id:: 63d12c10-54fe-48f1-95bf-d27db70bdc88
- 假设这条规则位于页面中的第一个样式表中，而且是该样式表中唯一一条 CSS 规则
  ls-type:: annotation
  hl-page:: 497
  hl-color:: yellow
  id:: 63d12c28-677f-47e7-a33a-1fe8f86561a6
- 使用这些接口，可以像确定元素 style 对象中包含的样式一样，确定一条样式规则的样式信息。与元素的场景一样，也可以修改规则中的样式
  ls-type:: annotation
  hl-page:: 497
  hl-color:: yellow
  id:: 63d12d2b-628b-4917-8c6a-d69d59f97f31
- 此外，cssText 是只读的，而 style.cssText 可以被重写
  ls-type:: annotation
  hl-page:: 496
  hl-color:: yellow
  id:: 63d12d40-5b67-469a-9347-6fc67c5d31f1
- 创建规则
  ls-type:: annotation
  hl-page:: 497
  hl-color:: green
  id:: 63d12d47-b7cb-4ef9-80e9-cdca5c831783
- 可以使用 insertRule()方法向样式表中添加新规则
  ls-type:: annotation
  hl-page:: 497
  hl-color:: yellow
  id:: 63d12d7d-d12e-4469-8c68-afa1c6c690ca
- 删除规则
  ls-type:: annotation
  hl-page:: 497
  hl-color:: green
  id:: 63d12dc8-3635-4cf9-afe2-4d06377f1fe6
- deleteRule()，它接收一个参数：要删除规则的索引
  ls-type:: annotation
  hl-page:: 497
  hl-color:: yellow
  id:: 63d12de8-4a5d-4aef-8f38-d5597cde6c41
- 元素尺寸
  ls-type:: annotation
  hl-page:: 497
  hl-color:: green
  id:: 63d12e03-3141-48cf-9814-4b6a0992a2a7
- 偏移尺寸
  ls-type:: annotation
  hl-page:: 498
  hl-color:: green
  id:: 63d12e13-0ab6-4d91-9b2a-67e0edbac2c3
- 要确定一个元素在页面中的偏移量，可以把它的 offsetLeft 和 offsetTop 属性分别与 offsetParent的相同属性相加，一直加到根元素
  ls-type:: annotation
  hl-page:: 498
  hl-color:: yellow
  id:: 63d12e79-8b5c-4a28-8c09-27282c083bae
- 包含在<div>元素中所有元素都以<body>为其 offsetParent，因此 getElementleft()和 getElementTop()返回的值与 offsetLeft 和 offsetTop 返回的值相同
  ls-type:: annotation
  hl-page:: 499
  hl-color:: yellow
  id:: 63d12e9e-a070-4e47-ab1e-8811cd42c732
- 客户端尺寸
  ls-type:: annotation
  hl-page:: 499
  hl-color:: green
  id:: 63d12ea5-a40e-4b21-8b78-5d2f2a36e98f
- 客户端尺寸实际上就是元素内部的空间，因此不包含滚动条占用的空间。这两个属性最常用于确定浏览器视口尺寸，即检测 document.documentElement 的 clientWidth 和 clientHeight
  ls-type:: annotation
  hl-page:: 499
  hl-color:: yellow
  id:: 63d12ec0-542d-463c-bd08-f9dfb6abe4ea
- 滚动尺寸
  ls-type:: annotation
  hl-page:: 500
  hl-color:: green
  id:: 63d12eec-db7b-4f75-a70b-003fdff1f032
- 如果元素在垂直方向上滚动，则 scrollTop 会大于 0，表示元素顶部不可见区域的高度
  ls-type:: annotation
  hl-page:: 500
  hl-color:: yellow
  id:: 63d12f44-5302-4366-a59e-54ff39f380c9
- 确定元素尺寸
  ls-type:: annotation
  hl-page:: 501
  hl-color:: green
  id:: 63d12f5f-8d49-4904-b25b-d01ed5e4ec1c
- 遍历
  ls-type:: annotation
  hl-page:: 501
  hl-color:: green
  id:: 63d12f72-0ba3-4bf8-b430-a5e0191adcfc
  hl-stamp:: 1674653569004
- 浏览器在每个元素上都暴露了 getBoundingClientRect()方法，返回一个 DOMRect 对象，包含6 个属性：left、top、right、bottom、height 和 width。
  ls-type:: annotation
  hl-page:: 501
  hl-color:: yellow
  id:: 63d12f79-23a8-470c-a021-5efa9ce46e62
- DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构
  ls-type:: annotation
  hl-page:: 501
  hl-color:: yellow
  id:: 63d12fc3-d0f4-4f10-a8c2-72a9b0c5671a
- 这两个类型—— NodeIterator 和 TreeWalker——从某个起点开始执行对 DOM 结构的深度优先遍历
  ls-type:: annotation
  hl-page:: 501
  hl-color:: yellow
  id:: 63d12fcf-ba0b-4746-bc89-1c41aeb6c6da
- 任何节点都可以成为遍历的根节点
  ls-type:: annotation
  hl-page:: 502
  hl-color:: yellow
  id:: 63d12ffa-f6b8-4ee2-8dc5-c536f1359daf
- NodeIterator
  ls-type:: annotation
  hl-page:: 503
  hl-color:: green
  id:: 63d13006-4f6a-46f8-8da3-a9d58f13982f
- NodeIterator 类型是两个类型中比较简单的，可以通过 document.createNodeIterator()方法创建其实例
  ls-type:: annotation
  hl-page:: 503
  hl-color:: yellow
  id:: 63d13026-a742-40b3-b562-6c425912eb6a
- filter 参数可以用来指定自定义 NodeFilter 对象，或者一个作为节点过滤器的函数。
  ls-type:: annotation
  hl-page:: 503
  hl-color:: yellow
  id:: 63d130ac-a191-4c67-ac7e-73d727d2a3ae
- 通常，JavaScript 会使用这种形式，因为更简单也更像普通 JavaScript 代码。
  ls-type:: annotation
  hl-page:: 504
  hl-color:: yellow
  id:: 63d13129-d26f-4aab-b441-ffca0f5b6745
- 这个例子中第一次调用 nextNode()返回<div>元素
  ls-type:: annotation
  hl-page:: 504
  hl-color:: yellow
  id:: 63d13156-60e3-46ad-a58b-970d0e9fb488
- NodeIterator 的两个主要方法是 nextNode()和 previousNode()。
  ls-type:: annotation
  hl-page:: 504
  hl-color:: yellow
  id:: 63d131b8-705c-4c73-bda5-e64ee3f36899
- TreeWalker
  ls-type:: annotation
  hl-page:: 505
  hl-color:: green
  id:: 63d131dc-3d34-419e-8cf2-86c9cf775b54
- TreeWalker 对 象 要 调 用 document.createTreeWalker() 方 法 来 创 建 ，
  ls-type:: annotation
  hl-page:: 505
  hl-color:: yellow
  id:: 63d13202-8728-4697-862a-0aa18ade29e8
- 节点过滤器（filter）除了可以返回 NodeFilter.FILTER_ACCEPT 和 NodeFilter. FILTER_SKIP，还可以返回 NodeFilter.FILTER_REJECT
  ls-type:: annotation
  hl-page:: 506
  hl-color:: yellow
  id:: 63d13228-c479-42b1-985a-557c920a7283
- NodeFilter.FILTER_REJECT 则表示跳过该节点以及该节点的整个子树。
  ls-type:: annotation
  hl-page:: 506
  hl-color:: yellow
  id:: 63d1324e-56c8-46e1-81fd-9a527931b8a0
- 注意，此时的 TreeWalker 只返回元素（这是因为传给 createTreeWalker()的第二个参数）。最后就可以使用 nextSibling()访问每个<li>元素，直到再也没有元素，此时方法返回 null。
  ls-type:: annotation
  hl-page:: 506
  hl-color:: yellow
  id:: 63d1327d-1dd5-4aba-b6e3-fff045462dc3
- currentNode 的属性，表示遍历过程中上一次返回的节点
  ls-type:: annotation
  hl-page:: 506
  hl-color:: yellow
  id:: 63d13283-b284-49b0-a273-cce93025889d
- 范围
  ls-type:: annotation
  hl-page:: 506
  hl-color:: green
  id:: 63d13305-1796-4ff0-aca7-b44c7f048f27
- DOM 范围
  ls-type:: annotation
  hl-page:: 507
  hl-color:: green
  id:: 63d13312-d43c-4ce0-b26a-414aa309fdfa
- DOM2 在 Document 类型上定义了一个 createRange()方法，暴露在 document 对象上。
  ls-type:: annotation
  hl-page:: 507
  hl-color:: yellow
  id:: 63d13320-5c2d-4add-8fc1-938ea67da783
- 每个范围都是 Range 类型的实例，拥有相应的属性和方法
  ls-type:: annotation
  hl-page:: 507
  hl-color:: yellow
  id:: 63d13361-b6f9-484c-935e-39c1f65c3b9a
- 简单选择
  ls-type:: annotation
  hl-page:: 507
  hl-color:: green
  id:: 63d13383-7aa9-4b7b-980f-122363dd2568
- 最简单的方式，就是使用 selectNode()或 selectNodeContents()方法
  ls-type:: annotation
  hl-page:: 507
  hl-color:: yellow
  id:: 63d133a7-2cf1-46c2-91e6-d239302f255f
- 。selectNode()方法选择整个节点，包括其后代节点
  ls-type:: annotation
  hl-page:: 507
  hl-color:: yellow
  id:: 63d133ca-87b4-44f2-ab8d-980c7b716ad4
- selectNodeContents()只选择节点的后代
  ls-type:: annotation
  hl-page:: 507
  hl-color:: yellow
  id:: 63d133d1-91bd-426e-bbd2-e59fb4cee9b8
- 调用 selectNode()时，startContainer、endContainer 和 commonAncestorContainer 都等于传入节点的父节点。
  ls-type:: annotation
  hl-page:: 508
  hl-color:: yellow
  id:: 63d134e4-b8aa-44a5-b060-e284ab772a58
- 在调用 selectNodeContents()时，startContainer、endContainer 和 commonAncestor Container 属性就是传入的节点
  ls-type:: annotation
  hl-page:: 508
  hl-color:: yellow
  id:: 63d13523-4bff-45df-93bd-b9dce54a912b
- setStartAfter(refNode)，把范围的起点设置到 refNode 之后，从而将 refNode 排除在选区之外，让其下一个同胞节点成为选区的第一个子节点
  ls-type:: annotation
  hl-page:: 508
  hl-color:: yellow
  id:: 63d13588-dc77-4f77-887a-4fc4478dc1d1
- 复杂选择
  ls-type:: annotation
  hl-page:: 508
  hl-color:: green
  id:: 63d135a3-c48d-4d4a-a54d-6d58fa93400b
- 要创建复杂的范围，需要使用 setStart()和 setEnd()方法。这两个方法都接收两个参数：参照节点和偏移量
  ls-type:: annotation
  hl-page:: 508
  hl-color:: yellow
  id:: 63d135b4-8e95-4998-a225-47775b0613a8
- 要选择节点（使用 range1），必须先确定给定节点（p1）在其父节点 childNodes 集合中的索引
  ls-type:: annotation
  hl-page:: 509
  hl-color:: yellow
  id:: 63d1376e-a8ea-41e1-8ef8-b5a9352e7362
- 但 setStart()和 setEnd()真正的威力还是选择节点中的某个部分。
  ls-type:: annotation
  hl-page:: 509
  hl-color:: yellow
  id:: 63d137d0-24f7-499c-8c51-8b51a22d227c
- 因为 helloNode 和 worldNode 是文本节点，所以它们会成为范围的 startContainer 和 endContainer，
  ls-type:: annotation
  hl-page:: 509
  hl-color:: yellow
  id:: 63d13857-2e41-4c42-85e5-193a272e1035
- 操作范围
  ls-type:: annotation
  hl-page:: 509
  hl-color:: green
  id:: 63d138d7-2bc3-4531-bab0-f9cb578a5bb3
- 创建范围之后，浏览器会在内部创建一个文档片段节点，用于包含范围选区中的节点
  ls-type:: annotation
  hl-page:: 509
  hl-color:: yellow
  id:: 63d138ec-30b5-418e-9cc3-2e4478fc2891
- 不过，范围能够确定缺失的开始和结束标签，从而可以重构出有效的 DOM 结构，以便后续操作
  ls-type:: annotation
  hl-page:: 509
  hl-color:: yellow
  id:: 63d138fa-04d1-44d8-b5c9-dd7d1725d581
- 同时还需要补上封闭"He"的结束标签</b>
  ls-type:: annotation
  hl-page:: 510
  hl-color:: yellow
  id:: 63d13929-6e80-4555-a958-481c5f85e20b
- ：deleteContents()。顾名思义，这个方法会从文档中删除范围包含的节点
  ls-type:: annotation
  hl-page:: 510
  hl-color:: yellow
  id:: 63d13966-596c-46b2-9480-e984433e103d
- extractContents()跟 deleteContents()类似，也会从文档中移除范围选区。但不同的是，extractContents()方法返回范围对应的文档片段。这样，就可以把范围选中的内容插入文档中其他地方
  ls-type:: annotation
  hl-page:: 510
  hl-color:: yellow
  id:: 63d13a06-db29-4322-be32-20a70212a29e
- 使用 cloneContents()创建一个副本
  ls-type:: annotation
  hl-page:: 511
  hl-color:: yellow
  id:: 63d13a1e-53ac-42ed-afed-a7fffc40cee6
- cloneContents()返回的文档片段包含范围中节点的副本，而非实际的节点
  ls-type:: annotation
  hl-page:: 511
  hl-color:: yellow
  id:: 63d13a27-fb23-4282-aed0-8a1541488b74
- 范围插入
  ls-type:: annotation
  hl-page:: 511
  hl-color:: green
  id:: 63d13a54-2672-42a3-863e-3418f8d2e6e0
- <span>正好插入到"Hello"中的"llo"之前，也就是范围选区的前面。同时，也要注意原始的 HTML 并没有添加或删除<b>元素，因为这里并没有使用之前提到的方法
  ls-type:: annotation
  hl-page:: 512
  hl-color:: yellow
  id:: 63d13ac9-5c9f-43e8-9fa5-0232bc2a3f95
- 使用 surroundContents()方法插入包含范围的内容。这个方法接收一个参数，即包含范围内容的节点
  ls-type:: annotation
  hl-page:: 512
  hl-color:: yellow
  id:: 63d13b3e-3b41-455e-8926-6ef78b6a3e80
- 为了插入<span>元素，范围中必须包含完整的 DOM 结构
  ls-type:: annotation
  hl-page:: 512
  hl-color:: yellow
  id:: 63d13bbf-dbfe-40a0-8824-452e5a73ac54
- 范围折叠
  ls-type:: annotation
  hl-page:: 512
  hl-color:: green
  id:: 63d13bd4-09c8-4afc-a7fd-cca168116223
- 如果范围并没有选择文档的任何部分，则称为折叠（collapsed）
  ls-type:: annotation
  hl-page:: 512
  hl-color:: yellow
  id:: 63d13bdd-7e01-4f81-92e1-879c0eea963f
- 折叠范围可以使用 collapse()方法，这个方法接收一个参数：布尔值，表示折叠到范围哪一端。
  ls-type:: annotation
  hl-page:: 513
  hl-color:: yellow
  id:: 63d13c57-e9f0-499c-8e94-267642b68d8e
- 要确定范围是否已经被折叠，可以检测范围的 collapsed属性：
  ls-type:: annotation
  hl-page:: 513
  hl-color:: yellow
  id:: 63d13c63-05c4-4bb6-9479-83203fd53459
- 测试范围是否被折叠，能够帮助确定范围中的两个节点是否相邻
  ls-type:: annotation
  hl-page:: 513
  hl-color:: yellow
  id:: 63d13c9c-d4fa-42cd-97d8-73fc5e20e976
- 范围比较
  ls-type:: annotation
  hl-page:: 513
  hl-color:: green
  id:: 63d13ca2-a28e-4219-9a11-ed8b43b4fe43
- 如果有多个范围，则可以使用 compareBoundaryPoints()方法确定范围之间是否存在公共的边界（起点或终点）
  ls-type:: annotation
  hl-page:: 513
  hl-color:: yellow
  id:: 63d13cc3-38c4-4e4d-9592-3a028087fc67
- ，因为它们都是 selectNodeContents()默认返回的值
  ls-type:: annotation
  hl-page:: 513
  hl-color:: yellow
  id:: 63d13d3b-6aa7-4050-9910-e0b8e535c7b7
- 复制范围
  ls-type:: annotation
  hl-page:: 514
  hl-color:: green
  id:: 63d13d45-8590-4fda-b28c-aa19c7a110ae
- 调用范围的 cloneRange()方法可以复制范围
  ls-type:: annotation
  hl-page:: 514
  hl-color:: yellow
  id:: 63d13d72-75d0-4675-b1d7-5a917faa965e
- 清理
  ls-type:: annotation
  hl-page:: 514
  hl-color:: green
  id:: 63d13d9a-0a9c-4e7e-8bdf-6e67a0b22410
- 最好调用 detach()方法把范围从创建它的文档中剥离。调用 detach()之后，就可以放心解除对范围的引用
  ls-type:: annotation
  hl-page:: 514
  hl-color:: yellow
  id:: 63d13da6-a01c-40ef-83e9-e600958fe7d1
- 事件流
  ls-type:: annotation
  hl-page:: 515
  hl-color:: green
  id:: 63d13dd5-cd53-4964-9f17-f4a6a6917c76
- 当你点击一个按钮时，实际上不光点击了这个按钮，还点击了它的容器以及整个页面。
  ls-type:: annotation
  hl-page:: 515
  hl-color:: yellow
  id:: 63d1d1f1-fa9a-4a66-8b76-fe718b21f770
- 事件冒泡
  ls-type:: annotation
  hl-page:: 515
  hl-color:: green
  id:: 63d1d203-960f-4762-b5c6-a79d5ddfda1e
- 事件被定义为从最具体的元素（文档树中最深的节点）开始触发，然后向上传播至没有那么具体的元素（文档）
  ls-type:: annotation
  hl-page:: 515
  hl-color:: yellow
  id:: 63d1d23f-2748-44a5-aebb-10626b1bd129
- 事件捕获
  ls-type:: annotation
  hl-page:: 516
  hl-color:: green
  id:: 63d1d268-45a1-44b0-9765-9d1f90248b33
- 最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件
  ls-type:: annotation
  hl-page:: 516
  hl-color:: yellow
  id:: 63d1d27d-4765-4d44-9dda-d8e2bd2abe42
- 事件捕获得到了所有现代浏览器的支持
  ls-type:: annotation
  hl-page:: 516
  hl-color:: yellow
  id:: 63d1d294-7023-486d-bd80-b2b0ed88c7bc
- DOM 事件流
  ls-type:: annotation
  hl-page:: 517
  hl-color:: green
  id:: 63d1d2c9-4fde-4924-8883-74b096050b2c
- 为 3 个阶段：事件捕获、到达目标和事件冒泡
  ls-type:: annotation
  hl-page:: 517
  hl-color:: yellow
  id:: 63d1d2e2-397e-4c52-a68f-881e22e57652
- 事件处理程序
  ls-type:: annotation
  hl-page:: 518
  hl-color:: green
  id:: 63d1d2fe-0c20-4d5d-9e0a-f35bbedd1f72
- 为响应事件而调用的函数被称为事件处理程序（或事件监听器）
  ls-type:: annotation
  hl-page:: 518
  hl-color:: yellow
  id:: 63d1d323-e671-444b-ae6f-0ee514f297b4
- HTML 事件处理程序
  ls-type:: annotation
  hl-page:: 518
  hl-color:: green
  id:: 63d1d32b-9277-431d-b937-62d2dd73d67e
- 在 HTML 中定义的事件处理程序可以包含精确的动作指令，也可以调用在页面其他地方定义的脚本，
  ls-type:: annotation
  hl-page:: 518
  hl-color:: yellow
  id:: 63d1d35e-2c48-4af6-859b-af9f5105cb6d
- 。这个函数有一个特殊的局部变量 event，其中保存的就是 event 对象
  ls-type:: annotation
  hl-page:: 518
  hl-color:: yellow
  id:: 63d1d394-4796-4fc6-9ca2-73e29e56e6e8
- 这也是很多开发者不使用 HTML事件处理程序，而使用 JavaScript 指定事件处理程序的主要原因
  ls-type:: annotation
  hl-page:: 519
  hl-color:: yellow
  id:: 63d1d41d-42b8-480d-9842-89a0a0dfba69
- DOM0 事件处理程序
  ls-type:: annotation
  hl-page:: 520
  hl-color:: green
  id:: 63d1d444-7e60-4db5-9276-53ba31738239
- 传统方式是把一个函数赋值给（DOM 元素的）一个事件处理程序属性
  ls-type:: annotation
  hl-page:: 520
  hl-color:: yellow
  id:: 63d1d473-021e-4a0f-a7e3-0aa890cb2758
- 每个元素（包括 window 和 document）都有通常小写的事件处理程序属性，比如 onclick。只要把这个属性赋值为一个函数
  ls-type:: annotation
  hl-page:: 520
  hl-color:: yellow
  id:: 63d1d4bf-9559-422a-af9f-daa43d9731cc
- 这里先从文档中取得按钮，然后给它的 onclick 事件处理程序赋值一个函数
  ls-type:: annotation
  hl-page:: 520
  hl-color:: yellow
  id:: 63d1d4e6-5094-414a-a9ef-f329d332ac56
- 通过将事件处理程序属性的值设置为 null，可以移除通过 DOM0 方式添加的事件处理程序
  ls-type:: annotation
  hl-page:: 520
  hl-color:: yellow
  id:: 63d1d52a-e125-4e17-a1da-3ab2116e3d62
- DOM2 事件处理程序
  ls-type:: annotation
  hl-page:: 520
  hl-color:: green
  id:: 63d1d53b-44cf-46aa-ac27-dd279e414883
- 两个方法：addEventListener()和 removeEventListener()。
  ls-type:: annotation
  hl-page:: 520
  hl-color:: yellow
  id:: 63d1d561-750b-48e6-b34a-611f9dd2f876
- 接收 3 个参数：事件名、事件处理函数和一个布尔值，true 表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事件处理程序
  ls-type:: annotation
  hl-page:: 520
  hl-color:: yellow
  id:: 63d1d583-4278-40b7-9ae5-de078459e832
- 使用 DOM2方式的主要优势是可以为同一个事件添加多个事件处理程序
  ls-type:: annotation
  hl-page:: 521
  hl-color:: yellow
  id:: 63d1d5bf-468e-487d-b035-5486a04b7b1e
- 通过 addEventListener()添加的事件处理程序只能使用 removeEventListener()并传入与添加时同样的参数来移除
  ls-type:: annotation
  hl-page:: 521
  hl-color:: yellow
  id:: 63d1d5db-6be0-45c0-91d0-4ae53f603b5c
- 传给 removeEventListener()的事件处理函数必须与传给 addEventListener()的是同一个
  ls-type:: annotation
  hl-page:: 521
  hl-color:: yellow
  id:: 63d1d5f7-6406-4694-82b3-04e902a51caf
- 事件处理程序会被添加到事件流的冒泡阶段
  ls-type:: annotation
  hl-page:: 521
  hl-color:: yellow
  id:: 63d1d620-a147-4a3b-b551-0eb113ae0a2a
- 把事件处理程序注册到捕获阶段通常用于在事件到达其指定目标之前拦截事件
  ls-type:: annotation
  hl-page:: 521
  hl-color:: yellow
  id:: 63d1d62b-d711-491c-87c7-b977ffe4d37f
- IE 事件处理程序
  ls-type:: annotation
  hl-page:: 522
  hl-color:: green
  id:: 63d1d63a-0d1b-4751-8320-2d8e66658384
- IE 实现了与 DOM 类似的方法，即 attachEvent()和 detachEvent()
  ls-type:: annotation
  hl-page:: 522
  hl-color:: yellow
  id:: 63d1d663-3afd-4109-8ae5-d1bcdd492f12
- 。使用 DOM0方式时，事件处理程序中的 this 值等于目标元素
  ls-type:: annotation
  hl-page:: 522
  hl-color:: yellow
  id:: 63d1d69a-1d8e-4056-bcf7-36451d3b8b62
- 使用 attachEvent()时，事件处理程序是在全局作用域中运行的，因此 this 等于 window
  ls-type:: annotation
  hl-page:: 522
  hl-color:: yellow
  id:: 63d1d6a1-9da6-41eb-846f-367e272f2193
- ，与 DOM 方法不同，这里的事件处理程序会以添加它们的顺序反向触
  ls-type:: annotation
  hl-page:: 522
  hl-color:: yellow
  id:: 63d1d6e7-3975-4205-9d40-c83b148ef48c
- 使用 attachEvent()添加的事件处理程序将使用 detachEvent()来移除，只要提供相同的参数
  ls-type:: annotation
  hl-page:: 522
  hl-color:: yellow
  id:: 63d1d6f6-b261-491a-8569-f67f7af19c80
- 跨浏览器事件处理程序
  ls-type:: annotation
  hl-page:: 523
  hl-color:: green
  id:: 63d1d704-bf00-420f-bf4a-017cf5913735
- 添加的这个 addHandler()方法接收 3 个参数：目标元素、事件名和事件处理函数
  ls-type:: annotation
  hl-page:: 523
  hl-color:: yellow
  id:: 63d1d726-2f83-4732-92b8-22966a2c66a8
- 这个方法会在 EventUtil 对象（本章示例使用的对象）上添加一个方法，以实现跨浏览器事件处理
  ls-type:: annotation
  hl-page:: 523
  hl-color:: yellow
  id:: 63d1d77c-e0b9-4044-8685-c80a89709d5c
- 则，如果存在 IE 方式，则使用该方式。注意这时候必须在事件类型前加上"on"，才能保证在 IE8 及更早版本中有效
  ls-type:: annotation
  hl-page:: 523
  hl-color:: yellow
  id:: 63d1d7bf-2ea2-4c0b-bc57-c6ab2698d76a
- 里的 addHandler()和 removeHandler()方法并没有解决所有跨浏览器一致性问题，比如 IE的作用域问题、多个事件处理程序执行顺序问题等
  ls-type:: annotation
  hl-page:: 524
  hl-color:: yellow
  id:: 63d1d813-ac06-41b3-b8f2-97a9d151e90c
- 事件对象
  ls-type:: annotation
  hl-page:: 524
  hl-color:: green
  id:: 63d1d818-870f-4042-a77b-640d7fe138d7
- 这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据。
  ls-type:: annotation
  hl-page:: 524
  hl-color:: yellow
  id:: 63d1d85e-317e-4415-b580-51f9aa1e2bb3
- DOM 事件对象
  ls-type:: annotation
  hl-page:: 524
  hl-color:: green
  id:: 63d1d86f-1568-4357-9eae-3b6046e642e1
- event 对象是传给事件处理程序的唯一参数
  ls-type:: annotation
  hl-page:: 524
  hl-color:: yellow
  id:: 63d1d8dd-eaba-44bd-9484-ee77b271a105
- 在通过 HTML 属性指定的事件处理程序中，同样可以使用变量 event 引用事件对象
  ls-type:: annotation
  hl-page:: 524
  hl-color:: yellow
  id:: 63d1d8f2-3091-4ec8-88fb-40e7d12ddf28
- 在事件处理程序内部，this 对象始终等于 currentTarget 的值，而 target 只包含事件的实际目标。
  ls-type:: annotation
  hl-page:: 525
  hl-color:: yellow
  id:: 63d1d91c-c0a6-45c0-812d-a687198c799c
- 比如下面的例子在 document.body 上添加了单击处理程序：
  ls-type:: annotation
  hl-page:: 525
  hl-color:: yellow
  id:: 63d1d97c-ab1c-4dc7-84c9-13aac1415a92
- 这个函数使用 event.type属性确定了事件类型，从而可以做出不同的响应
  ls-type:: annotation
  hl-page:: 526
  hl-color:: yellow
  id:: 63d1d9d0-f801-489d-9761-8133723359c4
- preventDefault()方法用于阻止特定事件的默认动作
  ls-type:: annotation
  hl-page:: 526
  hl-color:: yellow
  id:: 63d1d9f5-740a-4971-9c12-eb61bc728a9a
- 任何可以通过 preventDefault()取消默认行为的事件，其事件对象的 cancelable 属性都会设置为 true。
  ls-type:: annotation
  hl-page:: 526
  hl-color:: yellow
  id:: 63d1da3b-5a8e-4bb0-add2-d9283e02108a
- stopPropagation()方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件捕获或冒泡
  ls-type:: annotation
  hl-page:: 526
  hl-color:: yellow
  id:: 63d1da44-c4f8-4010-bc5c-f3268973f9b7
- eventPhase 属性可用于确定事件流当前所处的阶段
  ls-type:: annotation
  hl-page:: 526
  hl-color:: yellow
  id:: 63d1da8a-03f5-479e-80b4-bb9c55e5691f
- 而当 eventPhase 等于 2 时，this、target 和 currentTarget 三者相等
  ls-type:: annotation
  hl-page:: 527
  hl-color:: yellow
  id:: 63d1db07-df35-48be-870e-75a033451812
- IE 事件对象
  ls-type:: annotation
  hl-page:: 527
  hl-color:: green
  id:: 63d1db31-7f17-40ab-8e91-d1f8c8d60453
- 事件处理程序在捕获阶段被调用，则 eventPhase 等于 1
  ls-type:: annotation
  hl-page:: 526
  hl-color:: yellow
  id:: 63d1dbc2-a2e7-423f-b307-4b3583c0ca7e
- 事件处理程序在目标上被调用，则 eventPhase 等于 2
  ls-type:: annotation
  hl-page:: 526
  hl-color:: yellow
  id:: 63d1dbc9-cf24-41d9-ab65-4c4755eadb48
- 事件处理程序在冒泡阶段被调用，则 eventPhase 等于 3
  ls-type:: annotation
  hl-page:: 526
  hl-color:: yellow
  id:: 63d1dbcf-92d6-4c0d-bf56-6da2ba0b0ed1
- 如果事件处理程序是使用 DOM0 方式指定的，则 event 对象只是 window 对象的一个属性
  ls-type:: annotation
  hl-page:: 527
  hl-color:: yellow
  id:: 63d1dc4f-eef3-4327-a425-b012c3f7c25f
- 如果事件处理程序是使用 attachEvent()指定的，则 event对象会作为唯一的参数传给处理函数
  ls-type:: annotation
  hl-page:: 527
  hl-color:: yellow
  id:: 63d1dc83-4b14-42e0-8f99-d2e3aa204790
- 使用 attachEvent()时，event 对象仍然是 window 对象的属性（像 DOM0 方式那样），只是出于方便也将其作为参数传入
  ls-type:: annotation
  hl-page:: 527
  hl-color:: yellow
  id:: 63d1dd03-05a3-49f9-920b-aa938ca4f1ca
- returnValue 属性等价于 DOM 的 preventDefault()方法，都是用于取消给定事件默认的行为
  ls-type:: annotation
  hl-page:: 528
  hl-color:: yellow
  id:: 63d1ddc1-2e7f-4469-b8f8-5266eeb06151
- cancelBubble 属性与 DOMstopPropagation()方法用途一样，都可以阻止事件冒泡
  ls-type:: annotation
  hl-page:: 528
  hl-color:: yellow
  id:: 63d1ddd5-4419-4d4f-93a9-d4a040e783c4
- 通过在按钮的 onclick 事件处理程序中将 cancelBubble 设置为 true，可以阻止事件冒泡到 document.body，也就阻止了调用注册在它上面的事件处理程序。
  ls-type:: annotation
  hl-page:: 528
  hl-color:: yellow
  id:: 63d1ddf6-143d-4c03-94c8-cdda2103a325
- 跨浏览器事件对象
  ls-type:: annotation
  hl-page:: 528
  hl-color:: green
  id:: 63d1de2e-22e8-497c-8ca7-379e78e0c8e7
- getEvent()，其返回对 event 对象的引用。 IE 中事件对象的位置不同，而使用这个方法可以不用管事件处理程序是如何指定的
  ls-type:: annotation
  hl-page:: 529
  hl-color:: yellow
  id:: 63d1deb0-ad40-4c20-8525-75b4a6e2dc05
- getTarget()，其返回事件目标。在这个方法中
  ls-type:: annotation
  hl-page:: 529
  hl-color:: yellow
  id:: 63d1df18-c8fc-4589-af42-f11e2fad0fe7
- preventDefault()，其用于阻止事件的默认行为
  ls-type:: annotation
  hl-page:: 530
  hl-color:: yellow
  id:: 63d1df53-a5e3-4a92-bec0-869c36ce593c
- 第四个方法 stopPropagation()以类似的方式运行。同样先检测用于停止事件流的 DOM 方法
  ls-type:: annotation
  hl-page:: 530
  hl-color:: yellow
  id:: 63d1df8b-206b-4471-accc-ab260ee579fe
- 事件类型
  ls-type:: annotation
  hl-page:: 530
  hl-color:: green
  id:: 63d1dfa6-26d0-4e34-8b5d-6ab9098ed369
- DOM3 Events 定义了如下事件类型。
  ls-type:: annotation
  hl-page:: 530
  hl-color:: yellow
  id:: 63d1dfba-7a23-472d-afdb-b3f2b77def49
- 用户界面事件
  ls-type:: annotation
  hl-page:: 531
  hl-color:: green
  id:: 63d1e06d-9242-440a-bff2-5433d55154da
- DOMActivate：元素被用户通过鼠标或键盘操作激活时触发（比 click 或 keydown 更通用）。
  ls-type:: annotation
  hl-page:: 531
  hl-color:: yellow
  id:: 63d1e0bb-9537-4d1a-abd0-934221901298
- load：在 window 上当页面加载完成后触发
  ls-type:: annotation
  hl-page:: 531
  hl-color:: yellow
  id:: 63d1e0cc-c28a-45af-abb9-7642bcd1927b
- unload：在 window 上当页面完全卸载后触发
  ls-type:: annotation
  hl-page:: 531
  hl-color:: yellow
  id:: 63d1e0d1-5987-4823-9cd5-96da205c7cda
- abort：在<object>元素上当相应对象加载完成前被用户提前终止下载时触发
  ls-type:: annotation
  hl-page:: 531
  hl-color:: yellow
  id:: 63d1e0d6-0811-4a29-81a3-5599699e6d7f
- error：在 window 上当 JavaScript 报错时触发
  ls-type:: annotation
  hl-page:: 531
  hl-color:: yellow
  id:: 63d1e0db-4963-492c-9e0a-0372ab261180
- select：在文本框（<input>或 textarea）上当用户选择了一个或多个字符时触发
  ls-type:: annotation
  hl-page:: 531
  hl-color:: yellow
  id:: 63d1e116-a18a-4b8d-8f88-81d8ceb66f80
- resize：在 window 或窗格上当窗口或窗格被缩放时触发
  ls-type:: annotation
  hl-page:: 531
  hl-color:: yellow
  id:: 63d1e118-075a-4dd2-bbe3-318788003dfc
- scroll：当用户滚动包含滚动条的元素时在元素上触发
  ls-type:: annotation
  hl-page:: 531
  hl-color:: yellow
  id:: 63d1e11d-fae2-499f-ba55-9a0e14abbade
- 在 window 对象上，load 事件会在整个页面（包括所有外部资源如图片、JavaScript 文件和 CSS 文件）加载完成后触发
  ls-type:: annotation
  hl-page:: 531
  hl-color:: yellow
  id:: 63d1e12d-e7e0-4aab-b019-e84c057012ae
- 第一种是 JavaScript 方式
  ls-type:: annotation
  hl-page:: 531
  hl-color:: yellow
  id:: 63d1e486-f1c5-4992-8340-418ca844e844
- 第二种指定 load 事件处理程序的方式是向<body>元素添加 onload 属性
  ls-type:: annotation
  hl-page:: 531
  hl-color:: yellow
  id:: 63d1e48f-735b-4e59-b400-84032d30b5ec
- 在通过 JavaScript 创建新<img>元素时，也可以给这个元素指定一个在加载完成后执行的事件处理程序。
  ls-type:: annotation
  hl-page:: 532
  hl-color:: yellow
  id:: 63d1e4cd-8049-4d75-83b7-ec79e34f83a6
- 这里调用 Image 构造函数创建了一个新图片，并给它设置了事件处理程序
  ls-type:: annotation
  hl-page:: 533
  hl-color:: yellow
  id:: 63d1e520-7b7c-49e3-86ca-72e9fe264cba
- <script>元素会在 JavaScript 文件加载完成后触发 load 事件，从而可以动态检测
  ls-type:: annotation
  hl-page:: 533
  hl-color:: yellow
  id:: 63d1e528-9745-4d47-a3df-e1dc92bfac1b
- IE 和 Opera 支持<link>元素触发 load 事件，因而支持动态检测样式表是否加载完成。
  ls-type:: annotation
  hl-page:: 533
  hl-color:: yellow
  id:: 63d1e56b-4b2f-475e-8450-84ed6f06b7ae
- 在指定 href 属性并把<link>节点添加到文档之前不会下载样式表
  ls-type:: annotation
  hl-page:: 533
  hl-color:: yellow
  id:: 63d1e590-8c3a-438a-93cf-d6d4b91e6de1
- unload 事件
  ls-type:: annotation
  hl-page:: 533
  hl-color:: green
  id:: 63d1e5a6-e1c8-4a01-bd0d-d2c91ba887ce
- ，unload 事件会在文档卸载完成后触发
  ls-type:: annotation
  hl-page:: 533
  hl-color:: yellow
  id:: 63d1e5b8-02d9-4fa2-bc28-1dfe6a0ac634
- unload 事件一般是在从一个页面导航到另一个页面时触发，最常用于清理引用，以避免内存泄漏
  ls-type:: annotation
  hl-page:: 533
  hl-color:: yellow
  id:: 63d1e5c0-84e3-45f2-b90c-8b322be2611a
- 第一种是 JavaScript 方式
  ls-type:: annotation
  hl-page:: 533
  hl-color:: yellow
  id:: 63d1e5c9-76c8-475c-8de3-abf84102ae51
- 第二种方式与 load 事件类似，就是给<body>元素添加 onunload 属性
  ls-type:: annotation
  hl-page:: 534
  hl-color:: yellow
  id:: 63d1e5d3-be7a-44cf-8d86-dd7486e00d2c
- resize 事件
  ls-type:: annotation
  hl-page:: 534
  hl-color:: green
  id:: 63d1e5e8-9612-45c3-9deb-50ef8e518967
- 当浏览器窗口被缩放到新高度或宽度时，会触发 resize 事件。这个事件在 window 上触发
  ls-type:: annotation
  hl-page:: 534
  hl-color:: yellow
  id:: 63d1e604-253b-49ba-b8fc-31034e4ad3d4
- 浏览器窗口在最大化和最小化时也会触发 resize 事件。
  ls-type:: annotation
  hl-page:: 534
  hl-color:: yellow
  id:: 63d1e634-4404-44ba-ba30-c6f3028aaa50
- scroll 事件
  ls-type:: annotation
  hl-page:: 534
  hl-color:: green
  id:: 63d1e639-57dc-473b-b9f5-b25dd6809b0b
- 焦点事件
  ls-type:: annotation
  hl-page:: 535
  hl-color:: green
  id:: 63d1e65d-8158-40a7-94aa-dbb4848e651b
- 些 事 件 可 以 与 document.hasFocus() 和 document.activeElement 一起为开发者提供用户在页面中导航的信息
  ls-type:: annotation
  hl-page:: 535
  hl-color:: yellow
  id:: 63d1e66c-ae7b-44e0-8739-bf851dfd8faf
- 焦点事件中的两个主要事件是 focus 和 blur
  ls-type:: annotation
  hl-page:: 535
  hl-color:: yellow
  id:: 63d1e685-a29b-4f35-8d63-5cc4c2fceaf7
- ，blur、DOMFocusOut 和 focusout 的事件目标是失去焦点的元素，而 focus、DOMFocusIn和 focusin 的事件目标是获得焦点的元素
  ls-type:: annotation
  hl-page:: 535
  hl-color:: yellow
  id:: 63d1e6af-1e6f-431f-9386-8381e71d0ede
- 鼠标和滚轮事件
  ls-type:: annotation
  hl-page:: 535
  hl-color:: green
  id:: 63d1e6b6-d2d4-4361-84d4-cd6c3541c8be
- 页面中的所有元素都支持鼠标事件
  ls-type:: annotation
  hl-page:: 536
  hl-color:: yellow
  id:: 63d1e702-1c1c-468c-a21b-9541e471bc27
- 除了 mouseenter 和 mouseleave，所有鼠标事件都会冒泡，都可以被取消，而这会影响浏览器的默认行为
  ls-type:: annotation
  hl-page:: 536
  hl-color:: yellow
  id:: 63d1e707-2253-4323-b817-e261cc48f246
- 客户端坐标
  ls-type:: annotation
  hl-page:: 536
  hl-color:: green
  id:: 63d1e7de-2d42-4f9b-b346-9e803eb723d1
- 页面坐标
  ls-type:: annotation
  hl-page:: 537
  hl-color:: green
  id:: 63d1e845-6716-416a-852b-ac6692043c53
- 面坐标是事件发生时鼠标光标在页面上的坐标，通过 event 对象的 pageX 和 pageY 可以获取
  ls-type:: annotation
  hl-page:: 537
  hl-color:: yellow
  id:: 63d1e85c-16fa-43a2-8f99-bf8ed68d64b6
- 屏幕坐标
  ls-type:: annotation
  hl-page:: 538
  hl-color:: green
  id:: 63d1e865-f86a-43c1-81e5-be6a5020a051
- 可以通过 event 对象的 screenX 和 screenY 属性获取鼠标光标在屏幕上的坐标
  ls-type:: annotation
  hl-page:: 538
  hl-color:: yellow
  id:: 63d1e873-5263-4d19-8001-9e9ec8dd60c2
- 修饰键
  ls-type:: annotation
  hl-page:: 539
  hl-color:: green
  id:: 63d1e87b-09b2-4dfa-8dbd-cbe7056f3997
- shiftKey、ctrlKey、altKey 和 metaKey。这几属性会在各自对应的修饰键被按下时包含布尔值 true，没有被按下时包含 false。
  ls-type:: annotation
  hl-page:: 539
  hl-color:: yellow
  id:: 63d1e922-07a7-406f-a368-f6c8518ee9ee
- 相关元素
  ls-type:: annotation
  hl-page:: 539
  hl-color:: green
  id:: 63d1e954-61ab-429b-8f2d-b4f6ab759b84
- DOM 通过 event 对象的 relatedTarget 属性提供了相关元素的信息。
  ls-type:: annotation
  hl-page:: 540
  hl-color:: yellow
  id:: 63d1e96f-335d-4cd1-a332-7a93add88201
- IE会提供 fromElement 属性
  ls-type:: annotation
  hl-page:: 540
  hl-color:: yellow
  id:: 63d1e9a1-6dd8-478c-a672-259e74d1b5ca
- E 会提供 toElement属性，其中包含相关元素
  ls-type:: annotation
  hl-page:: 540
  hl-color:: yellow
  id:: 63d1e9a5-43ae-418b-884d-2156f0841d84
- 个方法同样使用特性检测来确定要返回哪个值。可以像下面这样使用 EventUtil.getRelatedTarget()方法
  ls-type:: annotation
  hl-page:: 540
  hl-color:: yellow
  id:: 63d1e9c8-8223-435c-aa5a-1bb60acc31d7
- 鼠标按键
  ls-type:: annotation
  hl-page:: 541
  hl-color:: green
  id:: 63d1ea0d-709f-43c0-a87b-b5313520aee8
- ：0 表示鼠标主键、1 表示鼠标中键（通常也是滚轮键）、2 表示鼠标副键
  ls-type:: annotation
  hl-page:: 541
  hl-color:: yellow
  id:: 63d1ea2c-e900-44a6-9ab7-6101ee6b020f
- 额外事件信息
  ls-type:: annotation
  hl-page:: 541
  hl-color:: green
  id:: 63d1ea34-f293-4f67-a2cf-341b5e406c2f
- 。对鼠标事件来说，detail 包含一个数值，表示在给定位置上发生了多少次单击
  ls-type:: annotation
  hl-page:: 541
  hl-color:: yellow
  id:: 63d1ea4d-a898-4145-b4c5-7dfb626a081e
- mousewheel 事件
  ls-type:: annotation
  hl-page:: 541
  hl-color:: green
  id:: 63d1ea6b-842e-4ab6-993d-b531e112f9cd
- mousewheel事件会在用户使用鼠标滚轮时触发，包括在垂直方向上任意滚动
  ls-type:: annotation
  hl-page:: 541
  hl-color:: yellow
  id:: 63d1ea75-36d7-491d-b6e9-65810788db45
- wheelDelta 的新属性。当鼠标滚轮向前滚动时， wheelDelta 每次都是+120；而当鼠标滚轮向后滚动时，wheelDelta 每次都是–120
  ls-type:: annotation
  hl-page:: 541
  hl-color:: yellow
  id:: 63d1ea92-b250-41e1-970c-64fb72eee26e
- 触摸屏设备
  ls-type:: annotation
  hl-page:: 542
  hl-color:: green
  id:: 63d1eaaa-423f-423d-aeea-68cecee9e463
- 不支持 dblclick 事件。
  ls-type:: annotation
  hl-page:: 542
  hl-color:: yellow
  id:: 63d1eab1-2e49-433c-a076-5ffc297145e4
- mousemove 事件也会触发 mouseover 和 mouseout 事件
  ls-type:: annotation
  hl-page:: 542
  hl-color:: yellow
  id:: 63d1eab7-efb9-43e1-9fce-a5067cb88d3a
- 双指点触屏幕并滑动导致页面滚动时会触发 mousewheel 和 scroll 事件
  ls-type:: annotation
  hl-page:: 542
  hl-color:: yellow
  id:: 63d1eabd-e466-4f9c-bd36-f68b51a0ec75
- 无障碍问题
  ls-type:: annotation
  hl-page:: 542
  hl-color:: green
  id:: 63d1eac7-4205-4874-a051-50d3b65a8ec0
- 键盘与输入事件
  ls-type:: annotation
  hl-page:: 543
  hl-color:: green
  id:: 63d1eada-52d4-4893-831e-764097945565
- keydown，用户按下键盘上某个键时触发，而且持续按住会重复触发。
  ls-type:: annotation
  hl-page:: 543
  hl-color:: yellow
  id:: 63d1eae8-5578-4ebe-acad-f99ca09c91f3
- keypress，用户按下键盘上某个键并产生字符时触发，而且持续按住会重复触发
  ls-type:: annotation
  hl-page:: 543
  hl-color:: yellow
  id:: 63d1eb12-a26b-4430-b1cd-d6b748c20097
- keyup，用户释放键盘上某个键时触发
  ls-type:: annotation
  hl-page:: 543
  hl-color:: yellow
  id:: 63d1eb1c-5e9e-4756-88db-67338b541c8a
- 输入事件只有一个，即 textInput。这个事件是对 keypress 事件的扩展
  ls-type:: annotation
  hl-page:: 543
  hl-color:: yellow
  id:: 63d1eb26-acc3-4f3b-9ed9-5ec18f3ddabc
- 键码
  ls-type:: annotation
  hl-page:: 543
  hl-color:: green
  id:: 63d1eb40-7143-4862-bd94-a1b2aaf9bc32
- 对于 keydown 和 keyup 事件，event 对象的 keyCode 属性中会保存一个键码，对应键盘上特定的一个键
  ls-type:: annotation
  hl-page:: 543
  hl-color:: yellow
  id:: 63d1eb55-a443-44b8-8c43-0aba7a14de70
- 字符编码
  ls-type:: annotation
  hl-page:: 544
  hl-color:: green
  id:: 63d1eb60-69d8-4323-8845-8add737afbcb
- 这个方法检测 charCode 属性是否为数值（在不支持的浏览器中是 undefined）。如果是数值，则返回。否则，返回 keyCode 值。可以像下面这样使用：
  ls-type:: annotation
  hl-page:: 545
  hl-color:: yellow
  id:: 63d1eb80-9354-4947-84f1-ad6022c9c5dd
- DOM3 的变化
  ls-type:: annotation
  hl-page:: 545
  hl-color:: green
  id:: 63d1eb86-49ca-475a-a2f6-5178d4ac24f7
- DOM3 Events 规范并未规定 charCode 属性，而是定义了 key 和 char 两个新属性
  ls-type:: annotation
  hl-page:: 545
  hl-color:: yellow
  id:: 63d1ed2d-5fb8-450e-a634-b60a8275acbc
- 支持一个名为 location 的属性，该属性是一个数值，表示是在哪里按的键。
  ls-type:: annotation
  hl-page:: 545
  hl-color:: yellow
  id:: 63d1ed6c-22d2-48d2-a3b9-09e9cb71cf9d
- 是给 event 对象增加了 getModifierState()方法
  ls-type:: annotation
  hl-page:: 546
  hl-color:: yellow
  id:: 63d1ed75-209a-4129-80d8-f24fca5f8a04
- 如果给定的修饰键处于激活状态（键被按住），则方法返回 true，否则返回 false：
  ls-type:: annotation
  hl-page:: 546
  hl-color:: yellow
  id:: 63d1ed9e-ad42-4046-8ea5-07b3a3ab47c7
- textInput 事件
  ls-type:: annotation
  hl-page:: 546
  hl-color:: green
  id:: 63d1ef2a-f100-410a-9830-22e1024e60f6
- 一个区别是 keypress 会在任何可以获得焦点的元素上触发，而 textInput 只在可编辑区域上触发
  ls-type:: annotation
  hl-page:: 546
  hl-color:: yellow
  id:: 63d1ef42-ad82-4800-a8a7-55dc02a8565a
- extInput 只在有新字符被插入时才会触发，而 keypress 对任何可能影响文本的键都会触发（包括退格键）。
  ls-type:: annotation
  hl-page:: 546
  hl-color:: yellow
  id:: 63d1ef4f-d68b-454c-884d-5ea981ee6da9
- event 对象上还有一个名为 inputMethod 的属性，该属性表示向控件中输入文本的手段。
  ls-type:: annotation
  hl-page:: 546
  hl-color:: yellow
  id:: 63d1ef7d-4ef5-458c-8d53-9c1306b75aa0
- 设备上的键盘事件
  ls-type:: annotation
  hl-page:: 547
  hl-color:: green
  id:: 63d1ef89-6ad6-4450-8ebb-d2468e4c2905
- 合成事件
  ls-type:: annotation
  hl-page:: 547
  hl-color:: green
  id:: 63d1ef95-049a-4c97-a727-84096bb0fced
- 用于处理通常使用 IME 输入时的复杂输入序列
  ls-type:: annotation
  hl-page:: 547
  hl-color:: yellow
  id:: 63d1efc2-87c8-4780-bf84-35ac473e32e7
- compositionstart，在 IME 的文本合成系统打开时触发，表示输入即将开始；
  ls-type:: annotation
  hl-page:: 547
  hl-color:: yellow
  id:: 63d1efd8-df3f-4930-b3dc-2bb09a50efa7
- compositionupdate，在新字符插入输入字段时触发；
  ls-type:: annotation
  hl-page:: 547
  hl-color:: yellow
  id:: 63d1efde-69e4-4593-b99e-662c0147ce20
- compositionend，在 IME 的文本合成系统关闭时触发，表示恢复正常键盘输入。
  ls-type:: annotation
  hl-page:: 547
  hl-color:: yellow
  id:: 63d1efe5-3f83-4e8c-af14-a3c2a4b45a4e
- 。唯一增加的事件属性是 data，其中包含的值视情况而异
  ls-type:: annotation
  hl-page:: 547
  hl-color:: yellow
  id:: 63d1eff2-4615-4bcc-b0a5-6c4a137ec2cf
- 变化事件
  ls-type:: annotation
  hl-page:: 548
  hl-color:: green
  id:: 63d1f002-1111-47a0-bfc2-526043867d33
- HTML5 事件
  ls-type:: annotation
  hl-page:: 548
  hl-color:: green
  id:: 63d1f008-fb3f-4229-b3a3-96ccd2cbc524
- 。变化事件已经被 Mutation Observers 所取代，可以参考第 14 章中的介绍。
  ls-type:: annotation
  hl-page:: 548
  hl-color:: yellow
  id:: 63d1f013-fe07-4586-9e65-b52b7301acb0
- HTML5 详尽地列出了浏览器支持的所有事件
  ls-type:: annotation
  hl-page:: 548
  hl-color:: yellow
  id:: 63d1f1d9-059a-4329-b53b-355414e67bca
- contextmenu 事件
  ls-type:: annotation
  hl-page:: 548
  hl-color:: green
  id:: 63d1f1e0-6743-484f-8c99-3917ca29eb2a
- 结果就出现了 contextmenu 事件，以专门用于表示何时该显示上下文菜单，从而允许开发者取消默认的上下文菜单并提供自定义菜单
  ls-type:: annotation
  hl-page:: 548
  hl-color:: yellow
  id:: 63d1f1f3-c186-4c12-9b1a-2d747a7378ad
- contextmenu 事件冒泡，因此只要给 document 指定一个事件处理程序就可以处理页面上的所有同类事件
  ls-type:: annotation
  hl-page:: 548
  hl-color:: yellow
  id:: 63d1f2d6-eb6b-43f7-9c63-258c5bf22fde
- 通常，自定义的上下文菜单都是通过 oncontextmenu 事件处理程序触发显示，并通过 onclick 事件处理程序触发隐藏的
  ls-type:: annotation
  hl-page:: 548
  hl-color:: yellow
  id:: 63d1f2f2-a41d-44fb-8df7-b396f8ba4811
- 这个事件处理程序首先取消默认行，确保不会显示浏览器默认的上下文菜单
  ls-type:: annotation
  hl-page:: 549
  hl-color:: yellow
  id:: 63d1f333-9ef7-437e-b804-4e1414b3b714
- beforeunload 事件
  ls-type:: annotation
  hl-page:: 549
  hl-color:: green
  id:: 63d1f378-55b6-4ff9-867f-085be4650745
- beforeunload 事件会在 window 上触发，用意是给开发者提供阻止页面被卸载的机会
  ls-type:: annotation
  hl-page:: 549
  hl-color:: yellow
  id:: 63d1f38f-7b43-4be1-896d-daa4ddcf97ff
- DOMContentLoaded 事件
  ls-type:: annotation
  hl-page:: 550
  hl-color:: green
  id:: 63d1f3d5-335d-4999-a718-a034023ca066
- 。而 DOMContentLoaded 事件会在 DOM 树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS 文件或其他资源加载完成
  ls-type:: annotation
  hl-page:: 550
  hl-color:: yellow
  id:: 63d1f3de-a282-4bf7-93b0-fb02eb94f13a
- 实际的事件目标是 document，但会冒泡到 window
  ls-type:: annotation
  hl-page:: 550
  hl-color:: yellow
  id:: 63d1f3f5-f299-415e-9b73-045cbfcb17c8
- DOMContentLoaded 事件通常用于添加事件处理程序或执行其他 DOM 操作。这个事件始终在 load事件之前触发。
  ls-type:: annotation
  hl-page:: 550
  hl-color:: yellow
  id:: 63d1f403-7dd6-4b5f-8122-5f24e37beeb7
- 要处理 DOMContentLoaded 事件，需要给 document 或 window 添加事件处理程序
  ls-type:: annotation
  hl-page:: 550
  hl-color:: yellow
  id:: 63d1f42c-e14e-4bf2-95df-1884fc4a5227
- readystatechange 事件
  ls-type:: annotation
  hl-page:: 550
  hl-color:: green
  id:: 63d1f432-6536-49b7-bab5-c6daa0d65d82
- 这个有点神秘的事件旨在提供文档或元素加载状态的信息，但行为有时候并不稳定
  ls-type:: annotation
  hl-page:: 550
  hl-color:: yellow
  id:: 63d1f45e-9b2a-4062-a935-5caed02500c5
- 支持 readystatechange 事件的每个对象都有一个 readyState 属性
  ls-type:: annotation
  hl-page:: 550
  hl-color:: yellow
  id:: 63d1f46e-f715-4f8f-901a-b51d4cf4ea5a
- 在与 load 事件共同使用时，这个事件的触发顺序不能保证
  ls-type:: annotation
  hl-page:: 551
  hl-color:: yellow
  id:: 63d1f4ee-1d97-477a-b025-9d451bb38784
- 如果是，则移除事件处理程序，以保证其他阶段不再执行
  ls-type:: annotation
  hl-page:: 551
  hl-color:: yellow
  id:: 63d1f506-9b77-4db5-bae8-baeadee88c75
- pageshow 与 pagehide 事件
  ls-type:: annotation
  hl-page:: 551
  hl-color:: green
  id:: 63d1f511-4364-484a-a3e6-d7ebba03ab3e
- 。在新加载的页面上， pageshow 会在 load 事件之后触发
  ls-type:: annotation
  hl-page:: 551
  hl-color:: yellow
  id:: 63d1f52c-336e-4a04-b7a0-bf85ebdc5022
- pageshow，其会在页面显示时触发
  ls-type:: annotation
  hl-page:: 551
  hl-color:: yellow
  id:: 63d1f532-f029-4675-a03e-2282caf23025
- 来自往返缓存的页面上，pageshow 会在页面状态完全恢复后触发
  ls-type:: annotation
  hl-page:: 551
  hl-color:: yellow
  id:: 63d1f53d-d6e4-44d3-8d53-ed8c1effef8f
- 虽然这个事件的目标是 document，但事件处理程序必须添加到 window 上
  ls-type:: annotation
  hl-page:: 551
  hl-color:: yellow
  id:: 63d1f544-a8d3-4393-b521-5483284f4ad2
- ageshow 的 event 对象中还包含一个名为 persisted 的属性。这个属性是一个布尔值，如果页面存储在了往返缓存中就是 true，否则就是 false。
  ls-type:: annotation
  hl-page:: 552
  hl-color:: yellow
  id:: 63d1f5a8-115e-4484-9c19-455fb3c1f1e9
- 是 pagehide，这个事件会在页面从浏览器中卸载后，在 unload 事件之前触发
  ls-type:: annotation
  hl-page:: 552
  hl-color:: yellow
  id:: 63d1f5c3-5d4c-432a-aa1b-dac39c8482f3
- pagehide 事件同样是在 document 上触发，但事件处理程序必须被添加到 window
  ls-type:: annotation
  hl-page:: 552
  hl-color:: yellow
  id:: 63d1f5de-3d4f-4f66-92c0-eec43cc67a58
- 对 pagehide 事件来说， persisted 为 true 表示页面在卸载之后会被保存在往返缓存中
  ls-type:: annotation
  hl-page:: 552
  hl-color:: yellow
  id:: 63d1f5fd-02f4-4de5-8700-e758fbe0438a
- 注册了 onunload 事件处理程序（即使是空函数）的页面会自动排除在往返缓存之外
  ls-type:: annotation
  hl-page:: 553
  hl-color:: yellow
  id:: 63d1f61e-c380-4c11-a7b9-024f259580e7
- hashchange 事件
  ls-type:: annotation
  hl-page:: 553
  hl-color:: green
  id:: 63d1f635-d6fa-4443-a3d3-5356cfbb42cb
- 用于在 URL 散列值（URL 最后#后面的部分）发生变化时通知开发者
  ls-type:: annotation
  hl-page:: 553
  hl-color:: yellow
  id:: 63d1f64f-03dd-4dfc-a4a8-b27426ce070d
- onhashchange 事件处理程序必须添加给 window，
  ls-type:: annotation
  hl-page:: 553
  hl-color:: yellow
  id:: 63d1f656-26d1-42b7-9aac-d52a1d565bc7
- 设备事件
  ls-type:: annotation
  hl-page:: 553
  hl-color:: green
  id:: 63d1f68c-bb8d-419f-9af3-51ab26d49724
- orientationchange 事件
  ls-type:: annotation
  hl-page:: 553
  hl-color:: green
  id:: 63d1f69f-46f5-4e0e-aae3-e526da641fab
- 相关信息都可以从 window.orientation 属性中获取
  ls-type:: annotation
  hl-page:: 554
  hl-color:: yellow
  id:: 63d1f6ac-e6ce-41be-9349-0198cc7a06b0
- deviceorientation 事件
  ls-type:: annotation
  hl-page:: 554
  hl-color:: green
  id:: 63d1f6d6-9090-4d7b-b19e-1e3c58ea3078
- 如果可以获取设备的加速计信息，而且数据发生了变化，这个事件就会在 window 上触发。
  ls-type:: annotation
  hl-page:: 554
  hl-color:: yellow
  id:: 63d1f6de-683b-4329-9c21-2755b098ab52
- deviceorientation 触发时，event 对象中会包含各个轴相对于设备静置时坐标值的变化
  ls-type:: annotation
  hl-page:: 555
  hl-color:: yellow
  id:: 63d1f6f1-362f-44b6-bb26-89b85b817630
- devicemotion 事件
  ls-type:: annotation
  hl-page:: 556
  hl-color:: green
  id:: 63d1f70a-cfc2-4c3f-914d-f5902bf88385
- 这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向
  ls-type:: annotation
  hl-page:: 556
  hl-color:: yellow
  id:: 63d1f713-efd3-45a8-96fb-550747459156
- 在使用这些属性前必须先检测它们的值是否为 null
  ls-type:: annotation
  hl-page:: 556
  hl-color:: yellow
  id:: 63d1f755-7120-49e2-9c42-b493f9e29bb1
- 触摸及手势事件
  ls-type:: annotation
  hl-page:: 556
  hl-color:: green
  id:: 63d1f75e-6551-4a9e-876d-f1a7d513857f
- 除了这些公共的 DOM 属性，触摸事件还提供了以下 3 个属性用于跟踪触点。
  ls-type:: annotation
  hl-page:: 557
  hl-color:: yellow
  id:: 63d1f7e6-4d10-4198-9277-c002d9f556d7
- 手势事件
  ls-type:: annotation
  hl-page:: 558
  hl-color:: green
  id:: 63d1f80d-c461-465a-a722-8832ee894ec3
- gesturestart：一个手指已经放在屏幕上，再把另一个手指放到屏幕上时触发。
  ls-type:: annotation
  hl-page:: 558
  hl-color:: yellow
  id:: 63d1f825-dfe3-4022-b2d5-4f14d74d7cf1
  hl-stamp:: 1674704935959
- gesturechange：任何一个手指在屏幕上的位置发生变化时触发
  ls-type:: annotation
  hl-page:: 558
  hl-color:: yellow
  id:: 63d1f830-c397-42a2-b916-25acc43f9ad2
- gestureend：其中一个手指离开屏幕时触发
  ls-type:: annotation
  hl-page:: 558
  hl-color:: yellow
  id:: 63d1f837-367c-406e-a4dd-826d6122bc07
- 与触摸事件类似，每个手势事件的 event 对象都包含所有标准的鼠标事件属性
  ls-type:: annotation
  hl-page:: 558
  hl-color:: yellow
  id:: 63d1f87a-e591-401f-af8f-dec791952242
- 事件参考
  ls-type:: annotation
  hl-page:: 559
  hl-color:: green
  id:: 63d1f887-e0a7-4350-921a-8e529cf68559
- 内存与性能
  ls-type:: annotation
  hl-page:: 565
  hl-color:: green
  id:: 63d1f893-2cd7-46e1-81eb-1b09b826909f
- 事件委托
  ls-type:: annotation
  hl-page:: 565
  hl-color:: green
  id:: 63d218e3-8561-4ffd-b16e-29a9eaa38672
- 过多事件处理程序”的解决方案是使用事件委托
  ls-type:: annotation
  hl-page:: 565
  hl-color:: yellow
  id:: 63d21945-53bf-451e-af3f-d5eda025a5b3
- 事件委托利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件
  ls-type:: annotation
  hl-page:: 565
  hl-color:: yellow
  id:: 63d2195f-2b9f-47ea-bd04-165b32655037
- 使用事件委托，只要给所有元素共同的祖先节点添加一个事件处理程序，就可以解决问题
  ls-type:: annotation
  hl-page:: 566
  hl-color:: yellow
  id:: 63d21abe-0101-4cde-bc74-28737f0ec743
- 所有使用按钮的事件（大多数鼠标事件和键盘事件）都适用于这个解决方案
  ls-type:: annotation
  hl-page:: 566
  hl-color:: yellow
  id:: 63d21bf6-91e0-40a4-bfb1-0d089256ea70
- 最适合使用事件委托的事件包括：click、mousedown、mouseup、keydown 和 keypress。
  ls-type:: annotation
  hl-page:: 566
  hl-color:: yellow
  id:: 63d21c01-f68d-4e0d-90b4-2292d53036b4
- 删除事件处理程序
  ls-type:: annotation
  hl-page:: 566
  hl-color:: green
  id:: 63d21c16-e5b8-402a-9602-c881d03d463a
- 被 innerHTML 删除的元素上如果有事件处理程序，就不会被垃圾收集程序正常清理
  ls-type:: annotation
  hl-page:: 567
  hl-color:: yellow
  id:: 63d21c6f-a504-44f5-bb0a-f2cd2e05111b
- 道某个元素会被删除，那么最好在删除它之前手工删除它的事件处理程序
  ls-type:: annotation
  hl-page:: 567
  hl-color:: yellow
  id:: 63d21c7c-edb9-43ea-a706-b1844480532d
- 另一个可能导致内存中残留引用的问题是页面卸载
  ls-type:: annotation
  hl-page:: 567
  hl-color:: yellow
  id:: 63d21e0e-2ebd-4ae1-8314-8e7c850c8905
- 好在 onunload 事件处理程序中趁页面尚未卸载先删除所有事件处理程序
  ls-type:: annotation
  hl-page:: 568
  hl-color:: yellow
  id:: 63d21e38-3360-4965-b49c-8e7b12a22765
- 模拟事件
  ls-type:: annotation
  hl-page:: 568
  hl-color:: green
  id:: 63d21e43-3f09-42e7-a46a-715256f1b535
- DOM 事件模拟
  ls-type:: annotation
  hl-page:: 568
  hl-color:: green
  id:: 63d21f41-bda7-4ab9-b768-e24a80a6eb43
- 任何时候，都可以使用 document.createEvent()方法创建一个 event 对象。
  ls-type:: annotation
  hl-page:: 568
  hl-color:: yellow
  id:: 63d21f81-1f5f-4a1f-91e1-68c0674da398
- 参数是一个表示要创建事件类型的字符串
  ls-type:: annotation
  hl-page:: 568
  hl-color:: yellow
  id:: 63d21f87-4e0f-45f4-b3b7-776825b7025b
- 事件模拟的最后一步是触发事件。为此要使用 dispatchEvent()方法，
  ls-type:: annotation
  hl-page:: 568
  hl-color:: yellow
  id:: 63d21fab-54fb-4232-aa78-2f1389b7358a
- 参数，即表示要触发事件的 event 对象
  ls-type:: annotation
  hl-page:: 568
  hl-color:: yellow
  id:: 63d21fb6-bef6-45f1-ac30-e3bf12bb0368
- 模拟鼠标事件
  ls-type:: annotation
  hl-page:: 568
  hl-color:: green
  id:: 63d21fc5-b6eb-4ee0-8f3a-6decf87e00f0
- 模拟键盘事件
  ls-type:: annotation
  hl-page:: 569
  hl-color:: green
  id:: 63d2200f-ce4e-440d-9cfc-f10a0dcbc265
- 模拟其他事件
  ls-type:: annotation
  hl-page:: 571
  hl-color:: green
  id:: 63d221e6-ef0e-47bb-ae90-1017dde0889c
  hl-stamp:: 1674715623853
- 自定义 DOM 事件
  ls-type:: annotation
  hl-page:: 571
  hl-color:: green
  id:: 63d22220-ef0e-4042-b4f0-b1570768b075
- type（字符串）：要触发的事件类型，如"myevent"。
  ls-type:: annotation
  hl-page:: 571
  hl-color:: yellow
  id:: 63d2222b-c67d-46d6-9bbe-eacd8bd10dc6
- bubbles（布尔值）：表示事件是否冒泡。
  ls-type:: annotation
  hl-page:: 571
  hl-color:: yellow
  id:: 63d22235-df78-4601-8e70-56d701d02dba
- cancelable（布尔值）：表示事件是否可以取消
  ls-type:: annotation
  hl-page:: 571
  hl-color:: yellow
  id:: 63d2223f-dbed-4103-968b-ab341ee82fb1
- detail（对象）：任意值。作为 event 对象的 detail 属性。
  ls-type:: annotation
  hl-page:: 571
  hl-color:: yellow
  id:: 63d22244-63a2-413a-ab4b-7ffa512a0484
- IE 事件模拟
  ls-type:: annotation
  hl-page:: 572
  hl-color:: green
  id:: 63d224af-3eed-40f9-abe0-b96762d0624f
- 要使用 document 对象的 createEventObject()方法来创建 event 对象。
  ls-type:: annotation
  hl-page:: 572
  hl-color:: yellow
  id:: 63d2255a-2aa3-439e-a67a-6bc6ee5068b9
- 最后一步是在事件目标上调用 fireEvent()方法，这个方法接收两个参数：事件处理程序的名字和 event 对象
  ls-type:: annotation
  hl-page:: 572
  hl-color:: yellow
  id:: 63d22568-f1f8-490e-a2f4-95da74cfe6b6
- 使用 requestAnimationFrame
  ls-type:: annotation
  hl-page:: 574
  hl-color:: green
  id:: 63d225a8-086f-430c-b7ca-178e59e01d2b
- Firefox 4 率先在浏览器中为 JavaScript动画增加了一个名为 mozRequestAnimationFrame()方法的 API
  ls-type:: annotation
  hl-page:: 574
  hl-color:: yellow
  id:: 63d226a1-4fcc-4dd7-8ed1-7c519839fbd6
- 早期定时动画
  ls-type:: annotation
  hl-page:: 574
  hl-color:: green
  id:: 63d226a7-329f-448a-b7a9-8f612900588c
- 在 JavaScript 中创建动画基本上就是使用 setInterval()来控制动画的执行
  ls-type:: annotation
  hl-page:: 574
  hl-color:: yellow
  id:: 63d226fc-98df-404d-9955-ab83582e50be
- 虽然使用 setInterval()的定时动画比使用多个 setTimeout()实现循环效率更高，但也不是没有问题
  ls-type:: annotation
  hl-page:: 575
  hl-color:: yellow
  id:: 63d22744-10ce-4e2e-b8ed-01a230ac01b3
- 时间间隔的问题
  ls-type:: annotation
  hl-page:: 575
  hl-color:: green
  id:: 63d22749-62bb-4b15-b174-33b5572fa105
- requestAnimationFrame
  ls-type:: annotation
  hl-page:: 575
  hl-color:: green
  id:: 63d22765-f0f0-4fa5-b481-cc84c3596e39
- 用以通知浏览器某些 JavaScript 代码要执行动画了
  ls-type:: annotation
  hl-page:: 575
  hl-color:: yellow
  id:: 63d22776-c5dc-4c3a-8c4a-8dd368e1bbe2
- 此参数是一个要在重绘屏幕前调用的函数
  ls-type:: annotation
  hl-page:: 575
  hl-color:: yellow
  id:: 63d2277c-9ddd-41c8-bdab-93346163ef41
- 修改 DOM 样式以反映下一次重绘有什么变化的地方
  ls-type:: annotation
  hl-page:: 576
  hl-color:: yellow
  id:: 63d2278a-a0d5-46e3-bdef-c7d3d5a71a99
- 因为 requestAnimationFrame()只会调用一次传入的函数，所以每次更新用户界面时需要再手动调用它一次。
  ls-type:: annotation
  hl-page:: 576
  hl-color:: yellow
  id:: 63d227a2-55f6-4cfa-aba8-b34ebf593b61
- cancelAnimationFrame
  ls-type:: annotation
  hl-page:: 576
  hl-color:: green
  id:: 63d227b7-ebb0-40b6-b43b-4430ce482e0b
- requestAnimationFrame()也返回一个请求 ID，可以用于通过另一个方法 cancelAnimationFrame()来取消重绘任务
  ls-type:: annotation
  hl-page:: 576
  hl-color:: yellow
  id:: 63d227de-29ec-411c-adfc-e10fa01493a1
- 通过 requestAnimationFrame 节流
  ls-type:: annotation
  hl-page:: 576
  hl-color:: green
  id:: 63d227f4-dc1d-49c7-b1cb-6398bdc9abc9
- 会暴露出作为钩子的回调队列
  ls-type:: annotation
  hl-page:: 576
  hl-color:: yellow
  id:: 63d227fc-3fb9-4d64-9b82-e6feefcc22a0
- 这样会把所有回调的执行集中在重绘钩子，但不会过滤掉每次重绘的多余调用
  ls-type:: annotation
  hl-page:: 577
  hl-color:: yellow
  id:: 63d22837-55a9-4514-a5f0-e973e1463fea
- 。更好的办法是配合使用一个计时器来限制操作执行的频率。
  ls-type:: annotation
  hl-page:: 577
  hl-color:: yellow
  id:: 63d22849-0dfe-47a4-bdcd-4d20c358da5e
- 基本的画布功能
  ls-type:: annotation
  hl-page:: 577
  hl-color:: green
  id:: 63d2286c-66a4-47e5-aa32-045af0406bb7
- 创建<canvas>元素时至少要设置其 width 和 height 属性
  ls-type:: annotation
  hl-page:: 577
  hl-color:: yellow
  id:: 63d22883-e5e1-41bc-aae0-259ff4201a9d
- 使用 getContext()方法可以获取对绘图上下文的引用
  ls-type:: annotation
  hl-page:: 578
  hl-color:: yellow
  id:: 63d2289c-b119-4643-a21f-be90e798622b
- 对于平面图形，需要给这个方法传入参数"2d"，表示要获取 2D 上下文对象
  ls-type:: annotation
  hl-page:: 578
  hl-color:: yellow
  id:: 63d228a4-ee2f-4328-9acb-5fa80478fa41
- 使用<canvas>元素时，最好先测试一下 getContext()方法是否存在
  ls-type:: annotation
  hl-page:: 578
  hl-color:: yellow
  id:: 63d228ce-62ed-44f0-857b-185251e75a40
- 可以使用 toDataURL()方法导出<canvas>元素上的图像
  ls-type:: annotation
  hl-page:: 578
  hl-color:: yellow
  id:: 63d228f6-8e7d-46b8-a9c6-b41f8705248a
- 2D 绘图上下文
  ls-type:: annotation
  hl-page:: 578
  hl-color:: green
  id:: 63d2291b-62da-447c-88ff-869654507744
- 填充和描边
  ls-type:: annotation
  hl-page:: 579
  hl-color:: green
  id:: 63d22933-405c-433a-8856-8fb41be8015f
- 。填充以指定样式（颜色、渐变或图像）自动填充形状
  ls-type:: annotation
  hl-page:: 579
  hl-color:: yellow
  id:: 63d2294d-1c68-49b1-8d31-b2a35b66c1df
- 描边只为图形边界着色
  ls-type:: annotation
  hl-page:: 579
  hl-color:: yellow
  id:: 63d22955-6b6b-4f5f-9238-1175ee3f4abb
- 显示效果取决于两个属性： fillStyle 和 strokeStyle。
  ls-type:: annotation
  hl-page:: 579
  hl-color:: yellow
  id:: 63d2296b-aeff-4370-9065-96087e5fbf52
- 绘制矩形
  ls-type:: annotation
  hl-page:: 579
  hl-color:: green
  id:: 63d229ab-78d1-4e3a-93e8-61ff362be950
- 绘制矩形相关的方法有 3 个： fillRect()、strokeRect()和 clearRect()
  ls-type:: annotation
  hl-page:: 579
  hl-color:: yellow
  id:: 63d229ba-34a6-47a7-b8cc-22eedabfa761
- 4 个参数：矩形 x 坐标、矩形 y 坐标、矩形宽度和矩形高度
  ls-type:: annotation
  hl-page:: 579
  hl-color:: yellow
  id:: 63d229c1-d34e-4c77-b5ac-3d110382b0ed
- fillRect()方法用于以指定颜色在画布上绘制并填充矩形
  ls-type:: annotation
  hl-page:: 579
  hl-color:: yellow
  id:: 63d229cc-e42c-4ec8-a8d8-9b2eb8ffd0c3
- strokeRect()方法使用通过 strokeStyle 属性指定的颜色绘制矩形轮廓
  ls-type:: annotation
  hl-page:: 580
  hl-color:: yellow
  id:: 63d229f5-aded-4590-94f0-b1465a5933a4
  hl-stamp:: 1674717687795
- 使用 clearRect()方法可以擦除画布中某个区域
  ls-type:: annotation
  hl-page:: 580
  hl-color:: yellow
  id:: 63d22bbe-3929-4d50-bade-9d832db20a85
- 绘制路径
  ls-type:: annotation
  hl-page:: 581
  hl-color:: green
  id:: 63d22bc9-0280-4272-92c5-ddb64478dfc0
- 必须首先调用 beginPath()方法以表示要开始绘制新路径
  ls-type:: annotation
  hl-page:: 581
  hl-color:: yellow
  id:: 63d22bed-56d6-4e22-af79-49bc81a765be
- 如果路径已经完成，则既可以指定 fillStyle 属性并调用 fill()方法来填充路径，
  ls-type:: annotation
  hl-page:: 581
  hl-color:: yellow
  id:: 63d22c2c-c973-4b31-9ca1-9ef1fb7d14f5
- 指定 strokeStyle 属性并调用 stroke()方法来描画路径
  ls-type:: annotation
  hl-page:: 581
  hl-color:: yellow
  id:: 63d22c35-7759-4b7e-a365-74551d7a4e9a
- 调用 clip()方法基于已有路径创建一个新剪切区域
  ls-type:: annotation
  hl-page:: 581
  hl-color:: yellow
  id:: 63d22c3a-1c17-484d-a522-ec949b343e81
- 路径是 2D 上下文的主要绘制机制，为绘制结果提供了很多控制
  ls-type:: annotation
  hl-page:: 582
  hl-color:: yellow
  id:: 63d22da3-bfe1-49d2-ab89-ee3ed23f7db7
- isPointInPath()方法，接收 x 轴和 y 轴坐标作为参数。这个方法用于确定指定的点是否在路径上，可以在关闭路径前随时调用
  ls-type:: annotation
  hl-page:: 582
  hl-color:: yellow
  id:: 63d22db5-8cd8-4b9c-b36b-f092ca4af019
- 绘制文本
  ls-type:: annotation
  hl-page:: 583
  hl-color:: green
  id:: 63d22dc2-f028-4e28-9177-9e6e50081614
- 2D 绘图上下文还提供了绘制文本的方法，即 fillText()和 strokeText()。
  ls-type:: annotation
  hl-page:: 583
  hl-color:: yellow
  id:: 63d22ddd-df97-422b-8f52-a3d94f0b8f63
- 4 个参数：要绘制的字符串、x 坐标、y 坐标和可选的最大像素宽度
  ls-type:: annotation
  hl-page:: 583
  hl-color:: yellow
  id:: 63d22de5-1891-4994-9e64-7a261973d1f7
- 。类似地，通过修改 textBaseline属性，可以改变文本的垂直对齐方式。
  ls-type:: annotation
  hl-page:: 584
  hl-color:: yellow
  id:: 63d22eba-82d1-4027-af57-7d9fdd56bd57
- 辅助确定文本大小的 measureText()方法。这个方法接收一个参数，即要绘制的文本，然后返回一个 TextMetrics 对象
  ls-type:: annotation
  hl-page:: 584
  hl-color:: yellow
  id:: 63d22ecb-57a6-4e42-9ce3-7880b24315f3
- 变换
  ls-type:: annotation
  hl-page:: 585
  hl-color:: green
  id:: 63d22eee-b63a-4478-a297-e77b5c03508a
- 对绘制上下文应用变换，可以导致以不同的变换矩阵应用绘制操作，从而产生不同的结果
  ls-type:: annotation
  hl-page:: 585
  hl-color:: yellow
  id:: 63d22f5a-acaf-4738-b644-29054e8b80a1
- 所有这些变换，包括 fillStyle 和 strokeStyle 属性，会一直保留在上下文中，直到再次修改它们
  ls-type:: annotation
  hl-page:: 586
  hl-color:: yellow
  id:: 63d230a3-85e8-4c1a-bc95-33a6220a4fb0
- ，可以调用 save()方法。调用这个方法后，所有这一时刻的设置会被放到一个暂存栈中。保存之后
  ls-type:: annotation
  hl-page:: 586
  hl-color:: yellow
  id:: 63d230ab-25b4-433e-942b-c35368a01a08
- restore()方法。这个方法会从暂存栈中取出并恢复之前保存的设
  ls-type:: annotation
  hl-page:: 587
  hl-color:: yellow
  id:: 63d230b1-c836-4938-853e-2044d5d6f75b
- 注意，save()方法只保存应用到绘图上下文的设置和变换，不保存绘图上下文的内容。
  ls-type:: annotation
  hl-page:: 587
  hl-color:: yellow
  id:: 63d23142-c600-4093-a1e6-2d4163690796
- 绘制图像
  ls-type:: annotation
  hl-page:: 587
  hl-color:: green
  id:: 63d2314f-80da-4b92-bf96-1e4d67977e74
- 如果想把现有图像绘制到画布上，可以使用 drawImage()方法
  ls-type:: annotation
  hl-page:: 587
  hl-color:: yellow
  id:: 63d23161-090b-4a93-a59d-d13d57ddc3db
- 最简单的调用是传入一个 HTML 的<img>元素
  ls-type:: annotation
  hl-page:: 587
  hl-color:: yellow
  id:: 63d23207-45b8-4ef4-bb6c-3220f8b511bc
- 。如果想改变所绘制图像的大小，可以再传入另外两个参数：目标宽度和目标高度
  ls-type:: annotation
  hl-page:: 587
  hl-color:: yellow
  id:: 63d23213-2284-43e5-b49f-36805293f1f1
- 重载后的 drawImage()方法可以实现最大限度的控制
  ls-type:: annotation
  hl-page:: 587
  hl-color:: yellow
  id:: 63d23235-d77f-40a4-b39a-6996558d41c2
- 第一个参数除了可以是 HTML 的<img>元素，还可以是另一个<canvas>元素
  ls-type:: annotation
  hl-page:: 588
  hl-color:: yellow
  id:: 63d23241-bb66-4ea7-8554-4c83cd0c8319
- 阴影
  ls-type:: annotation
  hl-page:: 588
  hl-color:: green
  id:: 63d23292-4286-481c-aa0b-18a0686d1ff0
- 2D 上下文可以根据以下属性的值自动为已有形状或路径生成阴影。
  ls-type:: annotation
  hl-page:: 588
  hl-color:: yellow
  id:: 63d232a3-3ed9-4dbe-8063-32cb5e21738f
- shadowColor：CSS 颜色值，表示要绘制的阴影颜色，默认为黑色。
  ls-type:: annotation
  hl-page:: 588
  hl-color:: yellow
  id:: 63d232cc-5e4c-44c7-8b91-e141d25657e2
- hadowOffsetX：阴影相对于形状或路径的 x 坐标的偏移量，默认为 0。
  ls-type:: annotation
  hl-page:: 588
  hl-color:: yellow
  id:: 63d232d6-69db-4014-bfdf-48884462da7c
- shadowOffsetY：阴影相对于形状或路径的 y 坐标的偏移量，默认为 0。
  ls-type:: annotation
  hl-page:: 588
  hl-color:: yellow
  id:: 63d232dc-c16f-4f56-8af2-5b86b15ee7ff
- shadowBlur：像素，表示阴影的模糊量。默认值为 0，表示不模糊。
  ls-type:: annotation
  hl-page:: 588
  hl-color:: yellow
  id:: 63d232e2-3b9d-4792-8bee-85cc31325af5
- 渐变
  ls-type:: annotation
  hl-page:: 589
  hl-color:: green
  id:: 63d232eb-6415-48f4-b822-79c792dcf688
  hl-stamp:: 1674719980641
- 要创建一个新的线性渐变，可以调用上下文的 createLinearGradient()方法。
  ls-type:: annotation
  hl-page:: 589
  hl-color:: yellow
  id:: 63d2331b-d724-4238-9571-b6065143a1ae
- 接下来要使用 addColorStop()方法为渐变指定色标。这个方法接收两个参数：色标位置和 CSS 颜色字符串
  ls-type:: annotation
  hl-page:: 589
  hl-color:: yellow
  id:: 63d2333a-72dc-4c91-8808-8adbc5c44c68
- 现在表示的就是在画布上从(30, 30)到(70, 70)绘制一个渐变。渐变的起点颜色为白色，终点颜色为黑色。可以把
  ls-type:: annotation
  hl-page:: 589
  hl-color:: yellow
  id:: 63d2335f-630c-4d87-aac8-e716154db379
- 为了让渐变覆盖整个矩形，而不只是其中一部分，两者的坐标必须搭配合适
  ls-type:: annotation
  hl-page:: 589
  hl-color:: yellow
  id:: 63d23368-bb0f-4983-81f9-c823fc9767d5
- 这个函数会基于起点的 x、y 坐标和传入的宽度、高度创建渐变对象，之后调用 fillRect()方法时可以使用相同的值
  ls-type:: annotation
  hl-page:: 590
  hl-color:: yellow
  id:: 63d23388-a727-4119-adbf-78104d22d9ed
- 用类似 createRectLinearGradient()这样的辅助函数能让计算坐标简单一些。
  ls-type:: annotation
  hl-page:: 590
  hl-color:: yellow
  id:: 63d2339e-b8a3-43be-9024-12bab33d2e3e
- 径向渐变（或放射性渐变）要使用 createRadialGradient()方法来创建
  ls-type:: annotation
  hl-page:: 590
  hl-color:: yellow
  id:: 63d233a6-e196-47c7-b9c5-7411f9eb82ae
- 要创建起点圆心在形状中心并向外扩散的径向渐变，需要将两个圆形设置为同心圆。
  ls-type:: annotation
  hl-page:: 590
  hl-color:: yellow
  id:: 63d233c1-c74d-4370-a16a-a7bff9296cbb
- 图案
  ls-type:: annotation
  hl-page:: 591
  hl-color:: green
  id:: 63d233fc-945e-4420-9b82-9b0da6505af7
- 要创建新图案，可以调用 createPattern()方法并传入两个参数：一个 HTML <img>元素和一个表示该如何重复图像的字符串
  ls-type:: annotation
  hl-page:: 591
  hl-color:: yellow
  id:: 63d2340e-6db6-40b8-8ad9-eb29c30ac4f5
- 传给 createPattern()方法的第一个参数也可以是<video>元素或者另一个<canvas>元素。
  ls-type:: annotation
  hl-page:: 591
  hl-color:: yellow
  id:: 63d23449-8fab-48da-b39b-f32aae2cea42
- 包括"repeat"、"repeat-x"、"repeat-y"和"no-repeat"
  ls-type:: annotation
  hl-page:: 591
  hl-color:: yellow
  id:: 63d23450-48ac-4c5d-b9f3-35a1abccb0c2
- 图像数据
  ls-type:: annotation
  hl-page:: 591
  hl-color:: green
  id:: 63d2345d-d82f-4e23-93cd-0b59d782e2ad
- getImageData()方法获取原始图像数据
  ls-type:: annotation
  hl-page:: 591
  hl-color:: yellow
  id:: 63d23469-4e71-4767-b705-cc585bc4bb9c
- 要取得数据中第一个像素的左上角坐标和要取得的像素宽度及高度
  ls-type:: annotation
  hl-page:: 591
  hl-color:: yellow
  id:: 63d2348a-42fb-40ff-9274-226feb3e3f02
- 返回的对象是一个 ImageData 的实例
  ls-type:: annotation
  hl-page:: 591
  hl-color:: yellow
  id:: 63d234a8-8cad-465c-9f9d-c6f5cfe35b82
- width、height和 data，其中，data 属性是包含图像的原始像素信息的数组
  ls-type:: annotation
  hl-page:: 591
  hl-color:: yellow
  id:: 63d234b3-afa6-4e26-8172-7f09126bc247
- 第一个像素的信息包含在第 0 到第 3 个值中
  ls-type:: annotation
  hl-page:: 591
  hl-color:: yellow
  id:: 63d234c8-c9ee-4bf7-8c3c-8670edfb3375
- 合成
  ls-type:: annotation
  hl-page:: 592
  hl-color:: green
  id:: 63d234dc-5ea7-4d97-a979-a18c356c8d2a
- globalAlpha 属性是一个范围在 0~1 的值（包括 0 和 1），用于指定所有绘制内容的透明度
  ls-type:: annotation
  hl-page:: 592
  hl-color:: yellow
  id:: 63d23542-60e2-4ae0-964d-fcfa8ce79d27
- globalCompositionOperation 属性表示新绘制的形状如何与上下文中已有的形状融合
  ls-type:: annotation
  hl-page:: 593
  hl-color:: yellow
  id:: 63d2354e-54b0-4b9a-980c-8b9babe30244
- WebGL
  ls-type:: annotation
  hl-page:: 594
  hl-color:: green
  id:: 63d235b3-cf0f-4aca-bc7a-17df42fd1c4d
- WebGL 上下文
  ls-type:: annotation
  hl-page:: 594
  hl-color:: green
  id:: 63d235fe-2907-4e20-a6ad-a5f5b487cb33
- 这里把 WebGL context 对象命名为 gl。大多数 WebGL 应用和例子遵循这个约定
  ls-type:: annotation
  hl-page:: 594
  hl-color:: yellow
  id:: 63d23619-23ec-4e12-9bc1-143abcc52b0d
- WebGL 基础
  ls-type:: annotation
  hl-page:: 594
  hl-color:: green
  id:: 63d2364d-41bb-49c4-a4dc-8d708684019c
- 可以在调用 getContext()取得 WebGL 上下文时指定一些选项
  ls-type:: annotation
  hl-page:: 594
  hl-color:: yellow
  id:: 63d2366e-7261-4082-9deb-b7623cb5418e
- let gl = drawing.getContext("webgl", { alpha: false });
  ls-type:: annotation
  hl-page:: 595
  hl-color:: yellow
  id:: 63d23682-9206-4a17-a0e7-c1fecbdd5b1f
- 准备绘图
  ls-type:: annotation
  hl-page:: 595
  hl-color:: green
  id:: 63d236e6-67a1-481f-aec7-d3ad84b2bd48
- 指定一种实心颜色清除<canvas>。为此，要调用 clearColor()方法并传入 4 个参数，分别表示红、绿、蓝和透明度值
  ls-type:: annotation
  hl-page:: 595
  hl-color:: yellow
  id:: 63d236f0-f4fa-4c73-a0d9-62e4bf822142
- 视口与坐标
  ls-type:: annotation
  hl-page:: 596
  hl-color:: green
  id:: 63d23726-61b2-4d60-b92e-edaca4c71585
- 绘图前还要定义 WebGL 视口。默认情况下，视口使用整个<canvas>区域
  ls-type:: annotation
  hl-page:: 596
  hl-color:: yellow
  id:: 63d2372e-8df9-4d3c-b190-19d487cca19d
- 如果绘图时使用了视口外部的坐标，则绘制结果会被视口剪切。
  ls-type:: annotation
  hl-page:: 597
  hl-color:: yellow
  id:: 63d23752-23ba-48bb-b021-ecf011f71a94
- 缓冲区
  ls-type:: annotation
  hl-page:: 597
  hl-color:: green
  id:: 63d237d3-f03a-4143-ba98-0329b3639bfe
- 创建缓冲区要调用 gl.createBuffer()方法，并使用 gl.bindBuffer()方法将缓冲区绑定到 WebGL 上下文
  ls-type:: annotation
  hl-page:: 597
  hl-color:: yellow
  id:: 63d237e0-7afb-405e-8089-30e609e30963
- 如果想输出缓冲区内容，那么可以调用 drawElements()方法并传入 gl.ELEMENT_ARRAY_BUFFER。
  ls-type:: annotation
  hl-page:: 597
  hl-color:: yellow
  id:: 63d23801-642d-488f-aecc-28d40d7d6c52
- gl.bufferData()方法的最后一个参数表示如何使用缓冲区。这个参数可以是以下常量值
  ls-type:: annotation
  hl-page:: 597
  hl-color:: yellow
  id:: 63d2380f-4a7f-4b88-a19b-5a3118706fd8
- gl.STATIC_DRAW：
  ls-type:: annotation
  hl-page:: 597
  hl-color:: yellow
  id:: 63d23822-76a3-43fd-ab84-ada1875a80a6
- gl.STREAM_DRAW：
  ls-type:: annotation
  hl-page:: 597
  hl-color:: yellow
  id:: 63d23827-1a45-437f-b25e-d4dbfeb5b681
- gl.DYNAMIC_DRAW
  ls-type:: annotation
  hl-page:: 597
  hl-color:: yellow
  id:: 63d2382c-7e60-4052-bf7b-8121d761f254
- 如果不再需要缓冲区，那么最好调用 gl.deleteBuffer()方法释放其占用的内存：
  ls-type:: annotation
  hl-page:: 597
  hl-color:: yellow
  id:: 63d23857-4f26-4d02-9326-f597bbf83a2c
- 错误
  ls-type:: annotation
  hl-page:: 597
  hl-color:: green
  id:: 63d23861-9826-4374-bf9d-bb1a59fcaf7e
- 在 WebGL 操作中通常不会抛出错误。必须在调用可能失败的方法后，调用 gl.getError()方法。这个方法返回一个常量，表示发生的错误类型
  ls-type:: annotation
  hl-page:: 597
  hl-color:: yellow
  id:: 63d2387e-1b70-4640-b1e2-f9d1bf325963
- 着色器
  ls-type:: annotation
  hl-page:: 598
  hl-color:: green
  id:: 63d23889-acb1-4200-a799-0fc4f1b1b561
- 顶点着色器和片段（或像素）着色器
  ls-type:: annotation
  hl-page:: 598
  hl-color:: yellow
  id:: 63d238da-ed89-446d-88f0-2e9a182c79ba
- 顶点着色器用于把 3D 顶点转换为可以渲染的 2D 点
  ls-type:: annotation
  hl-page:: 598
  hl-color:: yellow
  id:: 63d238f4-037c-4781-9ee2-f825429d9b27
- 片段着色器用于计算绘制一个像素的正确颜色
  ls-type:: annotation
  hl-page:: 598
  hl-color:: yellow
  id:: 63d238f9-df56-4c2c-bfa0-9a171709529c
- 编写着色器
  ls-type:: annotation
  hl-page:: 598
  hl-color:: purple
  id:: 63d2390e-d568-4c8c-84db-1ed524e34368
  hl-stamp:: 1674721562205
- 每个着色器都有一个 main()方法，在绘制期间会重复执行
  ls-type:: annotation
  hl-page:: 598
  hl-color:: yellow
  id:: 63d23929-8c42-4dbe-aa2e-fdb3fbe5c07c
- attribute vec2 aVertexPosition;
  ls-type:: annotation
  hl-page:: 598
  hl-color:: yellow
  id:: 63d239ab-b6d1-4e01-91ab-53b5667288fa
- 片段着色器与顶点着色器类似，只不过是通过 uniform 传入数据
  ls-type:: annotation
  hl-page:: 598
  hl-color:: yellow
  id:: 63d239c8-04bc-4c15-93fb-a47c3aae3ece
- 创建着色器程序
  ls-type:: annotation
  hl-page:: 598
  hl-color:: purple
  id:: 63d239df-9cad-4a96-b4b2-3d2756cdb20e
  hl-stamp:: 1674721761118
- 有了 GLSL 字符串，下一步是创建 shader 对象。为此，需要调用 gl.createShader()方法，并传 入 想 要 创 建 的 着 色 器 类 型 （ gl.VERTEX_SHADER 或 gl.FRAGMENT_SHADER ）
  ls-type:: annotation
  hl-page:: 599
  hl-color:: yellow
  id:: 63d239ff-2fb5-4a84-9ed9-f502f2b4d2fb
- 链接到程序之后，就可以通过 gl.useProgram()方法让 WebGL 上下文使用这个程序了：
  ls-type:: annotation
  hl-page:: 599
  hl-color:: yellow
  id:: 63d23a75-7241-4a0d-8635-ea05dad362c3
- 调用 gl.useProgram()之后，所有后续的绘制操作都会使用这个程序
  ls-type:: annotation
  hl-page:: 599
  hl-color:: yellow
  id:: 63d23a7b-a65a-4783-8f4b-a6eb6ad04139
- 给着色器传值
  ls-type:: annotation
  hl-page:: 599
  hl-color:: purple
  id:: 63d23a7e-5695-437b-9f0b-79f94f41ff95
- 对于 uniform 变量，可以调用 gl.getUniformLocation()方法。这个方法返回一个对象
  ls-type:: annotation
  hl-page:: 599
  hl-color:: yellow
  id:: 63d23b11-8a2c-451e-91fe-a9df488b0fe6
- 给顶点着色器传值也是类似的过程。而要获得 attribute 变量的位置，可以调用 gl.getAttribLocation()方法
  ls-type:: annotation
  hl-page:: 600
  hl-color:: yellow
  id:: 63d23b1c-cf60-4b91-96e8-11f095f08504
- 调试着色器和程序
  ls-type:: annotation
  hl-page:: 600
  hl-color:: purple
  id:: 63d23b5b-7615-443b-a5d3-5143f6d208fd
  hl-stamp:: 1674722142977
- 绘图
  ls-type:: annotation
  hl-page:: 601
  hl-color:: green
  id:: 63d23b85-c9a7-4c73-9aea-e77b30774cda
- WebGL 只能绘制三种形状：点、线和三角形
  ls-type:: annotation
  hl-page:: 601
  hl-color:: yellow
  id:: 63d23b8c-68e9-4986-913d-bb79b396c01d
- WebGL 绘图要使用 drawArrays()和 drawElements()方法，前者使用数组缓冲区，后者则操作元素数组缓冲区
  ls-type:: annotation
  hl-page:: 601
  hl-color:: yellow
  id:: 63d23b9c-bfec-4286-9eab-8b357c05ef2f
- drawArrays()和 drawElements()的第一个参数都表示要绘制形状的常量
  ls-type:: annotation
  hl-page:: 601
  hl-color:: yellow
  id:: 63d23bd4-e74e-412f-a997-f9989851c81e
- 区别在于前 3 个顶点之后的顶点会作为第三个顶点与其前面的顶点和第一个顶点构成三角形。
  ls-type:: annotation
  hl-page:: 601
  hl-color:: yellow
  id:: 63d23c01-a326-45c3-b4e5-ec1c3ae74645
- 以上常量可以作为 gl.drawArrays()方法的第一个参数，第二个参数是数组缓冲区的起点索引，第三个参数是数组缓冲区包含的顶点集合的数量。
  ls-type:: annotation
  hl-page:: 601
  hl-color:: yellow
  id:: 63d23c09-3e3c-4306-a7f5-322c267f111a
- aVertexPosition = gl.getAttribLocation(program, "aVertexPosition");
  ls-type:: annotation
  hl-page:: 601
  hl-color:: yellow
  id:: 63d23c52-d9ce-499d-b908-51272e03f582
- 点信息保存在了缓冲区。然后把颜色信息传给片段着色器。
  ls-type:: annotation
  hl-page:: 602
  hl-color:: yellow
  id:: 63d23cb9-62d7-4ab1-948d-50bb30ff6410
- 五个参数是步长值（stride value），表示跳过多个数组元素取得下一个值。
  ls-type:: annotation
  hl-page:: 602
  hl-color:: yellow
  id:: 63d23cca-2257-462d-ad11-a3f448120902
- 纹理
  ls-type:: annotation
  hl-page:: 602
  hl-color:: green
  id:: 63d23ce7-e444-46eb-a556-4e62a981c348
- 可以使用 gl.createTexture()方法创建新的纹理，然后再将图片绑定到这个纹理
  ls-type:: annotation
  hl-page:: 602
  hl-color:: yellow
  id:: 63d23d0a-a64b-46e4-8073-604109ec752c
- 大 的区别在 于 使用 gl.pixelStorei()设置了像素存储格式。
  ls-type:: annotation
  hl-page:: 603
  hl-color:: yellow
  id:: 63d23d5b-246e-48e3-a3be-216bcec8a524
- texture = gl.createTexture();
  ls-type:: annotation
  hl-page:: 603
  hl-color:: yellow
  id:: 63d23d7f-f830-49e0-bb6b-7a5dab93324f
- 用于纹理的图片必须跟当前页面同源，或者是来自启用了跨源资源共享（CORS，Cross-Origin Resource Sharing）的服务器上。
  ls-type:: annotation
  hl-page:: 603
  hl-color:: yellow
  id:: 63d23d8b-50ee-4285-a9b6-12b968013a27
- 读取像素
  ls-type:: annotation
  hl-page:: 603
  hl-color:: green
  id:: 63d23d94-079d-429c-b0ae-f62b9a12a6e6
- 读取像素的 readPixels()方法与 OpenGL 中的方法有同样的参数，只不过最后一个参数必须是定型数组
  ls-type:: annotation
  hl-page:: 603
  hl-color:: yellow
  id:: 63d23dc9-5215-45cc-8a3d-7dc1f47862c3
- eadPixels()方法的参数包括 x 和 y 坐标、宽度、高度、图像格式、类型和定型数组
  ls-type:: annotation
  hl-page:: 603
  hl-color:: yellow
  id:: 63d23df6-03e6-4de1-a511-f5a98d7686bf
- 类型参数指的是要存储在定型数组中的数据类型
  ls-type:: annotation
  hl-page:: 603
  hl-color:: yellow
  id:: 63d23e09-cd45-46d1-8939-8b45e1fe39f3
- 。图像格式参数几乎总是 gl.RGBA
  ls-type:: annotation
  hl-page:: 603
  hl-color:: yellow
  id:: 63d23e0f-8e73-4122-9906-39fb4da2e38c
- gl.readPixels(0, 0, 25, 25, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  ls-type:: annotation
  hl-page:: 603
  hl-color:: yellow
  id:: 63d23e9d-ca3d-439a-a25e-36053b120c24
- ，并把读到的像素信息保存在 pixels 数组中，其中每个像素的颜色在这个数组中都以 4 个值表示，分别代表红、绿、蓝和透明度值
  ls-type:: annotation
  hl-page:: 603
  hl-color:: yellow
  id:: 63d23ea5-66ee-4650-bf45-49afd7b6f633
- 此时调用 readPixels()会得到与清除状态一致的像素数据。
  ls-type:: annotation
  hl-page:: 603
  hl-color:: yellow
  id:: 63d23eae-d54a-4c9b-ac8b-bb933a6b97b0
- 如果想在绘制之后读取像素，则必须使用前面讨论过的 preserveDrawingBuffer 选项初始化 WebGL 上下文
  ls-type:: annotation
  hl-page:: 603
  hl-color:: yellow
  id:: 63d23ec5-3751-4820-9884-45ffbdeaceea
- WebGL1 与 WebGL2
  ls-type:: annotation
  hl-page:: 604
  hl-color:: green
  id:: 63d23eda-518a-4114-b0d5-b244e7215e61
- 要在 WebGL1 中使用绘制缓冲区，需要先测试相应扩展后再使用
  ls-type:: annotation
  hl-page:: 604
  hl-color:: yellow
  id:: 63d23f10-315b-470c-8b93-4b6988b8c13f
- 而在 WebGL2 中，这里的检测代码就不需要了，因为这个扩展已经直接暴露在上下文对象上了
  ls-type:: annotation
  hl-page:: 604
  hl-color:: yellow
  id:: 63d23f15-b886-4665-a302-b99b019bbf80
- 表单基础
  ls-type:: annotation
  hl-page:: 606
  hl-color:: green
  id:: 63d23f2d-b86f-4901-99bc-d7b20511416b
  hl-stamp:: 1674723119315
- Web 表单在 HTML 中以<form>元素表示，在 JavaScript 中则以 HTMLFormElement 类型表示
  ls-type:: annotation
  hl-page:: 606
  hl-color:: yellow
  id:: 63d23f42-3952-4300-9002-7e5e9378ab47
- 此拥有与其他 HTML 元素一样的默认属性。不过，HTMLFormElement 也有自己的属性和方法
  ls-type:: annotation
  hl-page:: 606
  hl-color:: yellow
  id:: 63d24240-e551-4cd7-8f6b-6034b298625b
- 有几种方式可以取得对<form>元素的引用。最常用的是将表单当作普通元素为它指定一个 id 属性，从而可以使用 getElementById()来获取表单，
  ls-type:: annotation
  hl-page:: 606
  hl-color:: yellow
  id:: 63d242d3-85b1-496f-97bd-af749fdd5774
- 使用 document.forms 集合可以获取页面上所有的表单元素
  ls-type:: annotation
  hl-page:: 606
  hl-color:: yellow
  id:: 63d258ee-e3c5-47f9-9c34-7af835812041
- 提交表单
  ls-type:: annotation
  hl-page:: 607
  hl-color:: green
  id:: 63d25933-46be-4f45-be8a-a1c7c4c810ba
- ，图片按钮可以使用 type 属性为"image"的<input>元素来定义
  ls-type:: annotation
  hl-page:: 607
  hl-color:: yellow
  id:: 63d26b29-8668-486b-add9-b4df5d435ec3
- 提交按钮可以使用 type 属性为"submit"的<input>或<button>元素来定义
  ls-type:: annotation
  hl-page:: 607
  hl-color:: yellow
  id:: 63d26b36-e118-45cc-8f17-40535b81542e
- 以这种方式提交表单会在向服务器发送请求之前触发 submit 事件。
  ls-type:: annotation
  hl-page:: 607
  hl-color:: yellow
  id:: 63d26b83-cc5e-40e6-9abe-8f2711010408
- 调用 preventDefault()方法可以阻止表单提交。通常，在表单数据无效以及不应该发送到服务器时可以这样处理。
  ls-type:: annotation
  hl-page:: 607
  hl-color:: yellow
  id:: 63d26b9b-7e0b-4769-841b-6a404a213c9d
- 通过 submit()提交表单时，submit 事件不会触发。因此在调用这个方法前要先做数据验证。
  ls-type:: annotation
  hl-page:: 607
  hl-color:: yellow
  id:: 63d26bb3-f5bc-4670-baae-ecaafb7dcb2a
- 解决这个问题主要有两种方式：在表单提交后禁用提交按钮，或者通过 onsubmit 事件处理程序取消之后的表单提交
  ls-type:: annotation
  hl-page:: 607
  hl-color:: yellow
  id:: 63d26bf1-8342-4442-884d-39bf7fcaf2d4
- 重置表单
  ls-type:: annotation
  hl-page:: 608
  hl-color:: green
  id:: 63d26bf6-b4bd-4a68-afd4-4863993db3fe
- 重置按钮可以使用 type 属性为"reset"的<input>或<button>元素来创建
  ls-type:: annotation
  hl-page:: 608
  hl-color:: yellow
  id:: 63d26deb-0645-4b14-b7e0-8b1ae39b0494
- 表单重置后，所有表单字段都会重置回页面第一次渲染时各自拥有的值。
  ls-type:: annotation
  hl-page:: 608
  hl-color:: yellow
  id:: 63d26e2a-c94b-4b1b-bfe3-996af622f35a
- 表单字段
  ls-type:: annotation
  hl-page:: 608
  hl-color:: green
  id:: 63d26e48-8603-450d-b84b-1555a2476fdd
- 所有表单元素都是表单 elements 属性（元素集合）中包含的一个值
  ls-type:: annotation
  hl-page:: 608
  hl-color:: yellow
  id:: 63d26ea6-42e4-4240-a01b-713b52ea7363
- elements集合中的每个字段都以它们在 HTML 标记中出现的次序保存，可以通过索引位置和 name 属性来访问
  ls-type:: annotation
  hl-page:: 608
  hl-color:: yellow
  id:: 63d26edf-f702-4d54-9f26-bd79930c414d
- 如果多个表单控件使用了同一个 name，比如像单选按钮那样，则会返回包含所有同名元素的 HTMLCollection
  ls-type:: annotation
  hl-page:: 609
  hl-color:: yellow
  id:: 63d26f10-757f-4e6a-8802-4b451654fcb1
- 以上代码表明，使用 form.elements[0]获取的表单的第一个字段就是 form.elements["color"]中包含的第一个元素
  ls-type:: annotation
  hl-page:: 609
  hl-color:: yellow
  id:: 63d26f75-56dd-410f-8ac8-9ea4d21e9424
- 比如 form[0]这种使用索引和 form["color"]这种使用字段名字的方式
  ls-type:: annotation
  hl-page:: 609
  hl-color:: yellow
  id:: 63d26f83-9d78-476c-8732-321e1015a2f1
- 表单字段的公共属性
  ls-type:: annotation
  hl-page:: 609
  hl-color:: green
  id:: 63d26f88-68dd-4dc5-97f4-eb98973e0df0
- 除<fieldset>元素以外，所有表单字段都有一组同样的属性
  ls-type:: annotation
  hl-page:: 609
  hl-color:: yellow
  id:: 63d27009-b15a-4801-8715-9c40b547462f
- 对此，常见的解决方案是第一次点击之后禁用提交按钮。可以通过监听 submit事件来实现。
  ls-type:: annotation
  hl-page:: 610
  hl-color:: yellow
  id:: 63d27034-7cbd-48ef-b505-515ab4381cab
- 当 submit 事件触发时，代码会取得提交按钮，然后将其 disabled 属性设置为 true。
  ls-type:: annotation
  hl-page:: 610
  hl-color:: yellow
  id:: 63d2719e-2d8b-4c84-8582-4438aa2fef34
- 有些浏览器会在触发表单的 submit 事件前先触发提交按钮的 click 事件，有些浏览器则会后触发 click 事件
  ls-type:: annotation
  hl-page:: 610
  hl-color:: yellow
  id:: 63d271e3-9da3-4b0f-8f7d-cf75e4bb5507
- 表单字段的公共方法
  ls-type:: annotation
  hl-page:: 611
  hl-color:: green
  id:: 63d27232-a3b0-4c40-ba20-20786711ed94
- 该字段被 CSS 属性 display 或 visibility 隐藏了，以上代码就会出错。
  ls-type:: annotation
  hl-page:: 611
  hl-color:: yellow
  id:: 63d27249-7d90-4486-b1bf-39acc5dd61d4
- 表单字段的公共事件
  ls-type:: annotation
  hl-page:: 611
  hl-color:: green
  id:: 63d2724f-6b0b-4e90-b4c0-e07459d6d778
- 上面的代码只会在 autofocus 属性不等于 true时调用 focus()方法，以确保向前兼容
  ls-type:: annotation
  hl-page:: 611
  hl-color:: yellow
  id:: 63d2727f-3cd0-4fd7-a252-7a9e2d6346a0
- blur：在字段失去焦点时触发
  ls-type:: annotation
  hl-page:: 612
  hl-color:: yellow
  id:: 63d272a6-ca65-4bea-a89c-74e41ee926ec
- change ： 在 <input> 和 <textarea> 元 素 的 value 发 生 变 化 且 失 去 焦 点 时 触 发 ， 或 者 在<select>元素中选中项发生变化时触发。
  ls-type:: annotation
  hl-page:: 612
  hl-color:: yellow
  id:: 63d272ae-51ae-4080-bab8-e0d7ccc8c574
- ocus：在字段获得焦点时触发。
  ls-type:: annotation
  hl-page:: 612
  hl-color:: yellow
  id:: 63d27400-9e8a-418a-91de-2ed2bf06c181
- change 事件通常用于验证用户在字段中输入的内容
  ls-type:: annotation
  hl-page:: 612
  hl-color:: yellow
  id:: 63d27416-5814-4979-8f99-ddb62d525b22
- 文本框编程
  ls-type:: annotation
  hl-page:: 612
  hl-color:: green
  id:: 63d27433-5e3d-4f13-bd34-3437da0982c7
- ：单行使用<input>元素
  ls-type:: annotation
  hl-page:: 612
  hl-color:: yellow
  id:: 63d2743c-f400-4e44-9fcb-eaf11e33f69b
- 多行使用<textarea>元素
  ls-type:: annotation
  hl-page:: 612
  hl-color:: yellow
  id:: 63d27442-9d0a-434a-ba1c-d54bf7d59b08
- value 属性用于指定文本框的初始值
  ls-type:: annotation
  hl-page:: 613
  hl-color:: yellow
  id:: 63d27621-6c54-4b49-ae98-6abe8136417c
- <textarea>不能在 HTML 中指定最大允许的字符数
  ls-type:: annotation
  hl-page:: 613
  hl-color:: yellow
  id:: 63d2767a-aec4-4584-b63d-2d88346bc92e
- 应该使用 value 属性，而不是标准 DOM 方法读写文本框的值
  ls-type:: annotation
  hl-page:: 613
  hl-color:: yellow
  id:: 63d27692-494c-49d6-84dd-63e4d10ebec7
- 选择文本
  ls-type:: annotation
  hl-page:: 613
  hl-color:: green
  id:: 63d27698-5937-4cc3-aabd-f55ca100d2be
- 两种文本框都支持一个名为 select()的方法，此方法用于全部选中文本框中的文本
  ls-type:: annotation
  hl-page:: 613
  hl-color:: yellow
  id:: 63d276a3-442f-4913-b829-cffdf884454e
- select 事件
  ls-type:: annotation
  hl-page:: 613
  hl-color:: green
  id:: 63d2781c-f50c-4638-be66-d4ec605fb0e1
- 取得选中文本
  ls-type:: annotation
  hl-page:: 614
  hl-color:: green
  id:: 63d27852-c292-43a5-a49c-684ef59e72e1
- 扩展为文本框添加了两个属性：selectionStart 和 selectionEnd。这两个属性包含基于 0 的数值
  ls-type:: annotation
  hl-page:: 614
  hl-color:: yellow
  id:: 63d2788b-623f-48bc-86f4-1a4d88bdb15a
- 老版本 IE 中有一个包含整个文档中文本选择信息的 document.selection 对象
  ls-type:: annotation
  hl-page:: 614
  hl-color:: yellow
  id:: 63d278bd-68ef-4e28-b686-2429b7591021
- 部分选中文本
  ls-type:: annotation
  hl-page:: 614
  hl-color:: green
  id:: 63d27900-8187-4974-bd84-35e3ff7c1c27
- 现在，除了 select()方法之外，Firefox最早实现的 setSelectionRange()方法也可以在所有文本框中使用
  ls-type:: annotation
  hl-page:: 614
  hl-color:: yellow
  id:: 63d27921-38bb-4261-8034-96dffeab3a20
- moveStart()可以把范围的起点和终点都移动到相同的位置，再给 moveEnd()传入要选择的字符总数作为参数
  ls-type:: annotation
  hl-page:: 615
  hl-color:: yellow
  id:: 63d2795f-ed3b-4e6e-bf29-8892d4a4b745
- IE8 及更早版本支持通过范围部分选中文本。这也就是说，要选择文本框中的部分文本，必须先使用 IE 在文本框上提供的 createTextRange()方法创建一个范围，并使用 moveStart()和 moveEnd()范围方法把这个范围放到正确的位置上
  ls-type:: annotation
  hl-page:: 615
  hl-color:: yellow
  id:: 63d27984-6bde-4b7c-86eb-6863c25e4179
- 输入过滤
  ls-type:: annotation
  hl-page:: 615
  hl-color:: green
  id:: 63d2799b-6d50-4b25-af95-3d870cf11850
- 屏蔽字符
  ls-type:: annotation
  hl-page:: 615
  hl-color:: green
  id:: 63d279b2-6874-4996-b181-a5f4aabccde7
- 正则表达式/\d/来测试。这个正则表达式匹配所有数字字符
  ls-type:: annotation
  hl-page:: 616
  hl-color:: yellow
  id:: 63d27a73-d34f-43a8-b8ca-01e2d0b8db0b
- keypress 事件负责向文本框插入字符
  ls-type:: annotation
  hl-page:: 615
  hl-color:: yellow
  id:: 63d27a94-9efd-4105-a7d5-9f60772308ae
- 还有一个问题需要处理：复制、粘贴及涉及 Ctrl 键的其他功能。
  ls-type:: annotation
  hl-page:: 616
  hl-color:: yellow
  id:: 63d27b3d-1d1c-459c-9901-fc17de9c0bfd
- 处理剪贴板
  ls-type:: annotation
  hl-page:: 616
  hl-color:: green
  id:: 63d27b45-8ce1-42fa-ba33-77128b2352a3
- 通过 beforecopy、beforecut 和 beforepaste 事件可以在向剪贴板发送或从中检索数据前修改数据
  ls-type:: annotation
  hl-page:: 617
  hl-color:: yellow
  id:: 63d27b63-1916-4a01-87ac-88291d6b6fbc
- 要阻止实际的剪贴板操作，必须取消 copy、cut和 paste 事件。
  ls-type:: annotation
  hl-page:: 617
  hl-color:: yellow
  id:: 63d27b6f-d1f0-40e2-9575-f8c7da205c05
- clipboardData 对象上有 3 个方法：getData()、setData()和 clearData()
  ls-type:: annotation
  hl-page:: 617
  hl-color:: yellow
  id:: 63d27c27-5b69-4350-80ff-031d7ad50bb5
- 剪贴板上的数据可以通过 window 对象（IE）或 event 对象（Firefox、Safari 和 Chrome）上的 clipboardData 对象来获取
  ls-type:: annotation
  hl-page:: 617
  hl-color:: yellow
  id:: 63d27c36-6048-48c4-889f-fca3d025b1d0
- 如果文本框期待某些字符或某种格式的文本，那么从剪贴板中读取文本是有帮助的。
  ls-type:: annotation
  hl-page:: 617
  hl-color:: yellow
  id:: 63d27c96-b129-4584-a9f7-bf8a66695ff8
- 这个 onpaste 事件处理程序确保只有数字才能粘贴到文本框中。
  ls-type:: annotation
  hl-page:: 618
  hl-color:: yellow
  id:: 63d27ca3-2a14-47c9-90e3-6521bc9b2716
- 如果文本框只允许输入数字，那么就必须检查粘贴过来的值，确保其中只包含数字。在 paste 事件
  ls-type:: annotation
  hl-page:: 617
  hl-color:: yellow
  id:: 63d27cac-ab49-4211-8b1a-0a0a3ea7157e
- 自动切换
  ls-type:: annotation
  hl-page:: 618
  hl-color:: green
  id:: 63d27cb4-29ed-42e7-b3e5-21500853bf71
- 当前字段完成时自动切换到下一个字段
  ls-type:: annotation
  hl-page:: 618
  hl-color:: yellow
  id:: 63d27ccf-a80d-4e4c-80ad-c09dce7ac758
- tabForward()函数是实现自动切换的关键
  ls-type:: annotation
  hl-page:: 619
  hl-color:: yellow
  id:: 63d27d19-55c5-4fdd-b7eb-0d575dca3eff
- 在填写这个简单的表单时，用户不用按 Tab 键切换字段和提交表单。
  ls-type:: annotation
  hl-page:: 619
  hl-color:: yellow
  id:: 63d27d21-6377-497a-97e8-9d7ba0a536c4
- HTML5 约束验证 API
  ls-type:: annotation
  hl-page:: 619
  hl-color:: green
  id:: 63d27d24-6b7f-4050-b368-ac19302a36c7
- 必填字段
  ls-type:: annotation
  hl-page:: 619
  hl-color:: green
  id:: 63d27d32-1f77-4791-b450-8adc48f9ca35
- 给表单字段添加 required 属性
  ls-type:: annotation
  hl-page:: 619
  hl-color:: yellow
  id:: 63d27d48-69f2-4cd7-9167-b1f056f35f54
- 更多输入类型
  ls-type:: annotation
  hl-page:: 619
  hl-color:: green
  id:: 63d27e7c-cf08-4b0e-9e8d-4871423bf99e
- 两个新的输入类型是已经得到广泛支持的"email"和"url"
  ls-type:: annotation
  hl-page:: 619
  hl-color:: yellow
  id:: 63d27ea8-2eb4-4f1a-971d-3331ed7c672a
- 数值范围
  ls-type:: annotation
  hl-page:: 620
  hl-color:: green
  id:: 63d27eb0-a456-4a99-b3af-4cb811d61f30
- ："number"、"range"、"datetime"、"datetime-local"、"date"、"month"、"week"和"time"。
  ls-type:: annotation
  hl-page:: 620
  hl-color:: yellow
  id:: 63d27ee9-ac3d-4d76-b13d-6de2beab393c
- 都可以指定 min 属性（最小可能值）、max 属性（最大可能值），以及 step属性（从 min 到 max 的步长值）
  ls-type:: annotation
  hl-page:: 620
  hl-color:: yellow
  id:: 63d27ef2-37e0-4f31-a5c0-764f669f205a
- 还有两个方法，即 stepUp()和 stepDown()。这两个方法都接收一个可选的参数：要从当前值加上或减去的数值。（
  ls-type:: annotation
  hl-page:: 620
  hl-color:: yellow
  id:: 63d27f02-f263-49b2-b94c-42722c47a7ec
- 输入模式
  ls-type:: annotation
  hl-page:: 620
  hl-color:: green
  id:: 63d27f0a-04cd-4716-a0de-4dde32b8bde2
- pattern 属性。这个属性用于指定一个正则表达式，用户输入的文本必须与之匹配
  ls-type:: annotation
  hl-page:: 620
  hl-color:: yellow
  id:: 63d27f87-d89d-4c42-a023-8d27f6ab379e
- 检测有效性
  ls-type:: annotation
  hl-page:: 620
  hl-color:: green
  id:: 63d27f8e-8713-42b0-b201-315a8401d73a
- 使用 checkValidity()方法可以检测表单中任意给定字段是否有效
  ls-type:: annotation
  hl-page:: 620
  hl-color:: yellow
  id:: 63d27f9b-f44f-4c26-9a3e-222e65f567fb
- 字段值不匹配 pattern 属性也会被视为无效
  ls-type:: annotation
  hl-page:: 620
  hl-color:: yellow
  id:: 63d27fb5-1575-4d79-9506-aeb2b639452c
- 要检查整个表单是否有效，可以直接在表单上调用 checkValidity()方法
  ls-type:: annotation
  hl-page:: 621
  hl-color:: yellow
  id:: 63d284e7-b558-420e-a30f-7ded75b51c87
- validity 属性会告诉我们字段为什么有效或无效
  ls-type:: annotation
  hl-page:: 621
  hl-color:: yellow
  id:: 63d284f8-4ec5-4d26-b3bd-74cf7f4a0862
- 禁用验证
  ls-type:: annotation
  hl-page:: 621
  hl-color:: green
  id:: 63d28501-a5db-4749-812f-1143ddccbca7
- 通过指定 novalidate 属性可以禁止对表单进行任何验证
  ls-type:: annotation
  hl-page:: 621
  hl-color:: yellow
  id:: 63d28576-0f8d-4dd3-ab97-e8cf328b004c
- 这个值也可以通过 JavaScript 属性 noValidate 检索或设置，设置为 true 表示属性存在，设置为 false 表示属性不存在
  ls-type:: annotation
  hl-page:: 621
  hl-color:: yellow
  id:: 63d285e0-314b-40bc-a083-f26966c8ccd3
- 选择框编程
  ls-type:: annotation
  hl-page:: 622
  hl-color:: green
  id:: 63d28645-5d52-480c-8638-fbe71e03c056
- 方便交互，HTMLSelectElement 类型在所有表单字段的公共能力之外又提供了以下属性和方法
  ls-type:: annotation
  hl-page:: 622
  hl-color:: yellow
  id:: 63d2872e-d2bd-48e4-bcef-f40c39f88da5
- 选择框的 type 属性可能是"select-one"或"select-multiple"，具体取决于 multiple 属性是否存在
  ls-type:: annotation
  hl-page:: 622
  hl-color:: yellow
  id:: 63d28741-4c8b-4088-a7b7-400edf20588c
- 选择框是使用<select>和<option>元素创建的
  ls-type:: annotation
  hl-page:: 622
  hl-color:: yellow
  id:: 63d2875d-4412-4e61-b2cf-42687811ed92
- 如果文本为"China"的项被选中，则字段的值是一个空字符串，因为该项的 value 属性是空字符串
  ls-type:: annotation
  hl-page:: 622
  hl-color:: yellow
  id:: 63d28c1e-74be-4ce2-be6e-746d46893fc9
- 如果选中最后一项，那么字段的值是"Australia"，因为该<option>元素没有指定 value 属性。
  ls-type:: annotation
  hl-page:: 622
  hl-color:: yellow
  id:: 63d28c2c-af36-4d48-b714-1e3241e664aa
- 大多数<option>属性是为了方便存取选项数据。可以使用常规 DOM 功能存取这些信息，只是效率比较低
  ls-type:: annotation
  hl-page:: 623
  hl-color:: yellow
  id:: 63d28c6d-fbc0-487f-bd5d-0bc6567c9c22
- 而选择框会在选中一项时立即触发 change 事件
  ls-type:: annotation
  hl-page:: 623
  hl-color:: yellow
  id:: 63d28c8a-fc12-4016-8c09-694110addf04
- 选项处理
  ls-type:: annotation
  hl-page:: 623
  hl-color:: green
  id:: 63d28c91-6b5d-437b-93fa-4938636322ef
- 对于只允许选择一项的选择框，获取选项最简单的方式是使用选择框的 selectedIndex 属性
  ls-type:: annotation
  hl-page:: 623
  hl-color:: yellow
  id:: 63d28cac-b491-4e9e-bce2-cdce5d5d6436
- 对于允许多选的选择框，selectedIndex 属性就像只允许选择一项一样
  ls-type:: annotation
  hl-page:: 623
  hl-color:: yellow
  id:: 63d28cc5-79b3-4099-a4d0-57300bbc3e9d
- 与 selectedIndex 不同，设置选项的 selected 属性不会在多选时移除其他选项，从而可以动态选择任意多个选项。
  ls-type:: annotation
  hl-page:: 624
  hl-color:: yellow
  id:: 63d28cd9-649d-403d-b31e-3fcd30d08153
- 通过 selected 属性可以确定选择框中哪个选项被选中。
  ls-type:: annotation
  hl-page:: 624
  hl-color:: yellow
  id:: 63d28d1f-df88-4eb5-890f-c2c384c6a418
- 添加选项
  ls-type:: annotation
  hl-page:: 624
  hl-color:: green
  id:: 63d28d32-f5f0-41c8-a069-e26bc31655e6
- 可以使用 DOM 方法
  ls-type:: annotation
  hl-page:: 624
  hl-color:: yellow
  id:: 63d28d44-c655-47f2-a627-b274e41f2055
- 也可以使用 Option 构造函数创建新选项
  ls-type:: annotation
  hl-page:: 625
  hl-color:: yellow
  id:: 63d28daa-a98e-470e-a22b-0a248d4067c1
- 添加新选项的方式是使用选择框的 add()方法
  ls-type:: annotation
  hl-page:: 625
  hl-color:: yellow
  id:: 63d28dbb-84b6-48f2-be85-a591abb32f77
- 要添加的新选项和要添加到其前面的参考选项
  ls-type:: annotation
  hl-page:: 625
  hl-color:: yellow
  id:: 63d28dc6-3f7c-4c02-a724-93f24451ecf2
- 移除选项
  ls-type:: annotation
  hl-page:: 625
  hl-color:: green
  id:: 63d28eac-436d-455b-bef9-578ce4c472fa
- 使用 DOM 的 removeChild()方法并传入要移除的选项
  ls-type:: annotation
  hl-page:: 625
  hl-color:: yellow
  id:: 63d28eb5-2641-4ba1-b704-92bc65202919
- 使用选择框的 remove()方法。这个方法接收一个参数，即要移除选项的索引
  ls-type:: annotation
  hl-page:: 625
  hl-color:: yellow
  id:: 63d28ebd-b01f-4e6c-8c81-3b1616c52aa3
- 直接将选项设置为等于 null
  ls-type:: annotation
  hl-page:: 625
  hl-color:: yellow
  id:: 63d28ec4-44ea-4514-84a3-097e83aea435
- 移动和重排选项
  ls-type:: annotation
  hl-page:: 626
  hl-color:: green
  id:: 63d28f84-a250-44d8-920d-47ad184c6179
  hl-stamp:: 1674743693164
- 移除第一项会自动将所有选项向前移一位
  ls-type:: annotation
  hl-page:: 626
  hl-color:: yellow
  id:: 63d28f88-1617-4fab-89e0-767ac550e217
- DOM 方法则可以直接将某个选项从第一个选择框移动到第二个选择框，只要对相应选项使用 appendChild()方法即可
  ls-type:: annotation
  hl-page:: 626
  hl-color:: yellow
  id:: 63d28fa7-0d3e-4401-b0b5-b61e272a5d35
- 将 选 项 移 动 到 选 择 框 中 的 特 定 位 置 ， insertBefore()方法是最合适的。
  ls-type:: annotation
  hl-page:: 626
  hl-color:: yellow
  id:: 63d28fb8-32d5-4d74-aff6-be82cbe0ebfb
- 把选项移动到最后，还是 appendChild()方法比较方便
  ls-type:: annotation
  hl-page:: 626
  hl-color:: yellow
  id:: 63d28fc4-776a-4dc6-a3b2-37f1f4fbf2e9
- 表单序列化
  ls-type:: annotation
  hl-page:: 626
  hl-color:: green
  id:: 63d29058-b1ac-4c57-bede-8ebeba2a74f8
- 表单在 JavaScript 中可以使用表单字段的 type 属性连同其 name 属性和 value 属性来进行序列化
  ls-type:: annotation
  hl-page:: 626
  hl-color:: yellow
  id:: 63d290b7-c474-4c4c-ae1b-4257a0f81865
- 表单序列化通常不包含任何按钮，因为序列化得到的字符串很可能以其他方式提交
  ls-type:: annotation
  hl-page:: 627
  hl-color:: yellow
  id:: 63d290c5-e4d6-41de-8736-2a2c1a2dfc90
- 不过 value 属性为空字符串是完全有效的
  ls-type:: annotation
  hl-page:: 627
  hl-color:: yellow
  id:: 63d291d0-88af-4860-bcb5-457c145e4b2e
- 表单中如果有<fieldset>元素，它就会出现在元素集合中，但应该没有 type 属性
  ls-type:: annotation
  hl-page:: 628
  hl-color:: yellow
  id:: 63d291da-e7c1-4b77-bbc1-65cb291be39b
- 对于单选按钮和复选框，会检测其 checked 属性。如果值为 false 就退出 switch 语句；如果值为 true，则继续执行 default 分支，将字段的名和值编码后添加到 parts 数组
  ls-type:: annotation
  hl-page:: 628
  hl-color:: yellow
  id:: 63d291f1-f09f-4217-b17a-9127632b003a
- 富文本编辑
  ls-type:: annotation
  hl-page:: 628
  hl-color:: green
  id:: 63d2929a-765d-43f2-95bd-3a36150fc930
- 这个函数的最后一步是使用 join()通过和号把所有字段的名值对拼接起来。
  ls-type:: annotation
  hl-page:: 628
  hl-color:: yellow
  id:: 63d292e9-0c45-496f-af8c-d72d4a85cbcf
- 基本的技术就是在空白 HTML 文件中嵌入一个 iframe。
  ls-type:: annotation
  hl-page:: 628
  hl-color:: yellow
  id:: 63d29300-f853-4a4e-96e8-3333e48ca618
- 通过 designMode 属性，可以将这个空白文档变成可以编辑的，实际编辑的则是<body>元素的 HTML。
  ls-type:: annotation
  hl-page:: 628
  hl-color:: yellow
  id:: 63d2932d-b468-4686-8591-c0b04aad79eb
- 这个页面会像其他任何页面一样加载到 iframe 里
  ls-type:: annotation
  hl-page:: 628
  hl-color:: yellow
  id:: 63d2933d-892b-48ac-a263-72d1b225043e
- 在这个包含页面内，需要使用 onload事件处理程序在适当时机设置 designMode，
  ls-type:: annotation
  hl-page:: 628
  hl-color:: yellow
  id:: 63d29345-4d66-4d21-a39a-69b7360c4995
- 使用 contenteditable
  ls-type:: annotation
  hl-page:: 628
  hl-color:: green
  id:: 63d2939c-b4b4-4190-9f25-7db99665bf95
- 元 素 中 包 含 的 任 何 文 本 都 会 自 动 被 编 辑 ， 元 素 本 身 类 似 于 <textarea> 元 素
  ls-type:: annotation
  hl-page:: 629
  hl-color:: yellow
  id:: 63d2940c-80eb-496b-930f-2b9fb15aec20
- "true"表示开启，"false"表示关闭，"inherit"表示继承父元素的设置（因为在 contenteditable 元素内部会创建和删除元素
  ls-type:: annotation
  hl-page:: 629
  hl-color:: yellow
  id:: 63d29415-de8d-498e-8b40-48c8a1baafbd
- 与富文本交互
  ls-type:: annotation
  hl-page:: 629
  hl-color:: green
  id:: 63d2941b-bc6f-441c-ae76-b70659218630
- 与富文本编辑器交互的主要方法是使用 document.execCommand()。
  ls-type:: annotation
  hl-page:: 629
  hl-color:: yellow
  id:: 63d29483-c649-4972-b11c-45b307df8f8f
- document.execCommand()可以接收 3 个参数：要执行的命令、表示浏览器是否为命令提供用户界面的布尔值和执行命令必需的值（如果不需要则为 null）。
  ls-type:: annotation
  hl-page:: 629
  hl-color:: yellow
  id:: 63d29497-edcc-456b-bdce-1559faa02ffa
- 同样的方法也可以用于页面中添加了 contenteditable 属性的元素
  ls-type:: annotation
  hl-page:: 630
  hl-color:: yellow
  id:: 63d294f6-e458-4279-846f-3b49a57a9c1a
- 在富文本编辑中，不能依赖浏览器生成的 HTML，因为命令实现和格式转换都是通过 innerHTML 完成的
  ls-type:: annotation
  hl-page:: 630
  hl-color:: yellow
  id:: 63d29581-63ba-48b6-a45c-f501e7f88a11
- queryCommandEnabled()，此方法用于确定对当前选中文本或光标所在位置是否可以执行相关命令。
  ls-type:: annotation
  hl-page:: 631
  hl-color:: yellow
  id:: 63d2958d-5ad8-4702-8296-cc9db51064fb
- 参数，即要检查的命令名
  ls-type:: annotation
  hl-page:: 631
  hl-color:: yellow
  id:: 63d29616-d048-45f8-bbea-4f283b6ead29
- queryCommandState()用于确定相关命令是否应用到了当前文本选区
  ls-type:: annotation
  hl-page:: 631
  hl-color:: yellow
  id:: 63d29641-ac4c-4cb3-9c4e-f45d24c0ca5e
- queryCommandValue()，此方法可以返回执行命令时使用的值
  ls-type:: annotation
  hl-page:: 631
  hl-color:: yellow
  id:: 63d2964f-c52f-4de9-9b91-61998263eadb
- 富文件选择
  ls-type:: annotation
  hl-page:: 631
  hl-color:: green
  id:: 63d29656-bd9e-4184-acf6-a1f6bc118341
- 在内嵌窗格中使用 getSelection()方法，可以获得富文本编辑器的选区。
  ls-type:: annotation
  hl-page:: 631
  hl-color:: yellow
  id:: 63d29679-f26d-44ae-844e-021effbcc76c
- 返回表示当前选中文本的 Selection 对象
  ls-type:: annotation
  hl-page:: 631
  hl-color:: yellow
  id:: 63d29699-0659-4272-91a7-46bbf4371836
- 这个 selection 对象是 document 的属性。要取得富文本编辑器中选中的文本，必须先创建一个文本范围，然后再访问其 text 属性
  ls-type:: annotation
  hl-page:: 632
  hl-color:: yellow
  id:: 63d296e0-e3b3-4650-9026-8399a77aa2d8
- 通过表单提交富文本
  ls-type:: annotation
  hl-page:: 632
  hl-color:: green
  id:: 63d2977e-d3c7-4dd5-b40c-09fe99f77e46
- 所以富文本编辑器技术上与表单没有关系。这意味着要把富文本编辑的结果提交给服务器，必须手工提取 HTML 并自己提交
  ls-type:: annotation
  hl-page:: 632
  hl-color:: yellow
  id:: 63d29792-9303-49a1-ad05-7e89c762f74c
- ，代码使用文档主体的 innerHTML 属性取得了内嵌窗格的 HTM
  ls-type:: annotation
  hl-page:: 633
  hl-color:: yellow
  id:: 63d2980d-ac67-4f64-ab18-1ada9e93d265
- 如果使用 submit()方法手工提交表单，那么要注意在提交前先执行上述操作。对于 contenteditable 元素，执行这一操作的代码是类似的
  ls-type:: annotation
  hl-page:: 633
  hl-color:: yellow
  id:: 63d298c4-952b-468e-bf36-16df4bf16a6a
- 因此要将富文本内容提交到服务器，必须把 HTML 从 iframe 或 contenteditable元素中复制到一个表单字段
  ls-type:: annotation
  hl-page:: 633
  hl-color:: yellow
  id:: 63d29988-bf19-47c0-9c02-369beaa5d7c4
- Atomics 与 SharedArrayBuffer
  ls-type:: annotation
  hl-page:: 634
  hl-color:: green
  id:: 63d299c0-c872-43ba-af90-cda183055140
- Atomics API 通过强制同一时刻只能对缓冲区执行一个操作，可以让多个上下文安全地读写一个 SharedArrayBuffer。
  ls-type:: annotation
  hl-page:: 634
  hl-color:: yellow
  id:: 63d3283e-6e8f-47f7-8d4c-3278cfba4934
- SharedArrayBuffer
  ls-type:: annotation
  hl-page:: 635
  hl-color:: green
  id:: 63d32856-f8f6-4cb6-8627-4b95e4a3ccde
- SharedArrayBuffer 与 ArrayBuffer 具有同样的 API
  ls-type:: annotation
  hl-page:: 635
  hl-color:: yellow
  id:: 63d32887-ad0a-44d6-86cb-ab6c2dc0ca3f
- SharedArrayBuffer 则可以被任意多个执行上下文同时使用。
  ls-type:: annotation
  hl-page:: 635
  hl-color:: yellow
  id:: 63d3288e-e5cd-4b1a-9055-6e33d7c9b884
- 原子操作基础
  ls-type:: annotation
  hl-page:: 636
  hl-color:: green
  id:: 63d328eb-fad0-4765-a051-1b4947539311
- 任何全局上下文中都有 Atomics 对象，这个对象上暴露了用于执行线程安全操作的一套静态方法，
  ls-type:: annotation
  hl-page:: 636
  hl-color:: yellow
  id:: 63d328fa-593d-412d-9d99-903dcdf16794
- 算术及位操作方法
  ls-type:: annotation
  hl-page:: 636
  hl-color:: green
  id:: 63d32907-c2ae-457d-86c6-b6b0565f886c
- 原子读和写
  ls-type:: annotation
  hl-page:: 638
  hl-color:: green
  id:: 63d3297a-9081-42b9-9dd5-10717649d0d7
- 但多线程下的指令重排可能导致资源争用，而且极难排错
  ls-type:: annotation
  hl-page:: 638
  hl-color:: yellow
  id:: 63d329c1-7881-406b-8c33-58e7b07b4609
- 所有原子指令相互之间的顺序永远不会重排。
  ls-type:: annotation
  hl-page:: 638
  hl-color:: yellow
  id:: 63d329c4-66e0-40e1-9647-554c80c4208e
- 使用原子读或原子写保证所有指令（包括原子和非原子指令）都不会相对原子读/写重新排序
  ls-type:: annotation
  hl-page:: 638
  hl-color:: yellow
  id:: 63d329cf-7ced-4055-9e57-2e2935c6739e
- 原子交换
  ls-type:: annotation
  hl-page:: 638
  hl-color:: green
  id:: 63d329e6-f0a0-4987-b0ec-f42c9833b132
- Atomics.exchange()执行简单的交换，以保证其他线程不会中断值的交换
  ls-type:: annotation
  hl-page:: 638
  hl-color:: yellow
  id:: 63d32a05-c41a-422e-a013-36ec6e2d08a0
- Atomics API 提供了 compareExchange()方法。这个方法只在目标索引处的值与预期值匹配时才会执行写操作。
  ls-type:: annotation
  hl-page:: 639
  hl-color:: yellow
  id:: 63d32a18-c74a-4e5a-b28c-6853600af671
- 原子 Futex 操作与加锁
  ls-type:: annotation
  hl-page:: 639
  hl-color:: green
  id:: 63d32a2d-8ff8-46f9-8d04-cc7bf470c8a2
- Atomics.wait()和 Atomics.notify()通过示例很容易理解
  ls-type:: annotation
  hl-page:: 639
  hl-color:: yellow
  id:: 63d32a3e-5291-4029-9fe6-dea83bf06222
- 因为是使用 0 来初始化 SharedArrayBuffer，所以每个工作线程都会到达 Atomics.wait()并停止执行。
  ls-type:: annotation
  hl-page:: 641
  hl-color:: yellow
  id:: 63d32aa6-2375-4419-b6a5-9eeb7cc1eeed
- Atomics.isLockFree()是一个优化原语。
  ls-type:: annotation
  hl-page:: 641
  hl-color:: yellow
  id:: 63d32af6-b788-49ac-b2ff-193f1772b15e
- 跨上下文消息
  ls-type:: annotation
  hl-page:: 641
  hl-color:: green
  id:: 63d32afd-92c4-4c63-a447-dd4b339ffefd
- 跨文档消息，有时候也简称为 XDM（cross-document messaging），是一种在不同执行上下文（如不同工作线程或不同源的页面）间传递信息的能力
  ls-type:: annotation
  hl-page:: 641
  hl-color:: yellow
  id:: 63d32b0d-462b-4dcf-af30-6d81d0c40902
- 跨 上 下 文 消 息 用 于 窗 口 之 间 通 信 或 工 作 线 程 之 间 通 信 。 本
  ls-type:: annotation
  hl-page:: 641
  hl-color:: yellow
  id:: 63d32c22-0f70-4ba1-a333-c92722b637c9
  hl-stamp:: 1674783813444
- postMessage()方法接收 3 个参数：消息、表示目标接收源的字符串和可选的可传输对象的数组（只与工作线程相关）。
  ls-type:: annotation
  hl-page:: 641
  hl-color:: yellow
  id:: 63d32c3e-e61f-486a-8cab-9aa54e5051f3
- 最后一行代码尝试向内嵌窗格中发送一条消息，而且指定了源必须是"http://www.wrox.com"。
  ls-type:: annotation
  hl-page:: 641
  hl-color:: yellow
  id:: 63d32c63-01be-4760-b8a8-4da2604337b6
- 接收到 XDM 消息后，window 对象上会触发 message 事件。这个事件是异步触发的
  ls-type:: annotation
  hl-page:: 641
  hl-color:: yellow
  id:: 63d32c85-9599-4751-920b-0bec53285faa
- source：发送消息的文档中 window 对象的代理。
  ls-type:: annotation
  hl-page:: 642
  hl-color:: yellow
  id:: 63d32c98-0983-4cb5-8c1f-d857797b28a6
- 在 onmessage 事件处理程序中检查发送窗口的源可以保证数据来自正确的地方
  ls-type:: annotation
  hl-page:: 642
  hl-color:: yellow
  id:: 63d32cb4-69fd-44b0-b9fe-cd26f4f063ab
- 大多数情况下，event.source 是某个 window 对象的代理，而非实际的 window 对象。
  ls-type:: annotation
  hl-page:: 642
  hl-color:: yellow
  id:: 63d32cce-6a08-4e40-9c0e-8c6e71cd327f
- Encoding API
  ls-type:: annotation
  hl-page:: 642
  hl-color:: green
  id:: 63d32d27-0a68-456f-ac5d-7beb90e422fb
- Encoding API 主要用于实现字符串与定型数组之间的转换。
  ls-type:: annotation
  hl-page:: 642
  hl-color:: yellow
  id:: 63d32d57-46c8-4927-b2e0-4646d12e47ce
- 文本编码
  ls-type:: annotation
  hl-page:: 642
  hl-color:: green
  id:: 63d32d60-20df-48db-8f09-189d0f5e0b58
- 两种将字符串转换为定型数组二进制格式的方法：批量编码和流编码。
  ls-type:: annotation
  hl-page:: 642
  hl-color:: yellow
  id:: 63d32d77-9e31-46a1-9d91-5ddc8d476500
- 批量编码
  ls-type:: annotation
  hl-page:: 643
  hl-color:: green
  id:: 63d32dac-5855-4ba1-8fad-5b63cc314a43
- 同步编码整个字符串
  ls-type:: annotation
  hl-page:: 643
  hl-color:: yellow
  id:: 63d32dc1-5a25-45f2-a906-58b8f138ca68
- 批量编码是通过 TextEncoder 的实例完成的
  ls-type:: annotation
  hl-page:: 643
  hl-color:: yellow
  id:: 63d32dcf-2766-465c-8daf-90d2a55df261
- 实例上有一个 encode()方法，该方法接收一个字符串参数，并以 Uint8Array 格式返回每个字符的 UTF-8 编码
  ls-type:: annotation
  hl-page:: 643
  hl-color:: yellow
  id:: 63d32dfc-f020-44bb-8edb-fed0a304acc0
- encodeInto()方法，该方法接收一个字符串和目标 Unit8Array，返回一个字典，该字典包含 read 和 written 属性，分别表示成功从源字符串读取了多少字符和向目标数组写入了多少字符。
  ls-type:: annotation
  hl-page:: 643
  hl-color:: yellow
  id:: 63d32e5b-2dbe-4f20-9052-d69e6785491c
- 流编码
  ls-type:: annotation
  hl-page:: 643
  hl-color:: green
  id:: 63d32e6f-d9d3-4106-bfc6-9bf0b1b958e1
- 解码后的文本流通过管道输入流编码器会得到编码后文本块的流
  ls-type:: annotation
  hl-page:: 643
  hl-color:: yellow
  id:: 63d32e7a-e360-4865-87a2-06d5dfbb7837
- 文本解码
  ls-type:: annotation
  hl-page:: 644
  hl-color:: green
  id:: 63d32eea-cc3a-4226-8b70-3ad69201e87e
- 两种将定型数组转换为字符串的方式：批量解码和流解码。
  ls-type:: annotation
  hl-page:: 644
  hl-color:: yellow
  id:: 63d32ef8-ef6c-430e-8c9b-8436eeed9e5e
- 批量解码
  ls-type:: annotation
  hl-page:: 644
  hl-color:: green
  id:: 63d32eff-e047-4459-b60e-19ee6097109d
- 批量解码是通过 TextDecoder 的实例完成的
  ls-type:: annotation
  hl-page:: 644
  hl-color:: yellow
  id:: 63d32f10-8be8-4b69-9164-53cd7c7de62a
  hl-stamp:: 1674784532487
- decode()方法，该方法接收一个定型数组参数，返回解码后的字符串：
  ls-type:: annotation
  hl-page:: 644
  hl-color:: yellow
  id:: 63d32f26-732f-43c8-8a91-99b4d03a8399
- 解码器不关心传入的是哪种定型数组，它只会专心解码整个二进制表示。
  ls-type:: annotation
  hl-page:: 645
  hl-color:: yellow
  id:: 63d32f64-8d90-4eec-b3d5-f964c7be5d6b
- 与 TextEncoder 不同，TextDecoder 可以兼容很多字符编码。
  ls-type:: annotation
  hl-page:: 645
  hl-color:: yellow
  id:: 63d32f80-e19d-4fc4-9b5f-64f5c45dc1cf
- 流解码
  ls-type:: annotation
  hl-page:: 645
  hl-color:: green
  id:: 63d32f89-f3d1-44ab-80a5-6fe0ae58dfd7
- TextDecoderStream 其实就是 TransformStream 形式的 TextDecoder。将编码后的文本流通过管道输入流解码器会得到解码后文本块的流
  ls-type:: annotation
  hl-page:: 645
  hl-color:: yellow
  id:: 63d32f97-3730-49ff-9a8f-e3cf0e1f316c
- 文本解码器流经常与 fetch()一起使用，因为响应体可以作为 ReadableStream 来处理。
  ls-type:: annotation
  hl-page:: 646
  hl-color:: yellow
  id:: 63d32fb4-92b2-41b5-949b-00c8092eddc5
- File API 与 Blob API
  ls-type:: annotation
  hl-page:: 647
  hl-color:: green
  id:: 63d3300d-4bf8-4b6e-aeb2-5f30fb852db6
- File 类型
  ls-type:: annotation
  hl-page:: 647
  hl-color:: green
  id:: 63d33026-43fe-4b57-bf62-f4e4c577eb21
- File API 仍然以表单中的文件输入字段为基础，但是增加了直接访问文件信息的能力。
  ls-type:: annotation
  hl-page:: 647
  hl-color:: yellow
  id:: 63d33057-6ec4-4152-a88c-5aaf23d71e08
- HTML5 在 DOM 上为文件输入元素添加了 files 集合
  ls-type:: annotation
  hl-page:: 647
  hl-color:: yellow
  id:: 63d33063-52e5-4e74-a5f3-2dc49468c454
- FileReader 类型
  ls-type:: annotation
  hl-page:: 647
  hl-color:: green
  id:: 63d33075-4572-4ee4-90fc-0ba8dac5a380
- FileReader 类型表示一种异步文件读取机制。
  ls-type:: annotation
  hl-page:: 647
  hl-color:: yellow
  id:: 63d330b9-2861-461d-a86a-688039a95fc2
- readAsText(file, encoding)：从文件中读取纯文本内容并保存在 result 属性中。
  ls-type:: annotation
  hl-page:: 647
  hl-color:: yellow
  id:: 63d330c4-4600-4fd1-b7eb-61833d6886d6
- readAsDataURL(file)：读取文件并将内容的数据 URI 保存在 result 属性中
  ls-type:: annotation
  hl-page:: 648
  hl-color:: yellow
  id:: 63d33127-e6c0-428d-b341-bab696ea1a0a
- readAsBinaryString(file)：读取文件并将每个字符的二进制数据保存在 result 属性中
  ls-type:: annotation
  hl-page:: 648
  hl-color:: yellow
  id:: 63d3312f-7eb9-4193-951e-cca1675c8385
- readAsArrayBuffer(file)：读取文件并将文件内容以 ArrayBuffer 形式保存在 result 属性
  ls-type:: annotation
  hl-page:: 648
  hl-color:: yellow
  id:: 63d33139-0f69-408b-948a-8afcbacf4d6d
- 中 3 个最有用的事件是 progress、error 和 load，分别表示还有更多数据、发生了错误和读取完成。
  ls-type:: annotation
  hl-page:: 648
  hl-color:: yellow
  id:: 63d3319c-2ab4-4415-8e36-598e457b7de2
- progress 事件每 50 毫秒就会触发一次，
  ls-type:: annotation
  hl-page:: 648
  hl-color:: yellow
  id:: 63d331c2-336f-48b6-8ecb-0aa66ebe31ec
- error 事件会在由于某种原因无法读取文件时触发。
  ls-type:: annotation
  hl-page:: 648
  hl-color:: yellow
  id:: 63d3323e-dbcf-4bb1-b888-e3f6e00474f0
- load 事件会在文件成功加载后触发。
  ls-type:: annotation
  hl-page:: 648
  hl-color:: yellow
  id:: 63d33245-07f4-4339-bfe1-30b504ac8272
- FileReaderSync 类型
  ls-type:: annotation
  hl-page:: 649
  hl-color:: green
  id:: 63d3324d-1910-44be-8d3c-85c9e3e364ba
- FileReaderSync 类型就是 FileReader 的同步版本。
  ls-type:: annotation
  hl-page:: 649
  hl-color:: yellow
  id:: 63d3332a-7124-4fdd-95bf-f258672ace97
- 拥有与 FileReader相同的方法，只有在整个文件都加载到内存之后才会继续执行。
  ls-type:: annotation
  hl-page:: 649
  hl-color:: yellow
  id:: 63d33349-9b48-4be0-928c-2529ff403234
- Blob 与部分读取
  ls-type:: annotation
  hl-page:: 649
  hl-color:: green
  id:: 63d33350-d4e2-4fa2-acd7-2a443545a6fd
- slice()方法接收两个参数：起始字节和要读取的字节数。
  ls-type:: annotation
  hl-page:: 649
  hl-color:: yellow
  id:: 63d3336d-a37a-47b1-a624-687cc8be7bff
- 回一个 Blob 的实例，而 Blob 实际上是 File 的超类。
  ls-type:: annotation
  hl-page:: 649
  hl-color:: yellow
  id:: 63d33374-a21e-4e54-9afe-b69db3247751
- blob 表示二进制大对象（binary larget object），是 JavaScript 对不可修改二进制数据的封装类型。
  ls-type:: annotation
  hl-page:: 649
  hl-color:: yellow
  id:: 63d3337d-31d9-401e-b393-6f224551af15
- Blob 对象有一个 size 属性和一个 type 属性，还有一个 slice()方法用于进一步切分数据。另外也可以使用 FileReader 从 Blob 中读取数据。
  ls-type:: annotation
  hl-page:: 650
  hl-color:: yellow
  id:: 63d3338c-4b24-4bee-ba6c-d9d7ce7fa76a
- 对象 URL 与 Blob
  ls-type:: annotation
  hl-page:: 650
  hl-color:: green
  id:: 63d333b4-8865-48dc-bb72-818521ea5b01
- 对象 URL 有时候也称作 Blob URL，是指引用存储在 File 或 Blob 中数据的 URL。
  ls-type:: annotation
  hl-page:: 650
  hl-color:: yellow
  id:: 63d333c2-a914-461a-baf4-9a886c24ae16
- 不用把文件内容读取到 JavaScript 也可以使用文件。只要在适当位置提供对象 URL 即可
  ls-type:: annotation
  hl-page:: 650
  hl-color:: yellow
  id:: 63d333c9-dd4f-4095-958d-3d5d9911f313
- 可以使用 window.URL.createObjectURL()方法并传入 File 或 Blob 对象
  ls-type:: annotation
  hl-page:: 650
  hl-color:: yellow
  id:: 63d333f9-8c9f-4160-930a-927b7bb239ee
- 如果想表明不再使用某个对象 URL，则可以把它传给 window.URL.revokeObjectURL()
  ls-type:: annotation
  hl-page:: 651
  hl-color:: yellow
  id:: 63d3341e-9c14-45cd-8870-769125d4879b
- 读取拖放文件
  ls-type:: annotation
  hl-page:: 651
  hl-color:: green
  id:: 63d33444-4063-4125-b633-371f7ebc85ff
- 被放置的文件可以通过事件的 event.dataTransfer.files 属性读到，这个属性保存着一组 File 对象
  ls-type:: annotation
  hl-page:: 651
  hl-color:: yellow
  id:: 63d33461-5b3d-4c19-bb14-aa30c15a6bf7
- 与后面要介绍的拖放的例子一样，必须取消 dragenter、dragover 和 drop 的默认行为
  ls-type:: annotation
  hl-page:: 651
  hl-color:: yellow
  id:: 63d33482-fe02-46d2-be2f-be27030d78da
- event.preventDefault();
  ls-type:: annotation
  hl-page:: 651
  hl-color:: yellow
  id:: 63d33496-c26c-41b9-b436-95152fcc23f3
- 媒体元素
  ls-type:: annotation
  hl-page:: 652
  hl-color:: green
  id:: 63d3349a-279a-4ac0-ac37-e20882ff5834
- 新增了两个与媒体相关的元素，即<audio>和<video>，从而为浏览器提供了嵌入音频和视频的统一解决方案
  ls-type:: annotation
  hl-page:: 652
  hl-color:: yellow
  id:: 63d334aa-a30f-41ae-adaf-49921503c8f6
- 既支持 Web 开发者在页面中嵌入媒体文件，也支持 JavaScript 实现对媒体的自定义控制
  ls-type:: annotation
  hl-page:: 652
  hl-color:: yellow
  id:: 63d33759-7abb-4002-857f-422417b758c8
- 每个元素至少要求有一个 src 属性，以表示要加载的媒体文件。
  ls-type:: annotation
  hl-page:: 652
  hl-color:: yellow
  id:: 63d3375d-91a2-4cdd-a3b0-72ef548a8b9d
- 属性
  ls-type:: annotation
  hl-page:: 652
  hl-color:: green
  id:: 63d33771-8a9f-44bd-b634-15c4962bc3bd
- 事件
  ls-type:: annotation
  hl-page:: 653
  hl-color:: green
  id:: 63d33842-033a-4de4-9284-79a176119633
- 自定义媒体播放器
  ls-type:: annotation
  hl-page:: 654
  hl-color:: green
  id:: 63d3384e-c34c-4dcf-8a70-be15dee4bbd7
- 这里的 JavaScript 代码简单地为按钮添加了事件处理程序，可以根据当前状态播放和暂停视频。
  ls-type:: annotation
  hl-page:: 655
  hl-color:: yellow
  id:: 63d33882-0397-4776-946a-1d1cdecc941e
- 检测编解码器
  ls-type:: annotation
  hl-page:: 655
  hl-color:: green
  id:: 63d33888-7b74-41f5-a961-063ad5d75dcc
- 检测浏览器是否支持给定格式和编解码器。这两个媒体元素都有一个名为 canPlayType()的方法，该方法接收一个格式/编解码器字符串，返回一个字符串值："probably"、"maybe"或""（空字符串），
  ls-type:: annotation
  hl-page:: 655
  hl-color:: yellow
  id:: 63d338a1-12a9-42ca-ae1a-d88614641b92
- 音频类型
  ls-type:: annotation
  hl-page:: 656
  hl-color:: green
  id:: 63d338b0-cdc0-46b2-8125-7a7ddb268abc
- 在 iOS 中调用 play()方法会弹出一个对话框，请求用户授权播放声音。为了连续播放，必须在 onfinish 事件处理程序中立即调用 play()。
  ls-type:: annotation
  hl-page:: 656
  hl-color:: yellow
  id:: 63d338d2-3acd-4ebd-90ca-abd65ff0bd2f
- <audio>元素还有一个名为 Audio 的原生 JavaScript 构造函数，支持在任何时候播放音频。
  ls-type:: annotation
  hl-page:: 656
  hl-color:: yellow
  id:: 63d338dc-f09b-4b54-a42b-a6ba7233fba1
- 原生拖放
  ls-type:: annotation
  hl-page:: 656
  hl-color:: green
  id:: 63d338e4-8da7-4a0d-8032-62247f0e5e90
- 时，网页中只有两样东西可以触发拖放：图片和文本
  ls-type:: annotation
  hl-page:: 656
  hl-color:: yellow
  id:: 63d33908-5600-4224-ada9-92f058b1295f
- E5 扩展了拖放能力，添加了新的事件，让网页中几乎一切都可以成为放置目标
  ls-type:: annotation
  hl-page:: 656
  hl-color:: yellow
  id:: 63d33940-7fdc-4ccc-bf0f-1692f286f6ac
- 于拖放最有意思的可能就是可以跨窗格、跨浏览器容器，有时候甚至可以跨应用程序拖动元素。浏览器对拖放的支持可以让我们实现这些功能
  ls-type:: annotation
  hl-page:: 656
  hl-color:: yellow
  id:: 63d33947-12a2-49d0-a2e0-36e3f9e0caa6
- 拖放事件
  ls-type:: annotation
  hl-page:: 656
  hl-color:: green
  id:: 63d33949-e032-440f-8800-f63f77cc575e
- 某个元素被拖动时，会（按顺序）触发以下事件：
  ls-type:: annotation
  hl-page:: 656
  hl-color:: yellow
  id:: 63d33a31-c966-4194-bbd4-c47c8a7b7f69
- 在按住鼠标键不放并开始移动鼠标的那一刻，被拖动元素上会触发 dragstart 事件
  ls-type:: annotation
  hl-page:: 656
  hl-color:: yellow
  id:: 63d33a39-523a-49e0-8b46-80c7e01a3d92
- 拖动开始时，可以在 ondragstart事件处理程序中通过 JavaScript 执行某些操作。
  ls-type:: annotation
  hl-page:: 656
  hl-color:: yellow
  id:: 63d33a66-975e-4c54-93e6-9c7bc4bcf47b
- dragstart 事件触发后，只要目标还被拖动就会持续触发 drag 事件
  ls-type:: annotation
  hl-page:: 656
  hl-color:: yellow
  id:: 63d33a89-33c7-4ee6-b858-38db2a747c7b
- 当拖动停止时（把元素放到有效或无效的放置目标上），会触发 dragend事件。
  ls-type:: annotation
  hl-page:: 656
  hl-color:: yellow
  id:: 63d33a9a-05d2-493d-9d7c-03e44b293a5f
- 默认情况下，浏览器在拖动开始后不会改变被拖动元素的外观，因此是否改变外观由你来决定。
  ls-type:: annotation
  hl-page:: 657
  hl-color:: yellow
  id:: 63d33aac-ec2d-45dc-8ddd-820d59e07a65
- 多数浏览器此时会创建元素的一个半透明副本，始终跟随在光标下方。
  ls-type:: annotation
  hl-page:: 657
  hl-color:: yellow
  id:: 63d33ab0-fef4-407b-a7ae-0504425163dd
- 在把元素拖动到一个有效的放置目标上时，会依次触发以下事件：
  ls-type:: annotation
  hl-page:: 657
  hl-color:: yellow
  id:: 63d33ab5-8998-41ca-9e4d-d6ec1d3fb109
- 只要一把元素拖动到放置目标上，dragenter 事件（类似于 mouseover 事件）就会触发
  ls-type:: annotation
  hl-page:: 657
  hl-color:: yellow
  id:: 63d33ac5-b7bd-4459-a083-6e7f270e1fab
- dragenter事件触发之后，会立即触发 dragover 事件，并且元素在放置目标范围内被拖动期间此事件会持续触发。
  ls-type:: annotation
  hl-page:: 657
  hl-color:: yellow
  id:: 63d33ad7-53f2-4e69-ab85-fe568e6809a0
- 当元素被拖动到放置目标之外，dragover 事件停止触发，dragleave 事件触发（类似于 mouseout事件）。
  ls-type:: annotation
  hl-page:: 657
  hl-color:: yellow
  id:: 63d33ae3-2d18-4e6c-a6cd-d68bc353666b
- 如果被拖动元素被放到了目标上，则会触发 drop 事件而不是 dragleave 事件。
  ls-type:: annotation
  hl-page:: 657
  hl-color:: yellow
  id:: 63d33af1-f683-4a3e-a656-4bc50835174f
- 自定义放置目标
  ls-type:: annotation
  hl-page:: 657
  hl-color:: green
  id:: 63d33b05-8b56-4b9a-832f-a8d0c91b408d
- 如果把元素拖动到不允许放置的目标上，无论用户动作是什么都不会触发 drop 事件
  ls-type:: annotation
  hl-page:: 657
  hl-color:: yellow
  id:: 63d33b2b-5014-47dd-bda0-24bc08dcb100
- 置事件的默认行为是导航到放在放置目标上的 UR
  ls-type:: annotation
  hl-page:: 657
  hl-color:: yellow
  id:: 63d33b59-442b-45f9-be1f-27c37a8c2c77
- dataTransfer 对象
  ls-type:: annotation
  hl-page:: 657
  hl-color:: green
  id:: 63d33b7d-2153-4d31-ade9-b53264e92a07
- dataTransfer 对象，用于从被拖动元素向放置目标传递字符串数据
  ls-type:: annotation
  hl-page:: 657
  hl-color:: yellow
  id:: 63d33b94-5b29-47d2-9222-a84e4f7b1237
- dataTransfer 对象有两个主要方法：getData()和 setData()。
  ls-type:: annotation
  hl-page:: 658
  hl-color:: yellow
  id:: 63d33bca-e6dc-419a-9ddf-42368f0de4be
- 存储在 dataTransfer 对象中的数据只能在放置事件中读取。如果没有在 ondrop 事件处理程序中取得这些数据，dataTransfer 对象就会被销毁，数据也会丢失
  ls-type:: annotation
  hl-page:: 658
  hl-color:: yellow
  id:: 63d33be8-bb6c-4150-aa0b-31bde796356b
- 在拖动链接或图片时，浏览器会调用 setData()并把 URL 存储起来
  ls-type:: annotation
  hl-page:: 658
  hl-color:: yellow
  id:: 63d33c06-9ed6-45cf-81a1-03392ccbccd9
- dropEffect 与 effectAllowed
  ls-type:: annotation
  hl-page:: 658
  hl-color:: green
  id:: 63d33c20-2794-43c2-8eb7-e3fe2d949d71
- dropEffect 属性可以告诉浏览器允许哪种放置行为。
  ls-type:: annotation
  hl-page:: 658
  hl-color:: yellow
  id:: 63d33c32-50d7-46dd-912f-879072892253
- 为了使用 dropEffect 属性，必须在放置目标的 ondragenter 事件处理程序中设置它。
  ls-type:: annotation
  hl-page:: 659
  hl-color:: yellow
  id:: 63d33c81-8f17-41db-919d-6dacd5595c0e
  hl-stamp:: 1674788021614
- effectAllowed 属性表示对被拖动元素是否允许 dropEffect
  ls-type:: annotation
  hl-page:: 659
  hl-color:: yellow
  id:: 63d33c91-059a-4242-a46d-66a14fb1c2e7
- 必须在 ondragstart 事件处理程序中设置这个属性
  ls-type:: annotation
  hl-page:: 659
  hl-color:: yellow
  id:: 63d33cbf-9ab5-4790-9d32-2032b48ccd57
- 可拖动能力
  ls-type:: annotation
  hl-page:: 659
  hl-color:: green
  id:: 63d33cdc-5e97-4ed5-ad9f-55d932d2f5e4
- HTML5 在所有 HTML 元素上规定了一个 draggable 属性，表示元素是否可以拖动
  ls-type:: annotation
  hl-page:: 659
  hl-color:: yellow
  id:: 63d33ceb-4d54-4e99-bfc6-1baadad51d10
- 其他成员
  ls-type:: annotation
  hl-page:: 659
  hl-color:: green
  id:: 63d33da1-7c85-448c-842a-a8f283a72d82
- addElement(element)：为拖动操作添加元素。
  ls-type:: annotation
  hl-page:: 659
  hl-color:: yellow
  id:: 63d33db5-204f-4308-ac0c-0e3b19d66d5b
- clearData(format)：清除以特定格式存储的数据。
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33dbd-f315-46e6-83c4-06ccfcbefa81
  hl-stamp:: 1674788287389
- setDragImage(element, x, y)：允许指定拖动发生时显示在光标下面的图片
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33dc9-2de6-451d-9777-61f00e512d05
- types：当前存储的数据类型列表。
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33dd0-69a6-4cbe-aa79-491c88e7c89f
- Notifications API
  ls-type:: annotation
  hl-page:: 660
  hl-color:: green
  id:: 63d33dd6-b636-4232-ac4a-294b40f2a5ea
- Notifications API 在 Service Worker 中非常有用。渐进 Web 应用（PWA，Progressive Web Application）通过触发通知可以在页面不活跃时向用户显示消息，看起来就像原生应用。
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33e1c-f9c3-422f-bd1b-72f598daa1f8
- 通知权限
  ls-type:: annotation
  hl-page:: 660
  hl-color:: green
  id:: 63d33e27-1a95-4b07-9102-797ec0beb4fc
- Notifications API 有被滥用的可能，因此默认会开启两项安全措施：
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33e8b-5b54-4804-92ac-8d00d355accc
- 通知只能在运行在安全上下文的代码中被触发；
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33e94-39bc-4d75-9dc9-f9af44aaa8ec
- 通知必须按照每个源的原则明确得到用户允许。
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33e9a-1aac-4643-b3c2-116c1e3f53f8
- 页面可以使用全局对象 Notification 向用户请求通知权限。
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33ea8-66bf-4363-a3d6-f1e6ae50cf06
- 这个对象有一个 requestPemission()方法，该方法返回一个期约，用户在授权对话框上执行操作后这个期约会解决。
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33eb6-2869-4a68-b4f8-02fc2e4723f3
- "granted"值意味着用户明确授权了显示通知的权限
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33ef5-352c-42ac-9c5e-163d6f093478
- 如果用户拒绝授权，这个值就是"denied"
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33f00-808d-4f66-94f4-ad48d47c8261
- 显示和隐藏通知
  ls-type:: annotation
  hl-page:: 660
  hl-color:: green
  id:: 63d33f08-5410-4a40-a865-7dc03b88889f
- Notification 构造函数用于创建和显示通知
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33f17-a02b-4036-83c9-0a88bf1efdbf
- 可以通过 options 参数对通知进行自定义，包括设置通知的主体、图片和振动等
  ls-type:: annotation
  hl-page:: 660
  hl-color:: yellow
  id:: 63d33f51-4cf3-4e5a-ba4e-0d35ce15c9f9
- 调用这个构造函数返回的 Notification 对象的 close()方法可以关闭显示的通知
  ls-type:: annotation
  hl-page:: 661
  hl-color:: yellow
  id:: 63d33f5f-4e43-4a2f-b2e3-28a6e49b5904
- 通知生命周期回调
  ls-type:: annotation
  hl-page:: 661
  hl-color:: green
  id:: 63d33f68-3e00-469a-af14-f9a5b59ea72a
- Notifications API 提供了 4 个用于添加回调的生命周期方法
  ls-type:: annotation
  hl-page:: 661
  hl-color:: yellow
  id:: 63d33f79-f2c9-4b47-8f20-bb898ac01aaf
- onshow 在通知显示时触发
  ls-type:: annotation
  hl-page:: 661
  hl-color:: yellow
  id:: 63d340d0-c1a5-45b5-9060-f21e530f4039
- onclick 在通知被点击时触发
  ls-type:: annotation
  hl-page:: 661
  hl-color:: yellow
  id:: 63d340da-c1e8-4a52-8ead-a427b910db63
- onclose 在通知消失或通过 close()关闭时触发
  ls-type:: annotation
  hl-page:: 661
  hl-color:: yellow
  id:: 63d340e0-7377-4306-9caf-043efcbc00c5
- onerror 在发生错误阻止通知显示时触发
  ls-type:: annotation
  hl-page:: 661
  hl-color:: yellow
  id:: 63d340e7-afd3-4ee6-bbe6-3f7af46e9cb6
- Page Visibility API
  ls-type:: annotation
  hl-page:: 661
  hl-color:: green
  id:: 63d340ed-5767-46ae-bf5d-5255106c2cf3
- Page Visibility API 旨在为开发者提供页面对用户是否可见的信息。
  ls-type:: annotation
  hl-page:: 661
  hl-color:: yellow
  id:: 63d3420b-b563-4125-a6aa-927943b40265
- document.visibilityState 值，表示下面 4 种状态之一。
  ls-type:: annotation
  hl-page:: 661
  hl-color:: yellow
  id:: 63d342f1-8c97-44dd-b7b1-1fee3b984a6c
- visibilitychange 事件，该事件会在文档从隐藏变可见（或反之）时触发。
  ls-type:: annotation
  hl-page:: 661
  hl-color:: yellow
  id:: 63d342fc-4773-4bff-9528-80955dacd115
- document.hidden 布尔值，表示页面是否隐藏
  ls-type:: annotation
  hl-page:: 661
  hl-color:: yellow
  id:: 63d34305-ebd2-45dd-a69f-3712726353d9
- Streams API
  ls-type:: annotation
  hl-page:: 662
  hl-color:: green
  id:: 63d34331-ac02-4649-a54b-5d4e06524b29
- 理解流
  ls-type:: annotation
  hl-page:: 662
  hl-color:: green
  id:: 63d34373-7656-44c7-869b-58b9530ed9b3
- Web 应用如何消费有序的小信息块而不是大块信息？
  ls-type:: annotation
  hl-page:: 662
  hl-color:: yellow
  id:: 63d34379-0ef6-41e9-a49f-22e4cd36d405
- Stream API 直接解决的问题是处理网络请求和读写磁盘。
  ls-type:: annotation
  hl-page:: 662
  hl-color:: yellow
  id:: 63d343b0-175d-4c91-8136-8ca9463f7d19
- Stream API 定义了三种流。
  ls-type:: annotation
  hl-page:: 662
  hl-color:: yellow
  id:: 63d343c8-f531-4b27-8988-32fb91d42f9c
- 生产者（producer）将数据写入流，数据在内部传入底层数据槽（sink）。
  ls-type:: annotation
  hl-page:: 662
  hl-color:: yellow
  id:: 63d34408-106b-4c3c-a29f-f01b64e51dfe
- 据在内部从底层源进入流，然后由消费者（consumer）进行处理
  ls-type:: annotation
  hl-page:: 662
  hl-color:: yellow
  id:: 63d34418-90bc-4ee3-8847-3c3eb9747cae
- 这两个流之间是转换程序（transformer），可以根据需要检查和修改流内容。
  ls-type:: annotation
  hl-page:: 662
  hl-color:: yellow
  id:: 63d3442c-43d5-4198-9641-c79e8fc92bb1
- 流的基本单位是块（chunk）。块可是任意数据类型，但通常是定型数组。
  ls-type:: annotation
  hl-page:: 662
  hl-color:: yellow
  id:: 63d34435-2cee-4fc7-ac6b-9cadd9490d4e
- 有流都会为已进入流但尚未离开流的块提供一个内部队列
  ls-type:: annotation
  hl-page:: 662
  hl-color:: yellow
  id:: 63d34452-2eba-4e8e-b5f0-ec6522fc3cbc
- 如果块入列速度快于出列速度，则内部队列会不断增大。
  ls-type:: annotation
  hl-page:: 663
  hl-color:: yellow
  id:: 63d34474-77d4-4ee1-b96a-127bc0b5fa99
- 这个策略定义了内部队列可以占用的最大内存，即高水位线（high water mark）
  ls-type:: annotation
  hl-page:: 663
  hl-color:: yellow
  id:: 63d3447b-5e2e-41ac-a712-e393e92bff89
- 此它会使用反压（backpressure）通知流入口停止发送数据，直到队列大小降到某个既定的阈值之下。
  ls-type:: annotation
  hl-page:: 663
  hl-color:: yellow
  id:: 63d34484-feb8-41d2-9cdb-2d7ea5132379
- 可读流
  ls-type:: annotation
  hl-page:: 663
  hl-color:: green
  id:: 63d3448b-f9bd-482a-8525-7262cc0fe31c
- ReadableStreamDefaultController
  ls-type:: annotation
  hl-page:: 663
  hl-color:: green
  id:: 63d344b6-c97c-4977-aa67-5ef03ccfcc2c
- 调用控制器的 enqueue()方法可以把值传入控制器。所有值都传完之后，调用 close()关闭流
  ls-type:: annotation
  hl-page:: 663
  hl-color:: yellow
  id:: 63d344f9-5e97-471e-8cc8-4e9307a2a426
- 建 ReadableStream 的一个实例，并在这个构造函数的 underlyingSource 参数（第一个参数）中定义 start()方法，
  ls-type:: annotation
  hl-page:: 663
  hl-color:: yellow
  id:: 63d3451d-524d-49fc-8722-6a90ecd1d943
- 在这个方法中使用作为参数传入的 controller。
  ls-type:: annotation
  hl-page:: 663
  hl-color:: yellow
  id:: 63d34524-c3a7-430d-9671-1bc5a236ce5d
- ReadableStreamDefaultReader
  ls-type:: annotation
  hl-page:: 663
  hl-color:: green
  id:: 63d34551-d72c-4fcf-a5e5-8c940581d10a
- 需要一个 ReadableStreamDefaultReader 的实例，该实例可以通过流的 getReader()方法获取
  ls-type:: annotation
  hl-page:: 663
  hl-color:: yellow
  id:: 63d34569-4de8-4f1e-a1a6-f7eaae15455c
- 调用这个方法会获得流的锁，保证只有这个读取器可以从流中读取值：
  ls-type:: annotation
  hl-page:: 663
  hl-color:: yellow
  id:: 63d34571-0801-4e12-b24a-5836850f7d85
- 可写流
  ls-type:: annotation
  hl-page:: 665
  hl-color:: green
  id:: 63d34582-cd54-452c-916b-3d1c5a780d5a
- 创建 WritableStream
  ls-type:: annotation
  hl-page:: 665
  hl-color:: green
  id:: 63d345ab-2fe3-4b4d-8adc-94359a784214
  hl-stamp:: 1674790323612
- 在传给 WritableStream 构造函数的 underlyingSink参数中，通过实现 write()方法可以获得写入的数据：
  ls-type:: annotation
  hl-page:: 665
  hl-color:: yellow
  id:: 63d345c2-01ac-4ee7-8208-99c614451c4d
- WritableStreamDefaultWriter
  ls-type:: annotation
  hl-page:: 665
  hl-color:: green
  id:: 63d345ce-478d-43f9-b069-5ebfd74d5d3a
- 要把获得的数据写入流，可以通过流的 getWriter()方法获取 WritableStreamDefaultWriter的实例。
  ls-type:: annotation
  hl-page:: 665
  hl-color:: yellow
  id:: 63d345dd-ab7a-4117-9ace-e7afdd907dce
- 在向流中写入数据前，生产者必须确保写入器可以接收值。
  ls-type:: annotation
  hl-page:: 665
  hl-color:: yellow
  id:: 63d345fa-f8cf-4be7-bfa1-0fcb58283eea
  hl-stamp:: 1674790497113
- 此期约会在能够向流中写入数据时解决。
  ls-type:: annotation
  hl-page:: 665
  hl-color:: yellow
  id:: 63d34629-74b6-4364-ad52-a759cfbca378
- writableStreamDefaultWriter.ready返回一个期约
  ls-type:: annotation
  hl-page:: 665
  hl-color:: yellow
  id:: 63d3466b-cd63-47a1-bcda-4f7402710e5f
- 转换流
  ls-type:: annotation
  hl-page:: 666
  hl-color:: green
  id:: 63d34677-07aa-46c9-8cb3-3b9331134bff
- 通过管道连接流
  ls-type:: annotation
  hl-page:: 667
  hl-color:: green
  id:: 63d34689-8168-4294-a9aa-d449684e3fde
- 转换流用于组合可读流和可写流。数据块在两个流之间的转换是通过 transform()方法完成的。
  ls-type:: annotation
  hl-page:: 666
  hl-color:: yellow
  id:: 63d346af-3385-4606-a61e-71b7705d7a13
- 流可以通过管道连接成一串。最常见的用例是使用 pipeThrough()方法把 ReadableStream 接入 TransformStream。
  ls-type:: annotation
  hl-page:: 667
  hl-color:: yellow
  id:: 63d34755-0bd0-46d7-8594-8e62b7bf390d
- 另外，使用 pipeTo()方法也可以将 ReadableStream 连接到 WritableStream
  ls-type:: annotation
  hl-page:: 668
  hl-color:: yellow
  id:: 63d34786-1b37-4a5f-9fea-f74bbe3f36b3
- 计时 API
  ls-type:: annotation
  hl-page:: 669
  hl-color:: green
  id:: 63d34795-aa73-4f96-803a-b6efcfc39fde
- Performance 接口通过 JavaScript API 暴露了浏览器内部的度量指标
  ls-type:: annotation
  hl-page:: 669
  hl-color:: yellow
  id:: 63d36759-8119-4d22-be13-ef7cf70bacc8
- 个接口暴露在 window.performance 对象上
  ls-type:: annotation
  hl-page:: 669
  hl-color:: yellow
  id:: 63d36799-46d1-45e4-870d-92a6621d1e58
- High Resolution Time API
  ls-type:: annotation
  hl-page:: 669
  hl-color:: green
  id:: 63d3682d-5871-4d0b-a8b2-c9b8df2a69a7
  hl-stamp:: 1674799150877
- Date.now()方法只适用于日期时间相关操作，而且是不要求计时精度的操作。
  ls-type:: annotation
  hl-page:: 669
  hl-color:: yellow
  id:: 63d36841-eead-486a-b892-415822d0bebb
- High Resolution Time API 定义了 window.performance.now()，这个方法返回一个微秒精度的浮点值
  ls-type:: annotation
  hl-page:: 669
  hl-color:: yellow
  id:: 63d368ee-7c33-48ec-9d85-1a17433ceda4
- performance.now()计时器采用相对度量。这个计时器在执行上下文创建时从 0 开始计时。
  ls-type:: annotation
  hl-page:: 670
  hl-color:: yellow
  id:: 63d3690e-a082-4966-9276-338be3798200
- performance.timeOrigin 属性返回计时器初始化时全局系统时钟的值。
  ls-type:: annotation
  hl-page:: 670
  hl-color:: yellow
  id:: 63d36923-4194-4317-85a3-aebd30a0e595
- Performance Timeline API
  ls-type:: annotation
  hl-page:: 670
  hl-color:: green
  id:: 63d36932-5759-4259-a621-3a0c2188ee2c
- Performance Timeline API 使用一套用于度量客户端延迟的工具扩展了 Performance 接口
  ls-type:: annotation
  hl-page:: 670
  hl-color:: yellow
  id:: 63d36963-a3d5-4bd2-83ff-ceff10dc9cd6
- 性能度量将会采用计算结束与开始时间差的形式
  ls-type:: annotation
  hl-page:: 670
  hl-color:: yellow
  id:: 63d36976-e75d-4f17-874d-4756419274bc
- 在一个执行上下文中被记录的所有性能条目可以通过 performance. getEntries()获取
  ls-type:: annotation
  hl-page:: 670
  hl-color:: yellow
  id:: 63d36998-3822-447c-9d7b-dbcf2d54734c
- 这个返回的集合代表浏览器的性能时间线（performance timeline）。
  ls-type:: annotation
  hl-page:: 670
  hl-color:: yellow
  id:: 63d369c6-c375-43f4-a9eb-83b3cf64d904
- PerformanceEntry 实际上是一个抽象基类
  ls-type:: annotation
  hl-page:: 671
  hl-color:: yellow
  id:: 63d36a06-ecff-4f82-9602-7358342d9f81
- User Timing API 用于记录和分析自定义性能条目
  ls-type:: annotation
  hl-page:: 671
  hl-color:: yellow
  id:: 63d36a4c-a1b0-4434-80c9-a47a713662e0
- 记录自定义性能条目要使用 performance.mark()方法：
  ls-type:: annotation
  hl-page:: 671
  hl-color:: yellow
  id:: 63d36a57-3dc9-45b8-8b21-88b75ff6dccb
- 新的标记（mark）会被推到 getEntriesByType()返回数组的开始
  ls-type:: annotation
  hl-page:: 671
  hl-color:: yellow
  id:: 63d36b2d-1547-42c0-89d7-20843d4dc21f
- 还可以生成 PerformanceMeasure（性能度量）条目，
  ls-type:: annotation
  hl-page:: 671
  hl-color:: yellow
  id:: 63d36b38-3f83-4262-9a7e-593568580abb
- Navigation Timing API 提供了高精度时间戳，用于度量当前页面加载速度。
  ls-type:: annotation
  hl-page:: 671
  hl-color:: yellow
  id:: 63d36bb6-ccd6-4270-9af3-b4aeba65c22d
- 自动记录 PerformanceNavigationTiming 条目
  ls-type:: annotation
  hl-page:: 672
  hl-color:: yellow
  id:: 63d36bc9-ec3b-4e91-b6c7-376cf96d9399
- Resource Timing API 提供了高精度时间戳，用于度量当前页面加载时请求资源的速度。
  ls-type:: annotation
  hl-page:: 672
  hl-color:: yellow
  id:: 63d36bdc-e5e8-4abc-9457-063abf3e65b6
- 览器会在加载资源时自动记录 PerformanceResourceTiming。这个对象会捕获大量时间戳，用于描述资源加载的速度
  ls-type:: annotation
  hl-page:: 672
  hl-color:: yellow
  id:: 63d36beb-83fe-4a73-b145-38449b26b229
- Web 组件
  ls-type:: annotation
  hl-page:: 673
  hl-color:: green
  id:: 63d36c0b-cb19-4a50-b124-1cf17d18df31
- HTML 模板
  ls-type:: annotation
  hl-page:: 673
  hl-color:: green
  id:: 63d36c31-b463-470a-bcc6-4796f74e5dfe
- 使用 DocumentFragment
  ls-type:: annotation
  hl-page:: 674
  hl-color:: green
  id:: 63d36c50-313d-4cc9-8299-ae8341102312
- <template>的内容不属于活动文档，所以 document.querySelector()等 DOM 查询方法不会发现其中的<p>标签
  ls-type:: annotation
  hl-page:: 674
  hl-color:: yellow
  id:: 63d36c8b-c5e7-418f-b6c7-43d3c5bc7ffc
- 通过<template>元素的 content 属性可以取得这个 DocumentFragment 的引用
  ls-type:: annotation
  hl-page:: 674
  hl-color:: yellow
  id:: 63d36c9f-0eef-4e9e-982d-0ee122fb1aff
- 使用<template>标签
  ls-type:: annotation
  hl-page:: 675
  hl-color:: green
  id:: 63d36ce7-c2ed-4e41-9473-a21d5db4ab6d
- 使用 DocumentFragment 可以一次性添加所有子节点，最多只会有一次布局重排：
  ls-type:: annotation
  hl-page:: 674
  hl-color:: yellow
  id:: 63d36cee-ea2b-4c4f-b94a-17371687aba9
- 如果想要复制模板，可以使用 importNode()方法克隆 DocumentFragment：
  ls-type:: annotation
  hl-page:: 675
  hl-color:: yellow
  id:: 63d36d38-2b9c-4063-827f-c47eb8946dd8
- 模板脚本
  ls-type:: annotation
  hl-page:: 676
  hl-color:: green
  id:: 63d36d51-174a-4b2a-b579-1a2de79a599d
- 脚本执行可以推迟到将 DocumentFragment 的内容实际添加到 DOM 树
  ls-type:: annotation
  hl-page:: 676
  hl-color:: yellow
  id:: 63d36d71-31b2-47a5-8a2e-17b561c7f078
- 影子 DOM
  ls-type:: annotation
  hl-page:: 676
  hl-color:: green
  id:: 63d36df2-25ef-47a2-ae64-880a5a2894e8
- 通过它可以将一个完整的 DOM 树作为节点添加到父 DOM 树
  ls-type:: annotation
  hl-page:: 676
  hl-color:: yellow
  id:: 63d36dfb-46dd-4497-89da-096f87308911
- 影子 DOM 的内容会实际渲染到页面上，而 HTML 模板的内容不会
  ls-type:: annotation
  hl-page:: 676
  hl-color:: yellow
  id:: 63d36e09-de13-4063-8364-69152adbf0cf
- 创建影子 DOM
  ls-type:: annotation
  hl-page:: 677
  hl-color:: green
  id:: 63d36e47-a7b5-4b1a-b998-85c0c3ab971f
- 考虑到安全及避免影子 DOM 冲突，并非所有元素都可以包含影子 DOM。
  ls-type:: annotation
  hl-page:: 677
  hl-color:: yellow
  id:: 63d36e53-6aba-46eb-a623-c427ba821952
- 影子 DOM 是通过 attachShadow()方法创建并添加给有效 HTML 元素的
  ls-type:: annotation
  hl-page:: 678
  hl-color:: yellow
  id:: 63d36e62-b70b-444f-b263-3cabce4e9704
- 容纳影子 DOM 的元素被称为影子宿主（shadow host）
  ls-type:: annotation
  hl-page:: 678
  hl-color:: yellow
  id:: 63d36e6a-6f49-495b-8910-e1c2a2417dd3
- 影子 DOM 的根节点被称为影子根（shadow root）
  ls-type:: annotation
  hl-page:: 678
  hl-color:: yellow
  id:: 63d36e71-899d-4ab8-a6a6-ab1aad642cdb
- 需要一个 shadowRootInit 对象，返回影子 DOM 的实例
  ls-type:: annotation
  hl-page:: 678
  hl-color:: yellow
  id:: 63d36e9b-2956-4e7f-8b18-e4f152a8ec36
- shadowRootInit对象必须包含一个 mode 属性，值为"open"或"closed"。
  ls-type:: annotation
  hl-page:: 678
  hl-color:: yellow
  id:: 63d36eb0-2f7b-40a8-9795-defc81d47942
- 使用影子 DOM
  ls-type:: annotation
  hl-page:: 678
  hl-color:: green
  id:: 63d36ecc-5fa3-4278-ba56-a3a19d3bf7a1
- 但每个选择符只会把样式应用到它们所在的影子 DOM 上
  ls-type:: annotation
  hl-page:: 679
  hl-color:: yellow
  id:: 63d36f20-33b8-4211-834e-2d47ae134545
- 影子 DOM 并非铁板一块。HTML 元素可以在 DOM 树间无限制移动：
  ls-type:: annotation
  hl-page:: 680
  hl-color:: yellow
  id:: 63d36fb5-72e2-49c5-8d74-d384ce921a99
- 合成与影子 DOM 槽位
  ls-type:: annotation
  hl-page:: 680
  hl-color:: green
  id:: 63d36fe1-89f1-4d80-a48a-8dc2cc053592
- 位于影子宿主中的 HTML 需要一种机制以渲染到影子 DOM 中去，但这些 HTML 又不必属于影子 DOM 树
  ls-type:: annotation
  hl-page:: 680
  hl-color:: yellow
  id:: 63d3702a-4647-4aa2-8ed7-9d0766f2060d
- 影子 DOM 一添加到元素中，浏览器就会赋予它最高优先级，优先渲染它的内容而不是原来的文本。
  ls-type:: annotation
  hl-page:: 680
  hl-color:: yellow
  id:: 63d37057-aa6c-404a-958a-fa8d9ecf9204
- 虽然在页面检查窗口中看到内容在影子 DOM 中，但这实际上只是 DOM 内容的投射（projection
  ls-type:: annotation
  hl-page:: 681
  hl-color:: yellow
  id:: 63d370e1-66fd-4f82-8f83-e8f4b7dba040
- 还可以使用命名槽位（named slot）实现多个投射
  ls-type:: annotation
  hl-page:: 681
  hl-color:: yellow
  id:: 63d370f8-5dc7-40b5-a68c-be0c510fcb1d
- 带有 slot="foo"属性的元素会被投射到带有 name="foo"的<slot>上
  ls-type:: annotation
  hl-page:: 682
  hl-color:: yellow
  id:: 63d37167-e1c3-498a-aa93-8f6e6a762572
- 事件重定向
  ls-type:: annotation
  hl-page:: 682
  hl-color:: green
  id:: 63d37177-aeda-4d5a-b22b-2158ab5d43ab
- 为此，事件会逃出影子 DOM 并经过事件重定向（event retarget）在外部被处理。
  ls-type:: annotation
  hl-page:: 682
  hl-color:: yellow
  id:: 63d371a2-e28e-4d14-b279-ac45a557894a
- 事件重定向只会发生在影子 DOM 中实际存在的元素上。使用<slot>标签从外部投射进来的元素不会发生事件重定向，
  ls-type:: annotation
  hl-page:: 682
  hl-color:: yellow
  id:: 63d371bc-1348-4c6f-9169-5aef7306d944
- 自定义元素
  ls-type:: annotation
  hl-page:: 682
  hl-color:: green
  id:: 63d37229-a9d7-4fb2-83e1-82f44f514c5d
- 创建自定义元素
  ls-type:: annotation
  hl-page:: 682
  hl-color:: green
  id:: 63d3723a-abff-4d15-b36b-366d9ad1a536
- 浏览器会尝试将无法识别的元素作为通用元素整合进 DOM。
  ls-type:: annotation
  hl-page:: 682
  hl-color:: yellow
  id:: 63d3724d-03ed-490b-a496-ab6636f164aa
- 来看下面的例子，其中胡乱编的 HTML 标签会变成一个 HTMLElement 实例：
  ls-type:: annotation
  hl-page:: 683
  hl-color:: yellow
  id:: 63d37262-b5ca-4537-88a7-74dc80c8e92d
- 定义元素要使用全局属性 customElements，这个属性会返回 CustomElementRegistry 对象
  ls-type:: annotation
  hl-page:: 683
  hl-color:: yellow
  id:: 63d37279-a6e4-442f-b56a-af465b9de62f
- 调用 customElements.define()方法可以创建自定义元素。
  ls-type:: annotation
  hl-page:: 683
  hl-color:: yellow
  id:: 63d37287-f28e-4310-9084-dba123221444
- 以通过调用自定义元素的构造函数来控制这个类在 DOM中每个实例的行为：
  ls-type:: annotation
  hl-page:: 683
  hl-color:: yellow
  id:: 63d372c2-0a12-4a5b-b43e-59df5540e451
- 在自定义元素的构造函数中必须始终先调用 super()。
  ls-type:: annotation
  hl-page:: 683
  hl-color:: yellow
  id:: 63d372f9-510b-433c-827a-5e8a07749faa
- 如果自定义元素继承了一个元素类，那么可以使用 is 属性和 extends 选项将标签指定为该自定义元素的实例
  ls-type:: annotation
  hl-page:: 684
  hl-color:: yellow
  id:: 63d37312-91a1-4e6a-af3c-08b2405e6dd3
- 添加 Web 组件内容
  ls-type:: annotation
  hl-page:: 684
  hl-color:: green
  id:: 63d3731d-ae27-43f4-8404-e2cc6ff374e0
- 虽然不能在构造函数中添加子 DOM（会抛出 DOMException），但可以为自定义元素添加影子 DOM 并将内容添加到这个影子 DOM 中
  ls-type:: annotation
  hl-page:: 684
  hl-color:: yellow
  id:: 63d3734c-35e2-45c0-84fd-628b2ebe8a1d
- 这样可以在自定义元素中实现高度的 HTML 和代码重用，以及 DOM 封装。使用这种模式能够自由创建可重用的组件而不必担心外部 CSS 污染组件的样式。
  ls-type:: annotation
  hl-page:: 685
  hl-color:: yellow
  id:: 63d37390-a667-4ee8-bd15-9c7e7d7be557
- 使用自定义元素生命周期方法
  ls-type:: annotation
  hl-page:: 685
  hl-color:: green
  id:: 63d37394-9c38-42f4-bd9d-b7bf8675bb47
- 有相应名称的自定义元素类的实例方法会在不同生命周期阶段被调用
  ls-type:: annotation
  hl-page:: 685
  hl-color:: yellow
  id:: 63d373ae-a5bc-4e6c-a442-48c614fe4321
- connectedCallback()：在每次将这个自定义元素实例添加到 DOM 中时调用
  ls-type:: annotation
  hl-page:: 685
  hl-color:: yellow
  id:: 63d374bf-9412-4814-937f-a170b5579465
- adoptedCallback()：在通过 document.adoptNode()将这个自定义元素实例移动到新文档对象时调用
  ls-type:: annotation
  hl-page:: 685
  hl-color:: yellow
  id:: 63d374d5-b598-403f-b20a-8d12cc4172ae
- 反射自定义元素属性
  ls-type:: annotation
  hl-page:: 686
  hl-color:: green
  id:: 63d374e2-690f-460c-9919-7c40ac7be80b
- 自定义元素既是 DOM 实体又是 JavaScript 对象，因此两者之间应该同步变化。
  ls-type:: annotation
  hl-page:: 686
  hl-color:: yellow
  id:: 63d3750a-c8af-4ea8-a248-3231d95aff98
- 从 DOM 到 JavaScript 对象）需要给相应的属性添加监听器
  ls-type:: annotation
  hl-page:: 686
  hl-color:: yellow
  id:: 63d37529-edd4-489d-8624-3007ce99aae8
- 升级自定义元素
  ls-type:: annotation
  hl-page:: 687
  hl-color:: green
  id:: 63d3754d-b097-4f34-8e81-592605c5bdbd
- Web 组件在 CustomElementRegistry 上额外暴露了一些方法。这些方法可以用来检测自定义元素是否定义完成，然后可以用它来升级已有元素。
  ls-type:: annotation
  hl-page:: 687
  hl-color:: yellow
  id:: 63d37573-5010-48f4-9799-5ee79238e67c
- CustomElementRegistry.get()方法会返回相应自定义元素的类
  ls-type:: annotation
  hl-page:: 687
  hl-color:: yellow
  id:: 63d3758f-d753-4d48-8c53-6b29609011ac
- CustomElementRegistry.whenDefined()方法会返回一个期约，当相应自定义元素有定义之后解决
  ls-type:: annotation
  hl-page:: 687
  hl-color:: yellow
  id:: 63d375af-7602-458f-986a-c078a9c123ea
- 可以使用 CustomElementRegistry.upgrade()方法
  ls-type:: annotation
  hl-page:: 687
  hl-color:: yellow
  id:: 63d375c8-1eba-414c-b544-5d76ccdcfc5b
- Web Cryptography API
  ls-type:: annotation
  hl-page:: 688
  hl-color:: green
  id:: 63d375db-4ba6-4e8a-a4d1-4b47ee799633
- 生成随机数
  ls-type:: annotation
  hl-page:: 688
  hl-color:: green
  id:: 63d375f9-70d2-42e0-a6de-2d6bfde8a8ef
- 每次调用 Math.random()，这个内部状态都会被一个算法修改，而结果会被转换为一个新的随机值
  ls-type:: annotation
  hl-page:: 688
  hl-color:: yellow
  id:: 63d376b2-3844-4665-8bfb-b24e4f12024f
- 密码学安全伪随机数生成器（CSPRNG，Cryptographically Secure PseudoRandom Number Generator）额外增加了一个熵作为输入，
  ls-type:: annotation
  hl-page:: 688
  hl-color:: yellow
  id:: 63d376cb-bc78-49a7-bbce-f4b42376e1ab
- 这种循环被称为置换循环（permutation cycle），而这个循环的长度被称为一个周期（period）。
  ls-type:: annotation
  hl-page:: 688
  hl-color:: yellow
  id:: 63d376d4-c86b-46d2-9c3e-28895e7f98af
- 个 CSPRNG 可以通过 crypto.getRandomValues()在全局 Crypto 对象上访问
  ls-type:: annotation
  hl-page:: 688
  hl-color:: yellow
  id:: 63d376e9-a20d-4f71-81fb-3acc9231e2b4
- getRandomValues()会把随机值写入作为参数传给它的定型数组。
  ls-type:: annotation
  hl-page:: 688
  hl-color:: yellow
  id:: 63d376f8-566c-4f49-a759-fdcae5834ac7
- getRandomValues()最多可以生成 2 16（65 536）字节
  ls-type:: annotation
  hl-page:: 688
  hl-color:: yellow
  id:: 63d3770e-766f-4961-921e-08c08a6655c1
- 要使用 CSPRNG 重新实现 Math.random()，可以通过生成一个随机的 32 位数值，然后用它去除最大的可能值 0xFFFFFFFF。这样就会得到一个介于 0 和 1 之间的值
  ls-type:: annotation
  hl-page:: 689
  hl-color:: yellow
  id:: 63d3772c-1821-4e47-8f63-18b58190f0bb
- 使用 SubtleCrypto 对象
  ls-type:: annotation
  hl-page:: 689
  hl-color:: green
  id:: 63d37738-c6df-4164-be3c-7f8f8af40388
- Web Cryptography API 重头特性都暴露在了 SubtleCrypto 对象上，可以通过 window.crypto. subtle 访问
  ls-type:: annotation
  hl-page:: 689
  hl-color:: yellow
  id:: 63d37745-f4cb-42a5-8000-4cd9da20c76d
- 为所有密码学操作都在原始二进制数据上执行，所以 SubtleCrypto 的每个方法都要用到 ArrayBuffer 和 ArrayBufferView 类 型 。
  ls-type:: annotation
  hl-page:: 689
  hl-color:: yellow
  id:: 63d3777d-ff66-4026-b4b3-619a4e02f27c
- 生成密码学摘要
  ls-type:: annotation
  hl-page:: 689
  hl-color:: green
  id:: 63d3779b-388b-400a-901a-d7cb9688f857
- 计算数据的密码学摘要是非常常用的密码学操作。这个规范支持 4 种摘要算法：SHA-1 和 3 种 SHA-2。
  ls-type:: annotation
  hl-page:: 689
  hl-color:: yellow
  id:: 63d377a3-af19-40d3-b073-bf4b1471dfa5
- 规范支持其中 3 种：SHA-256、SHA-384 和 SHA-512
  ls-type:: annotation
  hl-page:: 689
  hl-color:: yellow
  id:: 63d377da-fc9c-40dd-bcff-a64dc3072bcf
- SubtleCrypto.digest()方法用于生成消息摘要。
  ls-type:: annotation
  hl-page:: 689
  hl-color:: yellow
  id:: 63d377e1-7075-4f51-8739-1f4894a8dc08
- 过将二进制数据按 8 位进行分割，然后再调用 toString(16)就可以把任何数组缓冲区转换为十六进制字符串
  ls-type:: annotation
  hl-page:: 690
  hl-color:: yellow
  id:: 63d37819-5c9c-409a-9c42-755f888dff62
- CryptoKey 与算法
  ls-type:: annotation
  hl-page:: 691
  hl-color:: green
  id:: 63d37898-0dd9-45e1-a7a0-69cdb47587c3
- SubtleCrypto 对象使用 CryptoKey 类的实例来生成密钥。
  ls-type:: annotation
  hl-page:: 691
  hl-color:: yellow
  id:: 63d378a4-46a3-4399-b882-dded13f7114f
- CryptoKey 类支持多种加密算法，允许控制密钥抽取和使用。
  ls-type:: annotation
  hl-page:: 691
  hl-color:: yellow
  id:: 63d378bc-8927-4955-b516-4e43a7d9276e
- 生成 CryptoKey
  ls-type:: annotation
  hl-page:: 692
  hl-color:: green
  id:: 63d37db2-d407-4e75-9e13-13b98dcc32dd
- 使用 SubtleCrypto.generateKey()方法可以生成随机 CryptoKey，这个方法返回一个期约，解决为一个或多个 CryptoKey 实例
  ls-type:: annotation
  hl-page:: 692
  hl-color:: yellow
  id:: 63d37dba-8f07-4f62-9fee-4ef2e84f5707
- 法传入一个指定目标算法的参数对象、一个表示密钥是否可以从 CryptoKey 对象中提取出来的布尔值，以及一个表示这个密钥可以与哪个 SubtleCrypto 方法一起使用的字符串数组（keyUsages）。
  ls-type:: annotation
  hl-page:: 692
  hl-color:: yellow
  id:: 63d37dc6-3d91-493b-a9cf-b8f184785ea1
- 导出和导入密钥
  ls-type:: annotation
  hl-page:: 694
  hl-color:: green
  id:: 63d37df5-088c-48e1-9976-6781083cf77c
- 使用 exportKey()方法并指定目标格式（"raw"、"pkcs8"、"spki"或"jwk"）就可以取得密钥
  ls-type:: annotation
  hl-page:: 694
  hl-color:: yellow
  id:: 63d37e43-e174-43be-8f2c-72a6d8014d8c
- importKey()方法的签名实际上是 generateKey()和 exportKey()的组合。
  ls-type:: annotation
  hl-page:: 694
  hl-color:: yellow
  id:: 63d37e5a-9e9d-4ade-b2e7-c0fd17f0f81c
- 从主密钥派生密钥
  ls-type:: annotation
  hl-page:: 694
  hl-color:: green
  id:: 63d37e71-f891-4cc4-a263-3ee0ba13ba4d
- SubtleCrypto 支持一个 deriveKey()方法和一个 deriveBits()方法，
  ls-type:: annotation
  hl-page:: 694
  hl-color:: yellow
  id:: 63d37e87-635a-48c6-8180-56a6ecc0610a
- deriveBits()方法接收一个算法参数对象、主密钥和输出的位长作为参数。
  ls-type:: annotation
  hl-page:: 695
  hl-color:: yellow
  id:: 63d37e96-5dfb-4000-9209-eedd59c29fde
- deriveKey()方法是类似的，只不过返回的是 CryptoKey 的实例而不是 ArrayBuffer
  ls-type:: annotation
  hl-page:: 695
  hl-color:: yellow
  id:: 63d37ea2-3bf7-434f-afda-6ffe6b70c842
- 使用非对称密钥签名和验证消息
  ls-type:: annotation
  hl-page:: 696
  hl-color:: green
  id:: 63d37ebb-d884-43a5-808d-1c7d56274248
- 可以使用公钥算法用私钥生成签名，或者用公钥验证签名
  ls-type:: annotation
  hl-page:: 696
  hl-color:: yellow
  id:: 63d37ec4-f2e5-403a-9e8e-f1e5f9da7fc1
- 签名消息需要传入参数对象以指定算法和必要的值、CryptoKey 和要签名的 ArrayBuffer 或 ArrayBufferView。
  ls-type:: annotation
  hl-page:: 696
  hl-color:: yellow
  id:: 63d37f0d-c403-4350-a299-3ed6a09208da
- 希望通过这个签名验证消息的人可以使用公钥和 SubtleCrypto.verify()方法
  ls-type:: annotation
  hl-page:: 697
  hl-color:: yellow
  id:: 63d37f16-a13b-41aa-adf4-2bb090b83059
- 是必须提供公钥以及签名
  ls-type:: annotation
  hl-page:: 697
  hl-color:: yellow
  id:: 63d37f1b-a2d7-409c-b6f6-103f8742c15d
- 使用对称密钥加密和解密
  ls-type:: annotation
  hl-page:: 697
  hl-color:: green
  id:: 63d37f1f-3ae0-446f-8bf9-e5716b07ce48
- 加密消息需要传入参数对象以指定算法和必要的值、加密密钥和要加密的数据
  ls-type:: annotation
  hl-page:: 697
  hl-color:: yellow
  id:: 63d37f29-d02b-4624-beab-8c43caf93085
- 包装和解包密钥
  ls-type:: annotation
  hl-page:: 698
  hl-color:: green
  id:: 63d37f6c-03ef-4d6c-a427-caf192ad99e0
- 这两种操作分别通过 SubtleCrypto.wrapKey()和 SubtleCrypto.unwrapKey()方法完成
  ls-type:: annotation
  hl-page:: 698
  hl-color:: yellow
  id:: 63d384a9-f883-45c7-8389-2dc3baa31ee6
- 浏览器错误报告
  ls-type:: annotation
  hl-page:: 700
  hl-color:: green
  id:: 63d384c0-8510-4a39-bf91-a3e20ea490ce
- 桌面控制台
  ls-type:: annotation
  hl-page:: 700
  hl-color:: green
  id:: 63d3854d-66d7-4484-985e-5e44c4e97140
- 移动控制台
  ls-type:: annotation
  hl-page:: 701
  hl-color:: green
  id:: 63d38584-29bb-4f4f-8d9a-07837438aaa4
- 此外也可以使用第三方工具直接在移动设备上调试。Firefox 常用的调试工具是 Firebug Lite
  ls-type:: annotation
  hl-page:: 701
  hl-color:: yellow
  id:: 63d386e7-bc1b-4017-9e9a-c1258db4812b
- 错误处理
  ls-type:: annotation
  hl-page:: 701
  hl-color:: green
  id:: 63d386e9-281d-4429-bd95-12c16d21760f
- try/catch 语句
  ls-type:: annotation
  hl-page:: 701
  hl-color:: green
  id:: 63d3871c-fe93-489a-a054-beafbb7c33e3
- 任何可能出错的代码都应该放到 try 块中，而处理错误的代码则放在 catch 块中
  ls-type:: annotation
  hl-page:: 701
  hl-color:: yellow
  id:: 63d3872c-144e-4fb5-95d7-9bdd002d96a0
- 。message 属性是唯一一个在 IE、Firefox、Safari、 Chrome 和 Opera 中都有的属性，尽管每个浏览器添加了其他属性
  ls-type:: annotation
  hl-page:: 702
  hl-color:: yellow
  id:: 63d38742-57b9-45cf-84bc-ac6c985a9665
- finally 子句
  ls-type:: annotation
  hl-page:: 702
  hl-color:: green
  id:: 63d387a5-c2a7-4c78-854c-1f4b04da4cf0
- try 或 catch 块无法阻止 finally 块执行，包括 return 语句
  ls-type:: annotation
  hl-page:: 702
  hl-color:: yellow
  id:: 63d387bf-c4d2-4f80-8de6-dc3aabbffd29
- 错误类型
  ls-type:: annotation
  hl-page:: 702
  hl-color:: green
  id:: 63d387f2-a6e9-4ee1-8595-6e7c25ab8624
- InternalError 类型的错误会在底层 JavaScript 引擎抛出异常时由浏览器抛出
  ls-type:: annotation
  hl-page:: 703
  hl-color:: yellow
  id:: 63d3880e-b15d-48be-821b-fce42d2161be
- EvalError 类型的错误会在使用 eval()函数发生异常时抛出
  ls-type:: annotation
  hl-page:: 703
  hl-color:: yellow
  id:: 63d38814-eb6f-4d41-9fc9-8b001732170f
- RangeError 错误会在数值越界时抛出。
  ls-type:: annotation
  hl-page:: 703
  hl-color:: yellow
  id:: 63d3882d-0274-4dde-829b-7cae1b7e33af
- eferenceError 会在找不到对象时发生。
  ls-type:: annotation
  hl-page:: 703
  hl-color:: yellow
  id:: 63d38834-9e93-4c05-a643-e7377db7392f
- SyntaxError 经常在给 eval()传入的字符串包含 JavaScript 语法错误时发生
  ls-type:: annotation
  hl-page:: 703
  hl-color:: yellow
  id:: 63d38846-fc80-4aa7-b81a-a59410194943
- TypeError 在 JavaScript 中很常见，主要发生在变量不是预期类型，或者访问不存在的方法时
  ls-type:: annotation
  hl-page:: 703
  hl-color:: yellow
  id:: 63d38850-7c4d-4ce1-baa0-d1caf8bb3c95
- 是 URIError，只会在使用 encodeURI()或 decodeURI()但传入了格式错误的 URI 时发生。
  ls-type:: annotation
  hl-page:: 703
  hl-color:: yellow
  id:: 63d3885b-b426-485a-ba2d-0d6aeb974be7
- try/catch 的用法
  ls-type:: annotation
  hl-page:: 704
  hl-color:: green
  id:: 63d38899-f691-44da-b535-9bb60a420646
- 抛出错误
  ls-type:: annotation
  hl-page:: 704
  hl-color:: green
  id:: 63d388b6-cf7c-4c25-b320-c0589e83d6f5
- 与 try/catch 语句对应的一个机制是 throw 操作符，用于在任何时候抛出自定义错误
  ls-type:: annotation
  hl-page:: 704
  hl-color:: yellow
  id:: 63d388d7-c424-40c7-9824-40ba90315f34
- 使用 throw 操作符时，代码立即停止执行，除非 try/catch 语句捕获了抛出的值
  ls-type:: annotation
  hl-page:: 704
  hl-color:: yellow
  id:: 63d38904-b969-4a2a-a41b-9c57d6035a12
- 自定义错误常用的错误类型是 Error、RangeError、ReferenceError 和 TypeError。
  ls-type:: annotation
  hl-page:: 704
  hl-color:: yellow
  id:: 63d38910-5cc7-45db-ab3e-3c51a21165f3
- 创建自定义错误类型时，需要提供 name 属性和 message 属性，比如
  ls-type:: annotation
  hl-page:: 705
  hl-color:: yellow
  id:: 63d38995-c8f1-4401-ac90-f218b1575eae
- 何时抛出错误
  ls-type:: annotation
  hl-page:: 705
  hl-color:: green
  id:: 63d389c8-7222-4d6e-a01d-425637b001e5
- 抛出错误与 try/catch
  ls-type:: annotation
  hl-page:: 706
  hl-color:: green
  id:: 63d389e4-4ba2-4417-a5a2-2ab38fb7367e
  hl-stamp:: 1674807781461
- error 事件
  ls-type:: annotation
  hl-page:: 706
  hl-color:: green
  id:: 63d38a67-7af0-47b0-a9de-2dd10d95e9f7
- 在 onerror 事件处理程序中，任何浏览器都不会传入 event 对象。相反，会传入 3 个参数：错误消息、发生错误的 URL 和行号。
  ls-type:: annotation
  hl-page:: 706
  hl-color:: yellow
  id:: 63d38a7b-9d2d-4b6f-aabd-83b73f0a26f9
- onerror 事件处理程序需要使用 DOM Level 0 技术来指定
  ls-type:: annotation
  hl-page:: 706
  hl-color:: yellow
  id:: 63d38a8e-432a-4d1f-b993-c4639f657292
- 在任何错误发生时，无论是否是浏览器生成的，都会触发 error 事件并执行这个事件处理程序
  ls-type:: annotation
  hl-page:: 706
  hl-color:: yellow
  id:: 63d38ac1-a896-4a70-8d55-c92a6dcaf2ec
- 可以返回 false 来阻止浏览器默认报告错误的行为，
  ls-type:: annotation
  hl-page:: 706
  hl-color:: yellow
  id:: 63d38acc-192f-4a48-b50d-37500a2d22c1
- 图片也支持 error 事件。
  ls-type:: annotation
  hl-page:: 707
  hl-color:: yellow
  id:: 63d38ae8-3943-47c3-b848-3e0c229a102e
- 错误处理策略
  ls-type:: annotation
  hl-page:: 707
  hl-color:: green
  id:: 63d38aee-fce2-4570-98f4-24358d657a0b
- 识别错误
  ls-type:: annotation
  hl-page:: 707
  hl-color:: green
  id:: 63d38cbe-b9cf-437e-84f6-74c60984e2c0
- 错误处理非常重要的部分是首先识别错误可能会在代码中的什么地方发生
  ls-type:: annotation
  hl-page:: 707
  hl-color:: yellow
  id:: 63d38cca-ec11-4c74-b7a9-362be5e6e8ed
- 静态代码分析器
  ls-type:: annotation
  hl-page:: 707
  hl-color:: green
  id:: 63d38ced-fcf8-43d7-8bec-b5b98de3e0c8
- 类型转换错误
  ls-type:: annotation
  hl-page:: 708
  hl-color:: green
  id:: 63d38d05-c004-47a0-b4c0-d285ab18b93f
- 使用了会自动改变某个值的数据类型的操作符或语言构造
  ls-type:: annotation
  hl-page:: 708
  hl-color:: yellow
  id:: 63d38d1e-7a1d-49f8-b5a4-e5b24301ae70
- ，相等和不相等操作符会自动把执行比较的两个不同类型的值转换为相同类
  ls-type:: annotation
  hl-page:: 708
  hl-color:: yellow
  id:: 63d38d52-cfd4-42fd-8813-7efe880edb28
- 使用严格相等和严格不相等操作符可以避免比较过程的类型转换错误，强烈推荐用它们代替相等和不相等操作符。
  ls-type:: annotation
  hl-page:: 708
  hl-color:: yellow
  id:: 63d38d7e-17ae-425f-9589-fc83fc0fbe64
- 类型转换错误也会发生在流控制语句中。比如，if 语句会自动把条件表达式转换为布尔值
  ls-type:: annotation
  hl-page:: 708
  hl-color:: yellow
  id:: 63d38dbd-234b-45fe-ad42-51e995d4cd65
- 在流控制语句中使用非布尔值作为条件是很常见的错误来源
  ls-type:: annotation
  hl-page:: 709
  hl-color:: yellow
  id:: 63d38e58-868b-410f-adc2-beb5d25b09d0
- 数据类型错误
  ls-type:: annotation
  hl-page:: 709
  hl-color:: green
  id:: 63d38e63-4608-4f58-bdf2-6054d8992ffd
- 这个函数的用途是返回给定 URL 的查询字符串
  ls-type:: annotation
  hl-page:: 709
  hl-color:: yellow
  id:: 63d38ee8-7697-4ec1-b03d-c1f93a9bb874
- reverseSort()函数可以使用数组的 sort()和 reverse()方法，将数组反向排序
  ls-type:: annotation
  hl-page:: 710
  hl-color:: yellow
  id:: 63d38f02-7881-4610-9256-3336f5a9ede2
- 那么最好使用 instanceof 来确定值的正确类型
  ls-type:: annotation
  hl-page:: 710
  hl-color:: yellow
  id:: 63d38f74-ee9c-4531-b260-7b980b7fdead
- 通信错误
  ls-type:: annotation
  hl-page:: 710
  hl-color:: green
  id:: 63d38f83-1d95-4958-be9a-c372935982a7
- 原始类型的值应该使用 typeof 检测，而对象值应该使用 instanceof 检测
  ls-type:: annotation
  hl-page:: 710
  hl-color:: yellow
  id:: 63d38f92-cde7-4b4d-8783-3f33aa91c727
- 对于查询字符串，应该都要通过 encodeURIComponent()编码
  ls-type:: annotation
  hl-page:: 711
  hl-color:: yellow
  id:: 63d38fc5-8393-4a8c-adaa-2fea21718a9b
- 区分重大与非重大错误
  ls-type:: annotation
  hl-page:: 711
  hl-color:: green
  id:: 63d38fd6-e189-4464-b7a6-a17aef84ae58
- 代码中则不要区分什么是或什么不是重大错误
  ls-type:: annotation
  hl-page:: 712
  hl-color:: yellow
  id:: 63d39005-e6ad-439f-9791-d2491399c9b1
- 好在可以简单地重写以上代码，让每个模块的错误变成非重大错误：
  ls-type:: annotation
  hl-page:: 712
  hl-color:: yellow
  id:: 63d39015-0e3d-420a-b9e9-dce579eca6cf
- 通过在 for 循环中加入 try/catch 语句，模块初始化过程中的任何错误都不会影响其他模块初始化。如果代码中有错误发生，则可以单独处理，并不会影响用户体验
  ls-type:: annotation
  hl-page:: 712
  hl-color:: yellow
  id:: 63d3901c-951c-4854-aaad-760c06c6726f
- 把错误记录到服务器中
  ls-type:: annotation
  hl-page:: 712
  hl-color:: green
  id:: 63d39023-cb98-4338-bf42-37c0888642f1
- 要建立 JavaScript 错误日志系统，首先需要在服务器上有页面或入口可以处理错误数据
  ls-type:: annotation
  hl-page:: 712
  hl-color:: yellow
  id:: 63d3905b-ede1-430a-a03a-0be4e1b2fa42
- 该页面只要从查询字符串中取得错误数据，然后把它们保存到错误日志中即可
  ls-type:: annotation
  hl-page:: 712
  hl-color:: yellow
  id:: 63d39065-492d-4c47-814b-468dc3be2c7e
- 记录错误的过程很少出错。大多数 Ajax 通信借助 JavaScript 库的包装来处理。如果这个库本身出错，而你又要利用它记录错误，那么显然错误消息永远不会发给服务器
  ls-type:: annotation
  hl-page:: 713
  hl-color:: yellow
  id:: 63d3907d-25c2-46cf-987c-3b6a1cf8053b
- 调试技术
  ls-type:: annotation
  hl-page:: 713
  hl-color:: green
  id:: 63d390a6-961b-4ab5-9143-332578b600f7
- 其中最为常用的调试技术是在相关代码中插入 alert()
  ls-type:: annotation
  hl-page:: 713
  hl-color:: yellow
  id:: 63d390b5-77c0-46a9-946b-3c540537ff52
- 把消息记录到控制台
  ls-type:: annotation
  hl-page:: 713
  hl-color:: green
  id:: 63d390b9-d11f-4791-b476-b0a979516aba
- 支持通过 console 对象直接把 JavaScript 消息写入控制台
  ls-type:: annotation
  hl-page:: 713
  hl-color:: yellow
  id:: 63d39124-e4f6-4d51-9a47-edd707ab9d75
- 理解控制台运行时
  ls-type:: annotation
  hl-page:: 714
  hl-color:: green
  id:: 63d3912c-5a6d-4e6a-8f7f-02c6c0c00554
- 浏览器控制台是个读取求值打印循环（REPL，read-eval-print-loop），与页面的 JavaScript 运行时并发。这个运行时就像浏览器对新出现在 DOM 中的<script>标签求值一样。
  ls-type:: annotation
  hl-page:: 714
  hl-color:: yellow
  id:: 63d39139-7e43-44f9-8c35-875f1ff62cfb
- 使用$0 引用该节点的 JavaScript实例。它就跟普通的 JavaScript 实例一样，因此可以读取属性（如$0.scrollWidth），或者调用成员方法（如$0.remove()）。
  ls-type:: annotation
  hl-page:: 714
  hl-color:: yellow
  id:: 63d3915a-4ed5-415f-80d9-fa1573903387
- 使用 JavaScript 调试器
  ls-type:: annotation
  hl-page:: 714
  hl-color:: green
  id:: 63d3915c-810a-4c29-8247-ff8d47479431
- 在运行时碰到这个关键字时，所有主流浏览器都会打开开发者工具面板，并在指定位置显示断点。然后，可以通过单独的浏览器控制台在断点所在的特定词法作用域中执行代码
  ls-type:: annotation
  hl-page:: 714
  hl-color:: yellow
  id:: 63d39179-5899-48c9-8bbf-23e44538d64b
- 在页面中打印消息
  ls-type:: annotation
  hl-page:: 715
  hl-color:: green
  id:: 63d39182-9eb1-4120-a88e-171aa244950c
- 是把消息写到页面中指定的区域
  ls-type:: annotation
  hl-page:: 715
  hl-color:: yellow
  id:: 63d391d7-d8dd-4f55-ae59-174e59ff4402
- 补充控制台方法
  ls-type:: annotation
  hl-page:: 715
  hl-color:: green
  id:: 63d391eb-479c-4fb1-b3d5-a8c9caa1355b
- 抛出错误
  ls-type:: annotation
  hl-page:: 715
  hl-color:: green
  id:: 63d39202-7fdd-4db2-8c9a-a4fbe875b9a3
- 这里，任何一个参数不是数值都会抛出错误。错误消息中包含函数名和错误的具体原因
  ls-type:: annotation
  hl-page:: 716
  hl-color:: yellow
  id:: 63d39272-65a4-40ca-9284-8becefa9cba5
- 在大型应用程序中，自定义错误通常使用 assert()函数抛出错误
  ls-type:: annotation
  hl-page:: 716
  hl-color:: yellow
  id:: 63d39278-bc9c-4e6e-a176-394cfe023058
- 这个 assert()函数可用于代替多个 if 语句，同时也是记录错误的好地方
  ls-type:: annotation
  hl-page:: 716
  hl-color:: yellow
  id:: 63d39318-e6c8-4007-90d7-743ac6140b2d
- 旧版 IE 的常见错误
  ls-type:: annotation
  hl-page:: 716
  hl-color:: green
  id:: 63d3933a-1de5-413b-97bd-1f9626566224
- 无效字符
  ls-type:: annotation
  hl-page:: 716
  hl-color:: green
  id:: 63d3937b-15a2-444f-931e-f83ca6b6b60f
- 未找到成员
  ls-type:: annotation
  hl-page:: 717
  hl-color:: green
  id:: 63d3938e-ac51-4002-be5a-6668d6df0fe5
- 这个错误通常会在给一个已被销毁的对象赋值时发生。这个对象必须是 COM 对象才会出现这个消息。
  ls-type:: annotation
  hl-page:: 717
  hl-color:: yellow
  id:: 63d393cd-c745-4ae3-b54d-8ea5074ea751
- 未知运行时错误
  ls-type:: annotation
  hl-page:: 717
  hl-color:: green
  id:: 63d3943f-0d0e-4307-a8c3-86d60a0135ae
- 语法错误
  ls-type:: annotation
  hl-page:: 717
  hl-color:: green
  id:: 63d39470-825d-4214-8b39-3eab0bde4daa
- 系统找不到指定资源
  ls-type:: annotation
  hl-page:: 718
  hl-color:: green
  id:: 63d39479-e533-4796-9886-629bb921e34c
- 浏览器对 XML DOM 的支持
  ls-type:: annotation
  hl-page:: 719
  hl-color:: green
  id:: 63d3948a-600e-487b-b8cd-e4cee0dd6233
- DOM Level 2 Core
  ls-type:: annotation
  hl-page:: 719
  hl-color:: green
  id:: 63d3989d-3a12-453b-8f8d-2a1dc3addf06
- let xmldom = document.implementation.createDocument(namespaceUri, root, doctype);
  ls-type:: annotation
  hl-page:: 719
  hl-color:: yellow
  id:: 63d398be-48da-40ec-b5e7-50867bea3ed7
- 这个例子创建了一个 XML DOM 文档，该文档没有默认的命名空间和文档类型。
  ls-type:: annotation
  hl-page:: 719
  hl-color:: yellow
  id:: 63d3990c-9b92-4261-91ea-4fea9fc97d4c
- 要检查浏览器是否支持 DOM Level 2 XML，可以使用如下代码
  ls-type:: annotation
  hl-page:: 720
  hl-color:: yellow
  id:: 63d3994e-434f-428c-b191-b35f753787ae
- DOMParser 类型
  ls-type:: annotation
  hl-page:: 720
  hl-color:: green
  id:: 63d3995c-8a1d-4855-baae-aa67589fdb3e
- 两个参数：要解析的 XML 字符串和内容类型（始终应该是"text/html"）
  ls-type:: annotation
  hl-page:: 720
  hl-color:: yellow
  id:: 63d39973-def0-4045-897b-11a3e2e31f16
- 返回值是 Document的实例
  ls-type:: annotation
  hl-page:: 720
  hl-color:: yellow
  id:: 63d3997b-d921-4c87-a688-5ca37cb30657
- DOMParser 只能解析格式良好的 XML，因此不能把 HTML 解析为 HTML 文档
  ls-type:: annotation
  hl-page:: 720
  hl-color:: yellow
  id:: 63d399c9-c2e5-4d9b-b333-7079c20013ed
- 发生解析错误时，parseFromString()方法仍会返回一个 Document 对象，只不过其 document 元素是<parsererror>，该元素的内容为解析错误的描述。
  ls-type:: annotation
  hl-page:: 720
  hl-color:: yellow
  id:: 63d399d3-d8f0-4898-bad4-9396161776b4
- 最好使用 try/catch 来判断是否发生了解析错误，如果没有错误
  ls-type:: annotation
  hl-page:: 720
  hl-color:: yellow
  id:: 63d399fc-fcbd-4899-86e1-1cab1d6e02dc
- XMLSerializer 类型
  ls-type:: annotation
  hl-page:: 721
  hl-color:: green
  id:: 63d39a0c-747a-4dad-8fea-82585dcd88d0
- 把 DOM 文档序列化为 XML 字符串
  ls-type:: annotation
  hl-page:: 721
  hl-color:: yellow
  id:: 63d39a84-81be-4f50-99da-cae9e53ed815
- 浏览器对 XPath 的支持
  ls-type:: annotation
  hl-page:: 721
  hl-color:: green
  id:: 63d39a9c-cf61-46bb-b855-a6c3864e796c
- DOM Level 3 XPath 规范定义了接口，用于在 DOM 中求值 XPath 表达式。
  ls-type:: annotation
  hl-page:: 721
  hl-color:: yellow
  id:: 63d39b0a-4576-4ac2-a1fd-29ffe0dc159c
- XPathEvaluator 用于在特定上下文中求值 XPath 表达式，包含三个方法
  ls-type:: annotation
  hl-page:: 721
  hl-color:: yellow
  id:: 63d39b78-7a10-43ed-a363-bf670a1450d1
- evaluate()。这个方法接收五个参数：XPath 表达式、上下文节点、命名空间解析器、返回的结果类型和 XPathResult 对象（用于填充结果，通常是 null，因为结果也可能是函数值）
  ls-type:: annotation
  hl-page:: 722
  hl-color:: yellow
  id:: 63d39bda-73f1-47cb-9d25-24e9632cdf2e
- 这个例子使用了 XPathResult.ORDERED_NODE_ITERATOR_TYPE 结果类型，也是最常用的类型。
  ls-type:: annotation
  hl-page:: 722
  hl-color:: yellow
  id:: 63d39c2b-7f53-465e-b046-7c7bc8f3e766
- 有序还是无序，都必须使用 iterateNext()方法获取结果中每个匹配的节点
  ls-type:: annotation
  hl-page:: 723
  hl-color:: yellow
  id:: 63d39c6d-002e-4356-b783-5b4f9f12f2b5
- 单个节点结果
  ls-type:: annotation
  hl-page:: 723
  hl-color:: green
  id:: 63d39c94-3b30-4e1f-8caa-cbc20980f046
- 简单类型结果
  ls-type:: annotation
  hl-page:: 723
  hl-color:: green
  id:: 63d39cac-306f-49f4-8629-a034ab6fff34
- 使用布尔值、数值和字符串 XPathResult 类型，可以根据 XPath 获取简单、非节点数据类型
  ls-type:: annotation
  hl-page:: 723
  hl-color:: yellow
  id:: 63d39ce0-9af5-4996-b0a3-f12e97ae403a
- 这个例子输出了与"employee/name"匹配的第一个元素中第一个文本节点包含的文本字符串
  ls-type:: annotation
  hl-page:: 724
  hl-color:: yellow
  id:: 63d39d51-81b0-477f-94a5-92c40693f8d6
- 默认类型结果
  ls-type:: annotation
  hl-page:: 724
  hl-color:: green
  id:: 63d39d8c-17af-42a4-92f6-7c42898ed242
- 可以使用 XPathResult.ANY_TYPE 类型让求值自动返回默认类型结果
  ls-type:: annotation
  hl-page:: 724
  hl-color:: yellow
  id:: 63d39dae-f8d2-4257-b57f-b8ef4eded59a
- 使用 XPathResult.ANY_TYPE 可以让使用 XPath 变得更自然，但在返回结果后则需要增加额外的判断和处理
  ls-type:: annotation
  hl-page:: 724
  hl-color:: yellow
  id:: 63d39df4-7382-491a-b016-b9edf68e5d82
- 命名空间支持
  ls-type:: annotation
  hl-page:: 724
  hl-color:: green
  id:: 63d39dfe-cb8d-4fc9-a474-58395da04a58
- 对于使用命名空间的 XML 文档，必须告诉 XPathEvaluator 命名空间信息，才能进行正确求值
  ls-type:: annotation
  hl-page:: 724
  hl-color:: yellow
  id:: 63d39e2d-c6bb-4017-9c36-fe0c490e4484
- 如果想使用 XPath 查询该文档，就需要指定使用的命名空间，否则求值会失
  ls-type:: annotation
  hl-page:: 725
  hl-color:: yellow
  id:: 63d3ab46-0eb0-4591-ba05-ca75119f80c9
- 第一种处理命名空间的方式是通过 createNSResolver()方法创建 XPathNSResolver 对象
  ls-type:: annotation
  hl-page:: 725
  hl-color:: yellow
  id:: 63d3ab73-467d-45af-9e5c-6311b0a246e3
- 第二种处理命名空间的方式是定义一个接收命名空间前缀并返回相应 URI 的函数
  ls-type:: annotation
  hl-page:: 725
  hl-color:: yellow
  id:: 63d3abf3-352e-47d2-9bbb-cbc19efded91
- 浏览器对 XSLT 的支持
  ls-type:: annotation
  hl-page:: 725
  hl-color:: green
  id:: 63d3abff-ad06-4942-800c-0cdf6f33cbbb
- 可以利用 XPath 将一种文档表示转换为另一种文档表示
  ls-type:: annotation
  hl-page:: 725
  hl-color:: yellow
  id:: 63d3ac12-8254-4550-b9ca-d033b3a3ed49
- 可扩展样式表语言转换（XSLT，Extensible Stylesheet Language Transformations）
  ls-type:: annotation
  hl-page:: 725
  hl-color:: yellow
  id:: 63d3ac63-b19c-400d-ba8a-a18c1e934223
- XSLTProcessor 类型
  ls-type:: annotation
  hl-page:: 725
  hl-color:: green
  id:: 63d3ac6f-7034-474d-9347-33df8664063f
- 开发者可以使用 XSLT 转换 XML 文档，其方式类似于在 IE 中使用 XSL 处理器
  ls-type:: annotation
  hl-page:: 726
  hl-color:: yellow
  id:: 63d3aca4-f0c0-428a-a682-e86b99db8a71
- ，第一步是加载两个 DOM 文档：XML 文档和 XSLT 文档
  ls-type:: annotation
  hl-page:: 726
  hl-color:: yellow
  id:: 63d3acb1-610e-4410-9fc2-c99774ddb5db
- 使用 importStyleSheet()方法创建一个新的 XSLTProcessor，将 XSLT 指定给它
  ls-type:: annotation
  hl-page:: 726
  hl-color:: yellow
  id:: 63d3acbb-d84b-4074-9e83-7da19dd39f58
- 最后一步是执行转换
  ls-type:: annotation
  hl-page:: 726
  hl-color:: yellow
  id:: 63d3acdd-d7ce-4a51-9cc8-a7e0198197c2
- 返回完整的 DOM 文档，就调用 transformToDocument()
  ls-type:: annotation
  hl-page:: 726
  hl-color:: yellow
  id:: 63d3ace5-94af-456a-9e24-6eabde6d8304
- 想得到文档片段，则可以调用 transformToFragment()
  ls-type:: annotation
  hl-page:: 726
  hl-color:: yellow
  id:: 63d3ad61-ca93-4e7a-936b-776ca4bc8e26
- 使用参数
  ls-type:: annotation
  hl-page:: 726
  hl-color:: green
  id:: 63d3add4-55de-4ae9-89fe-024cdcd72681
- XSLTProcessor 还允许使用 setParameter()方法设置 XSLT 参数。该方法接收三个参数：命名空间 URI、参数本地名称和要设置的值。
  ls-type:: annotation
  hl-page:: 726
  hl-color:: yellow
  id:: 63d3ade4-e8d1-441c-a1f5-05fe53d9f9c1
- setParameter()方法必须在调用 transformToDocument()或 transformToFragment()之前调用
  ls-type:: annotation
  hl-page:: 726
  hl-color:: yellow
  id:: 63d3ae4c-ef0c-45b8-b178-77d92f763932
- getParameter()和 removeParameter()。它们分别用于取得参数的当前值和移除参数的值
  ls-type:: annotation
  hl-page:: 727
  hl-color:: yellow
  id:: 63d3ae5e-f391-4d37-9616-5038bbe6ac7d
- 重置处理器
  ls-type:: annotation
  hl-page:: 727
  hl-color:: green
  id:: 63d3ae75-256b-4b4a-9761-8388e52c5391
- 处理器的 reset()方法可以删除所有参数和样式表
  ls-type:: annotation
  hl-page:: 727
  hl-color:: yellow
  id:: 63d3ae7e-74a6-44c9-b906-5e356cabcf30
- 以使用 importStylesheet()方法加载不同的 XSLT 样表
  ls-type:: annotation
  hl-page:: 727
  hl-color:: yellow
  id:: 63d3ae89-2553-4a9c-bea3-2489aa7517af
- 语法
  ls-type:: annotation
  hl-page:: 728
  hl-color:: green
  id:: 63d3ae9c-55ce-4ad2-a7f7-bb14cab99c1f
- JSON 语法支持表示 3 种类型的值。
  ls-type:: annotation
  hl-page:: 728
  hl-color:: yellow
  id:: 63d3c27a-e3c4-4ce3-87dd-1a6bb4f17789
- 简单值
  ls-type:: annotation
  hl-page:: 728
  hl-color:: green
  id:: 63d3c353-68fd-43f9-bee7-3f9117ee02aa
- 布尔值和 null 本身也是有效的 JSON 值
  ls-type:: annotation
  hl-page:: 729
  hl-color:: yellow
  id:: 63d3c3af-4b14-449d-b6f6-dfa6b02cae1e
- 对象
  ls-type:: annotation
  hl-page:: 729
  hl-color:: green
  id:: 63d3c3b9-c3b3-439c-935e-bb196a47be82
- SON 中的对象必须使用双引号把属性名包围起来
  ls-type:: annotation
  hl-page:: 729
  hl-color:: yellow
  id:: 63d3c40c-1e0f-4a84-9147-df9eabb824ad
- 同一个对象中不允许出现两个相同的属
  ls-type:: annotation
  hl-page:: 729
  hl-color:: yellow
  id:: 63d3c486-22f6-4670-a9e7-b3dcfc77bc0e
- 数组
  ls-type:: annotation
  hl-page:: 729
  hl-color:: green
  id:: 63d3c49e-0f24-486c-9859-cbd0d4a949e5
- 解析与序列化
  ls-type:: annotation
  hl-page:: 731
  hl-color:: green
  id:: 63d3c4eb-4911-42b7-a5dd-b46b28faaa92
- JSON 对象
  ls-type:: annotation
  hl-page:: 731
  hl-color:: green
  id:: 63d3c595-9910-4e9d-a604-a363f35cdb15
- JSON.stringify()把一个 JavaScript 对象序列化为一个 JSON 字符串，保存在变量 jsonText 中
  ls-type:: annotation
  hl-page:: 731
  hl-color:: yellow
  id:: 63d3c5c9-d13e-4443-acdb-de61c9fad916
- JSON.stringify()会输出不包含空格或缩进的 JSON 字符串
  ls-type:: annotation
  hl-page:: 731
  hl-color:: yellow
  id:: 63d3c63a-9512-4106-8062-37844177a76c
- JSON 字符串可以直接传给 JSON.parse()，然后得到相应的 JavaScript 值
  ls-type:: annotation
  hl-page:: 732
  hl-color:: yellow
  id:: 63d3c662-f98f-496b-a254-f8211d55e558
- 序列化选项
  ls-type:: annotation
  hl-page:: 732
  hl-color:: green
  id:: 63d3c6c5-ba3a-4446-b753-702136698d29
- 第一个参数是过滤器，可以是数组或函数
  ls-type:: annotation
  hl-page:: 732
  hl-color:: yellow
  id:: 63d3c6e0-a8c4-4f8e-b77a-10a6baaa27b7
- 第二个参数是用于缩进结果 JSON 字符串的选项
  ls-type:: annotation
  hl-page:: 732
  hl-color:: yellow
  id:: 63d3c704-e125-4ffa-bbe5-7cc598248af4
- 过滤结果
  ls-type:: annotation
  hl-page:: 732
  hl-color:: green
  id:: 63d3c72f-c99c-4202-a271-136870762c18
- 第二个参数是一个数组，那么 JSON.stringify()返回的结果只会包含该数组中列出的对象属性
  ls-type:: annotation
  hl-page:: 732
  hl-color:: yellow
  id:: 63d3c784-43a4-446e-8d26-a52c32437e0c
- 提供的函数接收两个参数：属性名（key）和属性值（value）。可以根据这个 key 决定要对相应属性执行什么操作
  ls-type:: annotation
  hl-page:: 732
  hl-color:: yellow
  id:: 63d3c7ef-2bce-4be9-a8d2-da22030052fd
- 基于键进行了过滤
  ls-type:: annotation
  hl-page:: 733
  hl-color:: yellow
  id:: 63d3c806-21c0-4bbd-8001-2411bd95882f
- 字符串缩进
  ls-type:: annotation
  hl-page:: 733
  hl-color:: green
  id:: 63d3c812-cb92-4be2-9e9f-b9edb9837168
- 在这个参数是数值时，表示每一级缩进的空格数
  ls-type:: annotation
  hl-page:: 733
  hl-color:: yellow
  id:: 63d3c821-5e58-485e-8cbe-20f4551ebbb0
- 除了缩进，JSON.stringify()方法还为方便阅读插入了换行符。
  ls-type:: annotation
  hl-page:: 733
  hl-color:: yellow
  id:: 63d3c8b3-616d-4392-a5a6-68f69ae01bc7
- 如果缩进参数是一个字符串而非数值，那么 JSON 字符串中就会使用这个字符串而不是空格来缩进
  ls-type:: annotation
  hl-page:: 734
  hl-color:: yellow
  id:: 63d3c8c0-bfd6-46df-8fab-507257d3a2ff
- toJSON()方法
  ls-type:: annotation
  hl-page:: 734
  hl-color:: green
  id:: 63d3c8ca-92a7-46e9-9122-56bb970c552a
- 能够自动将 JavaScript 的 Date 对象转换为 ISO 8601 日期字符串
  ls-type:: annotation
  hl-page:: 734
  hl-color:: yellow
  id:: 63d3c967-713e-4081-affb-230ba04efa85
- 自定义 JSON 序列化
  ls-type:: annotation
  hl-page:: 734
  hl-color:: yellow
  id:: 63d3c976-122f-4a7b-9495-887c0df71396
- 箭头函数不能用来定义 toJSON()方法。主要原因是箭头函数的词法作用域是全局作用域，在这种情况下不合适
  ls-type:: annotation
  hl-page:: 734
  hl-color:: yellow
  id:: 63d3c9e2-3429-4b3e-8e63-4cd3cf9a7622
- 解析选项
  ls-type:: annotation
  hl-page:: 735
  hl-color:: green
  id:: 63d3c9f5-2095-4dff-b83c-2c3802b08fac
- JSON.parse()方法也可以接收一个额外的参数，这个函数会针对每个键/值对都调用一次
  ls-type:: annotation
  hl-page:: 735
  hl-color:: yellow
  id:: 63d3ca63-5ec4-441e-962c-ddc2c86fafac
- 还原函数也接收两个参数，属性名（key）和属性值（value），
  ls-type:: annotation
  hl-page:: 735
  hl-color:: yellow
  id:: 63d3ca9b-db14-4d3c-b8bf-be7f5c7df106
- 需要返回值
  ls-type:: annotation
  hl-page:: 735
  hl-color:: yellow
  id:: 63d3caa1-32a6-4cb2-92d3-893be780f5c9
- 如果还原函数返回 undefined，则结果中就会删除相应的键
  ls-type:: annotation
  hl-page:: 735
  hl-color:: yellow
  id:: 63d3caab-5bb0-46c9-ab46-160932c77fe3
- 以上代码在 book 对象中增加了 releaseDate 属性，是一个 Date 对象。
  ls-type:: annotation
  hl-page:: 735
  hl-color:: yellow
  id:: 63d3caf5-0a1a-4500-abf7-422009b74d5c
- XMLHttpRequest 对象
  ls-type:: annotation
  hl-page:: 736
  hl-color:: green
  id:: 63d3cb84-cfde-43ca-852b-de50e1097fe7
- Ajax（Asynchronous JavaScript+XML，即异步 JavaScript 加 XML）的技术
  ls-type:: annotation
  hl-page:: 736
  hl-color:: yellow
  id:: 63d3cc10-895d-4ed3-b8bd-8fbff697fabe
- XHR 为发送服务器请求和获取响应提供了合理的接口
  ls-type:: annotation
  hl-page:: 736
  hl-color:: yellow
  id:: 63d3cc92-2cf5-4045-bfff-07251b548375
- 这个技术主要是可以实现在不刷新页面的情况下从服务器获取数据，格式并不一定是 XM
  ls-type:: annotation
  hl-page:: 736
  hl-color:: yellow
  id:: 63d3cd8a-7316-424e-a26a-2a97fc7bfdc2
- 这个对象是通过 ActiveX 对象实现并包含在 MSXML 库中的
  ls-type:: annotation
  hl-page:: 736
  hl-color:: yellow
  id:: 63d3ce10-1714-4ca4-a49e-f075c240c05e
- 所有现代浏览器都通过 XMLHttpRequest 构造函数原生支持 XHR 对象
  ls-type:: annotation
  hl-page:: 737
  hl-color:: yellow
  id:: 63d3ce23-3357-4045-b994-0a04606c0cb8
- 使用 XHR
  ls-type:: annotation
  hl-page:: 737
  hl-color:: green
  id:: 63d3ce2b-0a12-48bd-b466-f2aeacc2f35d
- 使用 XHR 对象首先要调用 open()方法，这个方法接收 3 个参数：请求类型（"get"、"post"等）、请求 URL，以及表示请求是否异步的布尔值。
  ls-type:: annotation
  hl-page:: 737
  hl-color:: yellow
  id:: 63d3ce66-1e86-491d-a597-bcaf4a8df7c3
- 调用 open()不会实际发送请求，只是为发送请求做好准备
  ls-type:: annotation
  hl-page:: 737
  hl-color:: yellow
  id:: 63d3cede-2995-40ed-8e18-49bd7ddd7a71
- 发送定义好的请求，必须像下面这样调用 send()方法
  ls-type:: annotation
  hl-page:: 737
  hl-color:: yellow
  id:: 63d3cef3-5dbe-4d6e-9317-fba1283d540a
- send()方法接收一个参数，是作为请求体发送的数据。如果不需要发送请求体，则必须传 null，
  ls-type:: annotation
  hl-page:: 737
  hl-color:: yellow
  id:: 63d3cf75-d857-4b96-8c4c-ee5f5221c595
- 如果 HTTP状态码是 304，则表示资源未修改过，是从浏览器缓存中直接拿取的。
  ls-type:: annotation
  hl-page:: 737
  hl-color:: yellow
  id:: 63d3cfc1-9333-445c-a576-ba0778ae8d49
- 一般来说，HTTP 状态码为 2xx 表示成功
  ls-type:: annotation
  hl-page:: 737
  hl-color:: yellow
  id:: 63d3cfc9-27e9-438f-b54b-416527dc97e8
- 。XHR 对象有一个 readyState 属性，表示当前处在请求/响应过程的哪个阶段。
  ls-type:: annotation
  hl-page:: 738
  hl-color:: yellow
  id:: 63d3d042-9ee4-4587-b4c5-31bf38529202
- 每次 readyState 从一个值变成另一个值，都会触发 readystatechange 事件。
  ls-type:: annotation
  hl-page:: 738
  hl-color:: yellow
  id:: 63d3d059-4ef8-4a1f-b36f-56a96fc5f42e
- 保证跨浏览器兼容，onreadystatechange 事件处理程序应该在调用 open()之前赋值
  ls-type:: annotation
  hl-page:: 738
  hl-color:: yellow
  id:: 63d3d068-c7d9-4e24-99fe-39cfe5effb9e
- 在收到响应之前如果想取消异步请求，可以调用 abort()方法：
  ls-type:: annotation
  hl-page:: 738
  hl-color:: yellow
  id:: 63d3d0d9-7053-4124-9126-28fad9d54fbd
- HTTP 头部
  ls-type:: annotation
  hl-page:: 738
  hl-color:: green
  id:: 63d3d113-a251-46b2-aa7a-6c91df380fd9
- 默认情况下，XHR 请求会发送以下头部字段。
  ls-type:: annotation
  hl-page:: 738
  hl-color:: yellow
  id:: 63d3d179-7745-4e44-8e55-3973cd34d4f5
- 如果需要发送额外的请求头部，可以使用 setRequestHeader()方法。
  ls-type:: annotation
  hl-page:: 739
  hl-color:: yellow
  id:: 63d3d1c0-75f4-41b0-b3b2-a2be52f68cc7
- 两个参数：头部字段的名称和值
  ls-type:: annotation
  hl-page:: 739
  hl-color:: yellow
  id:: 63d3d1c9-a84a-41c6-8672-067fa247e0c0
- 必须在 open()之后、send()之前调用 setRequestHeader()
  ls-type:: annotation
  hl-page:: 739
  hl-color:: yellow
  id:: 63d3d1d3-617e-448f-b345-3332cbed63fb
- 可以使用 getResponseHeader()方法从 XHR 对象获取响应头部，只要传入要获取头部的名称即可
  ls-type:: annotation
  hl-page:: 739
  hl-color:: yellow
  id:: 63d3d239-7c0a-40f8-aa92-332850d638f9
- 取得所有响应头部，可以使用 getAllResponseHeaders()方法
  ls-type:: annotation
  hl-page:: 739
  hl-color:: yellow
  id:: 63d3d24b-e355-43a6-9251-14d0f521ef6c
- GET 请求
  ls-type:: annotation
  hl-page:: 740
  hl-color:: green
  id:: 63d3d2d1-4646-4165-9f89-686a4f2e0c14
- 要在 GET 请求的 URL后面添加查询字符串参数。
  ls-type:: annotation
  hl-page:: 740
  hl-color:: yellow
  id:: 63d3d2de-9f41-4674-8d47-e6ff6b6782d7
- 询字符串中的每个名和值都必须使用 encodeURIComponent()编码，所有名/值对必须以和号（&）分隔
  ls-type:: annotation
  hl-page:: 740
  hl-color:: yellow
  id:: 63d3d2ed-2f91-4a19-aa35-aed21b380160
- POST 请求
  ls-type:: annotation
  hl-page:: 740
  hl-color:: green
  id:: 63d3d398-2c43-4c1e-b758-04a650ae1865
- 每个 POST 请求都应该在请求体中携带提交的数据，
  ls-type:: annotation
  hl-page:: 740
  hl-color:: yellow
  id:: 63d3d3a4-f643-4ce1-bba7-30e2d97b73a6
- 可以使用 XHR 模拟表单提交。为此，第一步需要把 ContentType 头部设置为"application/x-www-formurlencoded"，这是提交表单时使用的内容类
  ls-type:: annotation
  hl-page:: 740
  hl-color:: yellow
  id:: 63d3d3b4-facc-4310-acf4-8475a284bddb
- 假如没有发送 Content-Type 头部，PHP 的全局$_POST 变量中就不会包含数据，而需要通过$HTTP_RAW_POST_DATA 来获取。
  ls-type:: annotation
  hl-page:: 741
  hl-color:: yellow
  id:: 63d3d448-72d0-43fc-b0f1-1639b4db49bf
- XMLHttpRequest Level 2
  ls-type:: annotation
  hl-page:: 741
  hl-color:: green
  id:: 63d3d44f-09f7-42a0-ad08-9d68ffefbf8f
- FormData 类型
  ls-type:: annotation
  hl-page:: 741
  hl-color:: green
  id:: 63d3d8f1-fffc-4ab6-a840-9d6b72baebe8
- append()方法接收两个参数：键和值，
  ls-type:: annotation
  hl-page:: 741
  hl-color:: yellow
  id:: 63d3d906-de9c-4f0d-b373-9ade2a11699f
- XHR 对象能够识别作为 FormData 实例传入的数据类型并自动配置相应的头部。
  ls-type:: annotation
  hl-page:: 742
  hl-color:: yellow
  id:: 63d3d96b-01d6-4d9b-83ac-63591b91eaf2
- 超时
  ls-type:: annotation
  hl-page:: 742
  hl-color:: green
  id:: 63d3dbc2-889c-4383-b5b6-94de27435d9d
- 在给 timeout 属性设置了一个时间且在该时间过后没有收到响应时，XHR 对象就会触发 timeout 事件，调用 ontimeout 事件处理程序。
  ls-type:: annotation
  hl-page:: 742
  hl-color:: yellow
  id:: 63d475d1-0cb9-4339-9363-d0f48bd17859
- 在给 timeout 属性设置了一个时间且在该时间过后没有收到响应时，XHR 对象就会触发 timeout 事件，调用 ontimeout 事件处理程序。
  ls-type:: annotation
  hl-page:: 742
  hl-color:: yellow
  id:: 63d475db-9220-4321-a6a5-78098d0dbe7b
- 不过，如果在超时之后访问 status 属性则会发生错误。为做好防护，可以把检查 status 属性的代码封装在 try/catch 语句中
  ls-type:: annotation
  hl-page:: 742
  hl-color:: yellow
  id:: 63d47617-76b6-4482-ace5-30aee6cd7609
- overrideMimeType()方法
  ls-type:: annotation
  hl-page:: 743
  hl-color:: green
  id:: 63d4761e-c598-4ec7-b67f-fcd1acf8643a
- overrideMimeType()方法用于重写 XHR 响应的 MIME 类型
  ls-type:: annotation
  hl-page:: 743
  hl-color:: yellow
  id:: 63d4765e-b210-4ef2-aeb1-58304b9877df
- XHR 把响应当成 XML 而不是纯文本来处理
  ls-type:: annotation
  hl-page:: 743
  hl-color:: yellow
  id:: 63d4767d-0658-4f59-9de7-f0004ce88982
- 进度事件
  ls-type:: annotation
  hl-page:: 743
  hl-color:: green
  id:: 63d4767f-65dc-4ac2-bcc9-8ec270c77933
- 个进度相关的事件
  ls-type:: annotation
  hl-page:: 743
  hl-color:: yellow
  id:: 63d476a1-9f63-483a-a2a2-5db4a288c7ca
- load 事件
  ls-type:: annotation
  hl-page:: 743
  hl-color:: green
  id:: 63d476a8-b534-4cd0-b3ec-1a46910a09e7
- load 事件在响应接收完成后立即触发
  ls-type:: annotation
  hl-page:: 743
  hl-color:: yellow
  id:: 63d476c2-9dec-4dcc-8a70-39c154f9d908
- onload 事件处理程序会收到一个 event 对象，其 target 属性设置为 XHR 实例，在这个实例上可以访问所有 XHR 对象属性和方法
  ls-type:: annotation
  hl-page:: 743
  hl-color:: yellow
  id:: 63d476e0-a7f6-4b1f-8886-e92cb3b1910d
- 只要是从服务器收到响应，无论状态码是什么，都会触发 load 事件
  ls-type:: annotation
  hl-page:: 744
  hl-color:: yellow
  id:: 63d47728-d8db-4606-8a73-c60496506ee5
- progress 事件
  ls-type:: annotation
  hl-page:: 744
  hl-color:: green
  id:: 63d4772d-9242-41d3-93a8-9c94c85e76e0
- 在浏览器接收数据期间，这个事件会反复触发
  ls-type:: annotation
  hl-page:: 744
  hl-color:: yellow
  id:: 63d4775e-2a8f-4ee7-86ad-eda69a24a8af
- 每次触发时，onprogress 事件处理程序都会收到 event 对象，其 target 属性是 XHR 对象，且包含 3 个额外属性：lengthComputable、position 和 totalSize。
  ls-type:: annotation
  hl-page:: 744
  hl-color:: yellow
  id:: 63d47770-3a7e-4c58-9085-d5a0f1462c85
- 跨源资源共享
  ls-type:: annotation
  hl-page:: 744
  hl-color:: green
  id:: 63d4783c-3973-4634-b138-a51d331b3959
- CORS 背后的基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。
  ls-type:: annotation
  hl-page:: 744
  hl-color:: yellow
  id:: 63d47862-1e4d-48b7-8a34-762c5f02026d
- Origin 头部包含发送请求的页面的源（协议、域名和端口），以便服务器确定是否为其提供响应。
  ls-type:: annotation
  hl-page:: 744
  hl-color:: yellow
  id:: 63d47870-af72-4c95-b6ba-1b11c3bf2a25
- 注意，无论请求还是响应都不会包含 cookie 信息。
  ls-type:: annotation
  hl-page:: 745
  hl-color:: yellow
  id:: 63d478c2-c5fd-45d8-a725-016db0fba58f
  hl-stamp:: 1674868932528
- 。要向不同域的源发送请求，可以使用标准 XHR 对象并给 open()方法传入一个绝对 URL，
  ls-type:: annotation
  hl-page:: 745
  hl-color:: yellow
  id:: 63d478de-42d0-40a2-9912-5e77d56bed8b
- 预检请求
  ls-type:: annotation
  hl-page:: 745
  hl-color:: green
  id:: 63d478f5-4d43-4830-9fe7-4e4eac1468e4
- 预检请求（preflighted request）的服务器验证机制，允许使用自定义头部、除 GET和 POST 之外的方法，以及不同请求体内容类型。
  ls-type:: annotation
  hl-page:: 745
  hl-color:: yellow
  id:: 63d47913-dc6e-40e1-b484-8eb0a9d88af8
- 只有第一次发送这种类型的请求时才会多发送一次额外的 HTTP 请求
  ls-type:: annotation
  hl-page:: 746
  hl-color:: yellow
  id:: 63d4792f-984e-49b1-99ef-9d2e2b952603
- 凭据请求
  ls-type:: annotation
  hl-page:: 746
  hl-color:: green
  id:: 63d479a1-6182-4531-976a-a81d0140687d
- 可以通过将 withCredentials 属性设置为 true 来表明请求会发送凭据
  ls-type:: annotation
  hl-page:: 746
  hl-color:: yellow
  id:: 63d47aa8-9699-4ab9-9c12-8282da6c0cc8
- 替代性跨源技术
  ls-type:: annotation
  hl-page:: 746
  hl-color:: green
  id:: 63d47c43-0940-40f5-be91-8092253b9734
- 图片探测
  ls-type:: annotation
  hl-page:: 746
  hl-color:: green
  id:: 63d47c99-185f-41b1-9d5c-7d7f180c96f9
- 这种动态创建图片的技术经常用于图片探测（image pings）。
  ls-type:: annotation
  hl-page:: 746
  hl-color:: yellow
  id:: 63d47cb4-e285-4db1-92f0-52f6fe63d01c
- 可以通过监听 onload 和 onerror 事件知道什么时候能接收到响应
  ls-type:: annotation
  hl-page:: 746
  hl-color:: yellow
  id:: 63d47cbf-fae8-40e0-b850-acbc202c537c
- 图片探测频繁用于跟踪用户在页面上的点击操作或动态显示广告。
  ls-type:: annotation
  hl-page:: 747
  hl-color:: yellow
  id:: 63d47ceb-e0c2-4217-816e-6b573b09f0cd
- JSONP
  ls-type:: annotation
  hl-page:: 747
  hl-color:: green
  id:: 63d47cf3-4352-4e4c-9e4c-92d3e4e27a17
- JSONP 看起来跟 JSON 一样，只是会被包在一个函数调用里
  ls-type:: annotation
  hl-page:: 747
  hl-color:: yellow
  id:: 63d47d26-0a8b-4ef4-a4d6-acdc20843923
- 回调是在页面接收到响应之后应该调用的函数，通常回调函数的名称是通过请求来动态指定的。
  ls-type:: annotation
  hl-page:: 747
  hl-color:: yellow
  id:: 63d47d4b-3fcb-45f1-b101-41fb43e50797
- 数据就是作为参数传给回调函数的 JSON 数据
  ls-type:: annotation
  hl-page:: 747
  hl-color:: yellow
  id:: 63d47d55-d295-4ba2-8b36-d454cc14f98f
- JSONP 调用是通过动态创建<script>元素并为 src 属性指定跨域 URL 实现的
  ls-type:: annotation
  hl-page:: 747
  hl-color:: yellow
  id:: 63d47d80-8919-40c8-894e-438c45bbedbb
- Fetch API
  ls-type:: annotation
  hl-page:: 747
  hl-color:: green
  id:: 63d47d9e-9472-4cf7-ad06-2e58fd716a08
- Fetch 标准定义请求、响应，以及绑定二者的流程：获取（fetch）
  ls-type:: annotation
  hl-page:: 748
  hl-color:: yellow
  id:: 63d47ddb-8364-4a79-93e7-306c8d5ee73e
- 基本用法
  ls-type:: annotation
  hl-page:: 748
  hl-color:: green
  id:: 63d47dec-d6f0-4cbc-9768-45ca7b572b98
- etch()方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。
  ls-type:: annotation
  hl-page:: 748
  hl-color:: yellow
  id:: 63d47f1d-5370-4177-99dc-556167fedf46
- 请求完成、资源可用时，期约会解决为一个 Response 对象。
  ls-type:: annotation
  hl-page:: 748
  hl-color:: yellow
  id:: 63d47f2c-93ce-4b93-9fa7-06afa3dd289c
- 分派请求
  ls-type:: annotation
  hl-page:: 748
  hl-color:: green
  id:: 63d47f3f-419e-4773-98cf-c7fb9b073191
- 读取响应内容的最简单方式是取得纯文本格式的内容，这要用到 text()方法
  ls-type:: annotation
  hl-page:: 748
  hl-color:: yellow
  id:: 63d47f6f-cf46-4cfa-a23d-f69611640482
- 处理状态码和请求失败
  ls-type:: annotation
  hl-page:: 748
  hl-color:: green
  id:: 63d47f81-b35d-4a3b-84f4-98584e5a460d
- 个行为是合理的：系统级网络协议已经成功完成消息的一次往返传输。至于真正的“成功”请求，则需要在处理响应时再定义。
  ls-type:: annotation
  hl-page:: 749
  hl-color:: yellow
  id:: 63d47fb4-504a-4811-b1b0-cb9b49e14c1f
- 通常状态码为 200 时就会被认为成功了，其他情况可以被认为未成功。
  ls-type:: annotation
  hl-page:: 749
  hl-color:: yellow
  id:: 63d47fcb-02b7-4236-986c-10673f6e3366
- 因为服务器没有响应而导致浏览器超时，这样真正的 fetch()失败会导致期约被拒绝
  ls-type:: annotation
  hl-page:: 749
  hl-color:: yellow
  id:: 63d47fd8-463b-4fb5-916e-c381aaef8f10
- 违反 CORS、无网络连接、HTTPS 错配及其他浏览器/网络策略问题都会导致期约被拒绝
  ls-type:: annotation
  hl-page:: 750
  hl-color:: yellow
  id:: 63d48006-9398-4d07-a2e0-db22ddb1391e
- 自定义选项
  ls-type:: annotation
  hl-page:: 750
  hl-color:: green
  id:: 63d4800f-f112-4027-b7c2-dd4ec9c00add
- 只使用 URL 时，fetch()会发送 GET 请求，只包含最低限度的请求头。
  ls-type:: annotation
  hl-page:: 750
  hl-color:: yellow
  id:: 63d48156-8d7b-4653-952c-f0a268f023ba
- 传入可选的第二个参数 init 对象。init 对象要按照下表中的键/值进行填充
  ls-type:: annotation
  hl-page:: 750
  hl-color:: yellow
  id:: 63d4816d-5d9d-40a2-b6d0-8e3cd73d10c2
- 常见 Fetch 请求模式
  ls-type:: annotation
  hl-page:: 753
  hl-color:: green
  id:: 63d48183-789c-447c-bc63-7a4870696a86
- 使用 init 对象参数，可以配置 fetch()在请求体中发送各种序列化的数据。
  ls-type:: annotation
  hl-page:: 753
  hl-color:: yellow
  id:: 63d481d2-540d-4583-98d8-8756c63b8ef7
- 发送 JSON 数据
  ls-type:: annotation
  hl-page:: 753
  hl-color:: green
  id:: 63d48233-f623-40ec-b85d-fed3dbb0c010
- Content-Type': 'application/json'
  ls-type:: annotation
  hl-page:: 753
  hl-color:: yellow
  id:: 63d4824a-fec9-4656-bbac-78ae303e49d9
- 在请求体中发送参数
  ls-type:: annotation
  hl-page:: 753
  hl-color:: green
  id:: 63d48250-5bbe-4a06-80f0-b7c2cea46b47
- 发送文件
  ls-type:: annotation
  hl-page:: 754
  hl-color:: green
  id:: 63d4825f-4980-43fd-8666-e3c5e5953032
- 因为请求体支持任意字符串值，所以可以通过它发送请求参数：
  ls-type:: annotation
  hl-page:: 753
  hl-color:: yellow
  id:: 63d48273-eeee-4dd8-b324-be690f158a7e
- 可以支持多个文件
  ls-type:: annotation
  hl-page:: 754
  hl-color:: yellow
  id:: 63d4828a-a863-4809-b6f5-c982d10c9298
- 请求体支持 FormData 实现
  ls-type:: annotation
  hl-page:: 754
  hl-color:: yellow
  id:: 63d48290-8fad-42a3-add5-36ee63510dac
- 加载 Blob 文件
  ls-type:: annotation
  hl-page:: 754
  hl-color:: green
  id:: 63d48303-510b-4031-b2ee-215106ef4bc9
- 可以使用响应对象上暴露的 blob()方法。这个方法返回一个期约，解决为一个 Blob 的实例
  ls-type:: annotation
  hl-page:: 754
  hl-color:: yellow
  id:: 63d4831e-12a3-46a5-9514-4e52d6849b8e
- 发送跨源请求
  ls-type:: annotation
  hl-page:: 754
  hl-color:: green
  id:: 63d48359-b429-41bd-bf90-0375965abe1e
- 从不同的源请求资源，响应要包含 CORS 头部才能保证浏览器收到响应
  ls-type:: annotation
  hl-page:: 754
  hl-color:: yellow
  id:: 63d483cf-ed8f-4b52-b57f-92ee103ef26b
- 中断请求
  ls-type:: annotation
  hl-page:: 755
  hl-color:: green
  id:: 63d483ee-fdae-4b82-9498-0f569d80ebb0
- 调用 AbortController. abort()会中断所有网络传输，特别适合希望停止传输大型负载的情况
  ls-type:: annotation
  hl-page:: 755
  hl-color:: yellow
  id:: 63d48405-11bd-42f5-a5c4-13fc0a173714
- 中断进行中的 fetch()请求会导致包含错误的拒绝。
  ls-type:: annotation
  hl-page:: 755
  hl-color:: yellow
  id:: 63d48427-dd25-4f57-aa4e-8c545d8a7bbe
- Headers 对象
  ls-type:: annotation
  hl-page:: 755
  hl-color:: green
  id:: 63d48431-fd84-41c1-bc4d-85393b0d8d32
- 每个入站 Response 实例也可以通过 Response.prototype.headers 访问包含着响应头部的 Headers 对象
  ls-type:: annotation
  hl-page:: 755
  hl-color:: yellow
  id:: 63d4846b-c36f-4231-9e3d-53e3d906be7f
- Headers 与 Map 的相似之处
  ls-type:: annotation
  hl-page:: 755
  hl-color:: green
  id:: 63d48476-4704-48c4-b4c1-a7486bcf2006
- 每个外发的 Request 实例都包含一个空的 Headers 实例，可以通过 Request.prototype.headers 访问
  ls-type:: annotation
  hl-page:: 755
  hl-color:: yellow
  id:: 63d48491-698d-43cb-b9a1-9b3ab58dce05
- 因为 HTTP 头部本质上是序列化后的键/值对，它们的 JavaScript 表示则是中间接口
  ls-type:: annotation
  hl-page:: 755
  hl-color:: yellow
  id:: 63d484af-d22a-4070-b678-3f1d8a13080b
- Headers 独有的特性
  ls-type:: annotation
  hl-page:: 756
  hl-color:: green
  id:: 63d484e1-8635-436f-963b-ba39d4c4f5d3
- 在初始化 Headers 对象时，也可以使用键/值对形式的对象，而 Map 则不可以
  ls-type:: annotation
  hl-page:: 756
  hl-color:: yellow
  id:: 63d48593-8201-4fde-9e0c-9d2aa4cbd2a0
- Headers 对象通过 append()方法支持添加多个值
  ls-type:: annotation
  hl-page:: 756
  hl-color:: yellow
  id:: 63d4859b-8c95-4a06-a497-f3b83aeeb7e7
- 头部护卫
  ls-type:: annotation
  hl-page:: 757
  hl-color:: green
  id:: 63d485ae-1a13-499b-a421-8a61cea373d5
- Headers 对象使用护卫来防止不被允许的修改
  ls-type:: annotation
  hl-page:: 757
  hl-color:: yellow
  id:: 63d485e5-634c-42d2-a99c-8df3956e83b8
- Request 对象
  ls-type:: annotation
  hl-page:: 757
  hl-color:: green
  id:: 63d48613-a41a-434d-89fa-8ee0c9773edc
- Request 对象是获取资源请求的接口
  ls-type:: annotation
  hl-page:: 757
  hl-color:: yellow
  id:: 63d4861f-9198-4bba-852c-bb3a2a151201
- 创建 Request 对象
  ls-type:: annotation
  hl-page:: 757
  hl-color:: green
  id:: 63d48628-99b6-4fec-aad5-2dd867b74290
- 可以通过构造函数初始化 Request 对象。为此需要传入一个 input 参数，一般是 URL
  ls-type:: annotation
  hl-page:: 757
  hl-color:: yellow
  id:: 63d4866a-89d5-4bf5-a1a7-24a22bd3a572
- Request 构造函数也接收第二个参数——一个 init 对象
  ls-type:: annotation
  hl-page:: 757
  hl-color:: yellow
  id:: 63d48687-3ff3-4bc8-8005-3845bec25183
- 克隆 Request 对象
  ls-type:: annotation
  hl-page:: 758
  hl-color:: green
  id:: 63d48693-6d1f-4e6d-8509-fb80a5f302f8
- 创建 Request 对象的副本：使用 Request 构造函数和使用 clone()方法。
  ls-type:: annotation
  hl-page:: 758
  hl-color:: yellow
  id:: 63d486a4-fe86-4dd9-99c6-960922dfbc99
- 如果再传入 init 对象，则 init 对象的值会覆盖源对象中同名的值
  ls-type:: annotation
  hl-page:: 758
  hl-color:: yellow
  id:: 63d486b7-6d18-40c6-99c6-c718a3fb8ca6
- 第二种克隆 Request 对象的方式是使用 clone()方法，这个方法会创建一模一样的副本，任何值都不会被覆盖
  ls-type:: annotation
  hl-page:: 759
  hl-color:: yellow
  id:: 63d486ca-de14-47b3-ab49-7ce45b82273f
- 如果请求对象的 bodyUsed 属性为 true（即请求体已被读取），那么上述任何一种方式都不能用来创建这个对象的副本。
  ls-type:: annotation
  hl-page:: 759
  hl-color:: yellow
  id:: 63d4870d-846d-4ecc-93da-d1f901795921
- 在 fetch()中使用 Request 对象
  ls-type:: annotation
  hl-page:: 759
  hl-color:: green
  id:: 63d48723-2134-45ec-af6c-06b1af4fcf00
- 在调用 fetch()时，可以传入已经创建好的 Request 实例而不是 URL
  ls-type:: annotation
  hl-page:: 759
  hl-color:: yellow
  id:: 63d4874d-ad83-4e37-90de-ff4010ad8d1b
- fetch()也不能拿请求体已经用过的 Request 对象来发送请求
  ls-type:: annotation
  hl-page:: 759
  hl-color:: yellow
  id:: 63d4876f-aa04-454b-a5c1-e4a7bfb63108
- 要想基于包含请求体的相同 Request 对象多次调用 fetch()，必须在第一次发送 fetch()请求前调用 clone()
  ls-type:: annotation
  hl-page:: 760
  hl-color:: yellow
  id:: 63d487b3-d4d4-4b58-a810-5e136c9f3b96
- 通过 fetch 使用 Request 会将请求体标记为已使用。
  ls-type:: annotation
  hl-page:: 760
  hl-color:: yellow
  id:: 63d487ba-ae79-43d5-ae55-f64c7e9724a4
- Response 对象
  ls-type:: annotation
  hl-page:: 760
  hl-color:: green
  id:: 63d487d3-88d8-4157-998e-c9c57081b2a2
- Response 对象是获取资源响应的接口
  ls-type:: annotation
  hl-page:: 760
  hl-color:: yellow
  id:: 63d487e6-803d-444a-8387-fe609cbca2ef
- 创建 Response 对象
  ls-type:: annotation
  hl-page:: 760
  hl-color:: green
  id:: 63d487ed-1fb0-442d-af79-e6fd71cca5ca
- 可以通过构造函数初始化 Response 对象且不需要参数
  ls-type:: annotation
  hl-page:: 760
  hl-color:: yellow
  id:: 63d4880e-8392-47e0-90c4-a19dce7d8ac4
- Response 构造函数接收一个可选的 body 参数。
  ls-type:: annotation
  hl-page:: 760
  hl-color:: yellow
  id:: 63d48816-5906-493c-b188-138319809448
- 还可以接收一个可选的 init 对象
  ls-type:: annotation
  hl-page:: 760
  hl-color:: yellow
  id:: 63d4882a-440d-4934-adce-c88a1cb9b627
- 大多数情况下，产生 Response 对象的主要方式是调用 fetch()，它返回一个最后会解决为 Response 对象的期约
  ls-type:: annotation
  hl-page:: 761
  hl-color:: yellow
  id:: 63d48843-db8a-45ba-93b0-3f096cca9bd7
- 于生成 Response 对象的静态方法：Response.redirect()和 Response. error()
  ls-type:: annotation
  hl-page:: 761
  hl-color:: yellow
  id:: 63d48850-99a3-4573-8249-1362a0ac4983
- Response.error()用于产生表示网络错误的 Response 对象（网络错误会导致 fetch()期约被拒绝）。
  ls-type:: annotation
  hl-page:: 762
  hl-color:: yellow
  id:: 63d48860-8585-4c0d-89a2-082f630d0d40
- 前者接收一个 URL 和一个重定向状态码（301、302、303、307 或 308），返回重定向的 Response对象：
  ls-type:: annotation
  hl-page:: 761
  hl-color:: yellow
  id:: 63d48873-b6c7-42aa-94ba-0ba74d27f944
- 读取响应状态信息
  ls-type:: annotation
  hl-page:: 762
  hl-color:: green
  id:: 63d4888a-f81e-42c2-93a6-a0fc9e9a5a82
- Response 对象包含一组只读属性，描述了请求完成后的状态
  ls-type:: annotation
  hl-page:: 762
  hl-color:: yellow
  id:: 63d48897-c262-4eab-8bf7-03768878d9e7
- 克隆 Response 对象
  ls-type:: annotation
  hl-page:: 763
  hl-color:: green
  id:: 63d488ac-922b-40c0-ae31-860b9084a84d
  hl-stamp:: 1674873006802
- 克隆 Response 对象的主要方式是使用 clone()方法
  ls-type:: annotation
  hl-page:: 763
  hl-color:: yellow
  id:: 63d488ba-d9a1-40f4-81fe-06b92a30f175
- 如果响应对象的 bodyUsed 属性为 true（即响应体已被读取），则不能再创建这个对象的副本
  ls-type:: annotation
  hl-page:: 764
  hl-color:: yellow
  id:: 63d488c6-474a-4fa7-8651-f1daa9e102e3
- 通过创建带有原始响应体的 Response 实例，可以执行伪克隆操作。关键是这样不会把第一个 Response 实例标记为已读，而是会在两个响应之间共享
  ls-type:: annotation
  hl-page:: 764
  hl-color:: yellow
  id:: 63d488e4-0cd2-4699-81e1-4dea96223505
- Request、Response 及 Body 混入
  ls-type:: annotation
  hl-page:: 764
  hl-color:: green
  id:: 63d488f9-76bd-48dd-81de-64698954fd0d
- Body 混入提供了 5 个方法，用于将 ReadableStream 转存到缓冲区的内存里，将缓冲区转换为某种 JavaScript 对象类型，以及通过期约来产生结果。
  ls-type:: annotation
  hl-page:: 765
  hl-color:: yellow
  id:: 63d48922-96b6-4107-afd6-59ae5355895e
- Body.text()
  ls-type:: annotation
  hl-page:: 765
  hl-color:: green
  id:: 63d48948-26b0-40bb-b45b-afde9361599d
- Body.text()方法返回期约，解决为将缓冲区转存得到的 UTF-8 格式字符串
  ls-type:: annotation
  hl-page:: 765
  hl-color:: yellow
  id:: 63d48953-74de-4c01-82d9-0f7b227067d0
- Body.json()
  ls-type:: annotation
  hl-page:: 765
  hl-color:: green
  id:: 63d489a4-742b-4e17-88d7-165c06b6228e
- Body.json()方法返回期约，解决为将缓冲区转存得到的 JSON。
  ls-type:: annotation
  hl-page:: 765
  hl-color:: yellow
  id:: 63d489ad-cbfa-4fcc-a377-453b8bf41e5c
- Body.formData()
  ls-type:: annotation
  hl-page:: 765
  hl-color:: green
  id:: 63d489bd-ae0a-43a0-b797-9079014ed734
- 浏览器可以将 FormData 对象序列化/反序列化为主体
  ls-type:: annotation
  hl-page:: 765
  hl-color:: yellow
  id:: 63d489c7-d19a-493b-a728-d2caad934bea
- Body.formData()方法返回期约，解决为将缓冲区转存得到的 FormData 实例
  ls-type:: annotation
  hl-page:: 766
  hl-color:: yellow
  id:: 63d489e3-2f88-4bd0-9ca6-f0cfa9477f80
- Body.arrayBuffer()
  ls-type:: annotation
  hl-page:: 766
  hl-color:: green
  id:: 63d48a20-fe62-4f17-83a2-32dc6e4cdb32
  hl-stamp:: 1674873425818
- Body.blob()
  ls-type:: annotation
  hl-page:: 766
  hl-color:: green
  id:: 63d48a4b-10d1-42b7-9b44-6331c8d49439
- 一次性流
  ls-type:: annotation
  hl-page:: 767
  hl-color:: green
  id:: 63d48a55-53d3-45bc-aa2e-069c1de3174c
- 所有主体混入方法都只能调用一次，再次调用就会抛出错误。
  ls-type:: annotation
  hl-page:: 767
  hl-color:: yellow
  id:: 63d48a8b-2bba-45e5-985a-4e16e18abf51
- 即使是在读取流的过程中，所有这些方法也会在它们被调用时给 ReadableStream 加锁，以阻止其他读取器访问
  ls-type:: annotation
  hl-page:: 767
  hl-color:: yellow
  id:: 63d48ac7-3fe1-4d86-aec6-c5f5074ba17a
- 作为 Body 混入的一部分，bodyUsed 布尔值属性表示 ReadableStream 是否已摄受（disturbed），意思是读取器是否已经在流上加了锁
  ls-type:: annotation
  hl-page:: 767
  hl-color:: yellow
  id:: 63d48af3-eebb-4619-8e07-0d43302736a1
- 使用 ReadableStream 主体
  ls-type:: annotation
  hl-page:: 768
  hl-color:: green
  id:: 63d48b0d-323e-45a4-9043-af4451762743
- ，ReadableStream 暴露了 getReader()方法，用于产生 ReadableStreamDefaultReader，这个读取器可以用于在数据到达时异步获取数据块
  ls-type:: annotation
  hl-page:: 768
  hl-color:: yellow
  id:: 63d48b59-df6c-4b8a-8034-69d61a8fd146
- 异步函数非常适合这样的 fetch()操作。可以通过使用 async/await 将上面的递归调用打平
  ls-type:: annotation
  hl-page:: 769
  hl-color:: yellow
  id:: 63d48b6d-9cf5-4996-93db-7ad8fbc5b5b5
- read()方法也可以真接封装到 Iterable 接口中。因此就可以在 for-await-of 循环中方便地实现这种转换
  ls-type:: annotation
  hl-page:: 769
  hl-color:: yellow
  id:: 63d48b8c-4de3-46cc-94bf-0c53e0dc42df
- 如果流因为耗尽或错误而终止，读取器会释放锁，以允许不同的流读取器继续操作：
  ls-type:: annotation
  hl-page:: 769
  hl-color:: yellow
  id:: 63d48bb1-5f2b-49bd-8dc5-c91c01246b32
- 要将 Uint8Array 转换为可读文本，可以将缓冲区传给 TextDecoder，返回转换后的值
  ls-type:: annotation
  hl-page:: 770
  hl-color:: yellow
  id:: 63d48bd1-a1db-4087-a900-d4f9098c1f09
- 以使用 ReadableStream 创建 Response 对象，所以就可以在读取流之后，将其通过管道导入另一个流
  ls-type:: annotation
  hl-page:: 771
  hl-color:: yellow
  id:: 63d48bee-4dfd-4e04-9af5-c3dee4fe7bc1
- Beacon API
  ls-type:: annotation
  hl-page:: 772
  hl-color:: green
  id:: 63d48c07-1c68-4d0f-b3d3-4fcd6f3a6fb7
- 浏览器会因为要等待 unload 事件处理程序完成而延迟导航到下一个页面。
  ls-type:: annotation
  hl-page:: 772
  hl-color:: yellow
  id:: 63d48c4c-467f-4e21-a9d2-2c9ab65ebb78
- sendBeacon()方法。这个简单的方法接收一个 URL 和一个数据有效载荷参数，并会发送一个 POST请求。可
  ls-type:: annotation
  hl-page:: 772
  hl-color:: yellow
  id:: 63d48c6f-627e-4756-bdfa-3719015e63b8
- 调用 sendBeacon()后，浏览器会把请求添加到一个内部的请求队列。浏览器会主动地发送队列中的请求。
  ls-type:: annotation
  hl-page:: 772
  hl-color:: yellow
  id:: 63d48ca0-d601-47d8-83a6-122cfaf71c42
- 信标（beacon）请求会携带调用 sendBeacon()时所有相关的 cookie。
  ls-type:: annotation
  hl-page:: 772
  hl-color:: yellow
  id:: 63d48cb1-4894-4625-b37b-ba4d7a2429cc
- Web Socket
  ls-type:: annotation
  hl-page:: 772
  hl-color:: green
  id:: 63d48ce6-9ad7-463c-bccf-b980369ff2bb
- 通过一个长时连接实现与服务器全双工、双向的通信
  ls-type:: annotation
  hl-page:: 772
  hl-color:: yellow
  id:: 63d48cf5-9e32-4a8e-9168-a2eaefd2dab8
- 创建 Web Socket 时，一个 HTTP 请求会发送到服务器以初始化连接
  ls-type:: annotation
  hl-page:: 772
  hl-color:: yellow
  id:: 63d48d11-2c97-472a-98c0-ee9b34363cbb
- 服务器响应后，连接使用 HTTP的 Upgrade 头部从 HTTP 协议切换到 Web Socket 协议
  ls-type:: annotation
  hl-page:: 772
  hl-color:: yellow
  id:: 63d48d1a-db42-4821-9bd1-8907461872b3
- 因为 Web Socket 使用了自定义协议，所以 URL 方案（scheme）稍有变化：不能再使用 http://或 https://，而要使用 ws://和 wss://
  ls-type:: annotation
  hl-page:: 772
  hl-color:: yellow
  id:: 63d48d29-af9c-4689-b533-9087d94e509a
- 使用自定义协议的缺点是，定义协议的时间比定义 JavaScript API 要长
  ls-type:: annotation
  hl-page:: 772
  hl-color:: yellow
  id:: 63d48d3b-68c2-4ccf-baa6-84302c6ccc22
- API
  ls-type:: annotation
  hl-page:: 773
  hl-color:: green
  id:: 63d48d5d-cb84-4855-9579-e19b5dde7e95
- 必须给 WebSocket 构造函数传入一个绝对 URL
  ls-type:: annotation
  hl-page:: 773
  hl-color:: yellow
  id:: 63d48d72-b65e-45e4-a36f-228e2ae6d0b8
- 任何时候都可以调用 close()方法关闭 Web Socket 连接
  ls-type:: annotation
  hl-page:: 773
  hl-color:: yellow
  id:: 63d48d84-8836-4c04-8d17-b61530ad2587
- 发送和接收数据
  ls-type:: annotation
  hl-page:: 773
  hl-color:: green
  id:: 63d48d99-1f0f-4374-bbdd-2c25be22aad1
- 打开 Web Socket 之后，可以通过连接发送和接收数据。要向服务器发送数据，使用 send()方法并传入一个字符串、ArrayBuffer 或 Blob
  ls-type:: annotation
  hl-page:: 773
  hl-color:: yellow
  id:: 63d48da6-ecbe-425d-a10f-cfae9c024f43
- 服务器向客户端发送消息时，WebSocket 对象上会触发 message 事件。
  ls-type:: annotation
  hl-page:: 773
  hl-color:: yellow
  id:: 63d48e30-2275-471a-b6b9-295d36f02fa0
- 其他事件
  ls-type:: annotation
  hl-page:: 773
  hl-color:: green
  id:: 63d48e38-8257-45d8-a76a-b37be4fbf16a
- 需要使用 DOM Level 0 风格的事件处理程序来监听这些事件
  ls-type:: annotation
  hl-page:: 774
  hl-color:: yellow
  id:: 63d48e98-7007-48e4-9f37-347996a2d5c3
- 只有 close 事件的 event 对象上有额外信息。这个对象上有 3 个额外属性
  ls-type:: annotation
  hl-page:: 774
  hl-color:: yellow
  id:: 63d48fe8-e730-4178-84e4-92cc233baebc
- 安全
  ls-type:: annotation
  hl-page:: 774
  hl-color:: green
  id:: 63d49022-3327-4f40-b593-9333344652d4
- 在未授权系统可以访问某个资源时，可以将其视为跨站点请求伪造（CSRF，cross-site request forgery）攻击
  ls-type:: annotation
  hl-page:: 774
  hl-color:: yellow
  id:: 63d49049-30a3-4637-bbdb-6c3efa5e64b9
- 要求通过 SSL 访问能够被 Ajax 访问的资源。
  ls-type:: annotation
  hl-page:: 774
  hl-color:: yellow
  id:: 63d4906e-ca24-4a0b-aad3-34be0daac038
- 要求每个请求都发送一个按约定算法计算好的令牌（token）。
  ls-type:: annotation
  hl-page:: 774
  hl-color:: yellow
  id:: 63d49077-0b0c-40db-bd8f-10998515e024
- cookie
  ls-type:: annotation
  hl-page:: 776
  hl-color:: green
  id:: 63d490bd-d67e-4eba-8cf8-ed0bf0d1c27e
- 最初用于在客户端存储会话信息
  ls-type:: annotation
  hl-page:: 776
  hl-color:: yellow
  id:: 63d4ccbc-4f4a-4ccd-996a-c66f7729f69d
- 要求服务器在响应 HTTP 请求时，通过发送 Set-Cookie HTTP 头部包含会话信息
  ls-type:: annotation
  hl-page:: 776
  hl-color:: yellow
  id:: 63d4ccd2-e7e6-44ee-9a3a-d9fe2b9d101d
- 这些发送回服务器的额外信息可用于唯一标识发送请求的客户端
  ls-type:: annotation
  hl-page:: 776
  hl-color:: yellow
  id:: 63d4cd1f-e757-4988-a6a8-73105fecfc3b
- 限制
  ls-type:: annotation
  hl-page:: 776
  hl-color:: green
  id:: 63d4cd26-1460-46b7-89cf-1a232cf73ed7
- cookie 是与特定域绑定的
  ls-type:: annotation
  hl-page:: 776
  hl-color:: yellow
  id:: 63d4cdbb-29d8-4cf8-a5f3-5fd3749a0c0c
- 每个域能设置的 cookie 总数也是受限的，但不同浏览器的限制不同
  ls-type:: annotation
  hl-page:: 777
  hl-color:: yellow
  id:: 63d4cdd8-4c23-431e-b8c8-15575254df05
- cookie 的构成
  ls-type:: annotation
  hl-page:: 777
  hl-color:: green
  id:: 63d4ce14-3f46-4580-ac6b-c4f9cad5b100
- JavaScript 中的 cookie
  ls-type:: annotation
  hl-page:: 778
  hl-color:: green
  id:: 63d4cf00-5954-4b19-b7b3-d754988a0026
- 接口过于简单，只有 BOM 的 document.cookie 属性
  ls-type:: annotation
  hl-page:: 778
  hl-color:: yellow
  id:: 63d4cf30-6e0e-437a-bf29-6f93e3bd3e95
- 所有名和值都是 URL 编码的，因此必须使用 decodeURIComponent()解码。
  ls-type:: annotation
  hl-page:: 778
  hl-color:: yellow
  id:: 63d4cf45-5f05-48ea-abad-83945bff9f87
- 在设置值时，可以通过 document.cookie 属性设置新的 cookie 字符串
  ls-type:: annotation
  hl-page:: 778
  hl-color:: yellow
  id:: 63d4cf6e-4b08-4644-80c1-c9c2be00c978
- 最好还是使用 encodeURIComponent()对名称和值进行编码
  ls-type:: annotation
  hl-page:: 778
  hl-color:: yellow
  id:: 63d4cf9b-8357-48d8-b21c-8ba2fa1dffe8
- 子 cookie
  ls-type:: annotation
  hl-page:: 780
  hl-color:: green
  id:: 63d4cfc4-7d91-4c67-9b26-d3202652e461
- name=name1=value1&name2=value2&name3=value3&name4=value4&name5=v
  ls-type:: annotation
  hl-page:: 780
  hl-color:: yellow
  id:: 63d4cff3-c818-4825-be33-001799e4f519
- 使用 cookie 的注意事项
  ls-type:: annotation
  hl-page:: 784
  hl-color:: green
  id:: 63d4d00d-20c9-496a-a570-87e00d075b0b
- HTTP-only 可以在浏览器设置，也可以在服务器设置，但只能在服务器上读取，这是因为 JavaScript 无法取得这种 cookie 的值
  ls-type:: annotation
  hl-page:: 784
  hl-color:: yellow
  id:: 63d4d01e-41fc-4cc9-baaf-fd70776aeb3b
- Web Storage
  ls-type:: annotation
  hl-page:: 784
  hl-color:: green
  id:: 63d4d061-c2a8-4e30-8db7-db2fae525a5b
- 。Web Storage 的目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用 cookie 的问题
  ls-type:: annotation
  hl-page:: 784
  hl-color:: yellow
  id:: 63d4d072-f4c9-46e6-bed8-808fc748a3b0
- 提供在 cookie 之外的存储会话数据的途径
  ls-type:: annotation
  hl-page:: 784
  hl-color:: yellow
  id:: 63d4d079-b15f-40d9-bcdb-c06e90d6ad57
- 提供跨会话持久化存储大量数据的机制
  ls-type:: annotation
  hl-page:: 784
  hl-color:: yellow
  id:: 63d4d084-be24-499d-8d8d-ce2d2cf461f3
- localStorage 是永久存储机制
  ls-type:: annotation
  hl-page:: 784
  hl-color:: yellow
  id:: 63d4d08e-0bdf-4bf9-a2b3-4a2a43baefa3
- sessionStorage 是跨会话的存储机制
  ls-type:: annotation
  hl-page:: 784
  hl-color:: yellow
  id:: 63d4d094-10b0-40ea-9c79-b447aad1914a
- Storage 类型
  ls-type:: annotation
  hl-page:: 784
  hl-color:: green
  id:: 63d4d09b-d901-4027-9d6e-68e33e15f61d
- Storage 类型用于保存名/值对数据，直至存储空间上限（由浏览器决定）
  ls-type:: annotation
  hl-page:: 784
  hl-color:: yellow
  id:: 63d4d0f1-4ec4-442f-b48f-703cb2205a38
- Storage 类型只能存储字符串。非字符串数据在存储之前会自动转换为字符串
  ls-type:: annotation
  hl-page:: 785
  hl-color:: yellow
  id:: 63d4d12c-13df-4070-944b-2c510379ea94
- sessionStorage 对象
  ls-type:: annotation
  hl-page:: 785
  hl-color:: green
  id:: 63d4d132-bd0a-4b50-b153-d894024b0f8a
- essionStorage 对象只存储会话数据，这意味着数据只会存储到浏览器关闭
  ls-type:: annotation
  hl-page:: 785
  hl-color:: yellow
  id:: 63d4d13d-d981-46a9-91e0-d1acecd828e6
- 存储在 sessionStorage 中的数据不受页面刷新影响，可以在浏览器崩溃并重启后恢复
  ls-type:: annotation
  hl-page:: 785
  hl-color:: yellow
  id:: 63d4d14b-6f1f-42ff-9ca6-fccb6167f43c
- sessionStorage 对象是 Storage 的实例
  ls-type:: annotation
  hl-page:: 785
  hl-color:: yellow
  id:: 63d4d158-ba6d-4304-822e-e4e558f9a367
- 所有现代浏览器在实现存储写入时都使用了同步阻塞方式，因此数据会被立即提交到存储。
  ls-type:: annotation
  hl-page:: 785
  hl-color:: yellow
  id:: 63d4d1a6-f0f9-4742-82bf-84e24bedf06b
- 对存在于 sessionStorage 上的数据，可以使用 getItem()或直接访问属性名来取得
  ls-type:: annotation
  hl-page:: 785
  hl-color:: yellow
  id:: 63d4d1c6-037c-4145-89aa-b436d6d6ca9d
- 要从 sessionStorage 中删除数据，可以使用 delete 操作符直接删除对象属性，也可以使用 removeItem()方法
  ls-type:: annotation
  hl-page:: 786
  hl-color:: yellow
  id:: 63d4d1df-0a2e-4bc4-aa40-e36cfe9f0f93
- ocalStorage 对象
  ls-type:: annotation
  hl-page:: 786
  hl-color:: green
  id:: 63d4d1e5-5d78-4408-b6b1-786cf12c4080
- 要访问同一个 localStorage 对象，页面必须来自同一个域（子域不可以）、在相同的端口上使用相同的协议
  ls-type:: annotation
  hl-page:: 786
  hl-color:: yellow
  id:: 63d4d1fa-196d-4e49-9b64-6d22e4f977b8
- localStorage 是 Storage 的 实 例 
  ls-type:: annotation
  hl-page:: 786
  hl-color:: yellow
  id:: 63d4d201-fc26-4774-bc1f-ac64617fe1ec
- 储在 localStorage 中的数据会保留到通过 JavaScript 删除或者用户清除浏览器缓存
  ls-type:: annotation
  hl-page:: 787
  hl-color:: yellow
  id:: 63d4d23e-53d8-475f-b58a-26b0c56925fe
- 存储事件
  ls-type:: annotation
  hl-page:: 787
  hl-color:: green
  id:: 63d4d244-7edb-4dce-90fb-d96c6d1bdbab
- 每当 Storage 对象发生变化时，都会在文档上触发 storage 事件
  ls-type:: annotation
  hl-page:: 787
  hl-color:: yellow
  id:: 63d4d258-d05d-44ba-827a-ce5fd2a72f70
- 限制
  ls-type:: annotation
  hl-page:: 787
  hl-color:: green
  id:: 63d4d270-7a20-4619-85e0-b5f92a5ba828
- 不同浏览器给 localStorage 和 sessionStorage 设置了不同的空间限制，但大多数会限制为每个源 5MB
  ls-type:: annotation
  hl-page:: 787
  hl-color:: yellow
  id:: 63d4d280-f526-436a-9444-6e63dd84cafd
- IndexedDB
  ls-type:: annotation
  hl-page:: 787
  hl-color:: green
  id:: 63d4d289-03a2-4afe-a844-e074fc4f6060
- IndexedDB 背后的思想是创造一套 API，方便 JavaScript 对象的存储和获取，同时也支持查询和搜索
  ls-type:: annotation
  hl-page:: 787
  hl-color:: yellow
  id:: 63d4d2aa-98a8-402c-8cd3-6f22b6419904
- IndexedDB 的设计几乎完全是异步的。
  ls-type:: annotation
  hl-page:: 787
  hl-color:: yellow
  id:: 63d4d2b2-4489-4400-ac44-788ff118e2eb
- 数据库
  ls-type:: annotation
  hl-page:: 788
  hl-color:: green
  id:: 63d4d2ce-b79d-489d-a645-596bb6eb7d16
- IndexedDB 使用对象存储而不是表格保存数据
  ls-type:: annotation
  hl-page:: 788
  hl-color:: yellow
  id:: 63d4d2dc-11f4-4ded-b901-d1e3e5d82d5e
- 第一步是调用 indexedDB.open()方法，并给它传入一个要打开的数据库名称
  ls-type:: annotation
  hl-page:: 788
  hl-color:: yellow
  id:: 63d4d30f-db10-4a87-9cf8-c251c0116899
- 这个方法会返回 IDBRequest 的实例，可以在这个实例上添加 onerror 和 onsuccess 事件处理程序
  ls-type:: annotation
  hl-page:: 788
  hl-color:: yellow
  id:: 63d4d324-a6ba-4950-acf1-01393682360f
- 如果 onsuccess事件处理程序被调用，说明可以通过 event.target.result 访问数据库（IDBDatabase）实例了
  ls-type:: annotation
  hl-page:: 788
  hl-color:: yellow
  id:: 63d4d344-498f-488e-83c8-b7601134cf9f
- 对象存储
  ls-type:: annotation
  hl-page:: 788
  hl-color:: green
  id:: 63d4d34c-8dc8-4416-a81c-8c8546b48e7e
- 如果打开数据库期间发生错误，event.target.errorCode 中就会存储表示问题的错误码。
  ls-type:: annotation
  hl-page:: 788
  hl-color:: yellow
  id:: 63d4d357-c722-4924-9a00-62ef9e677889
- 用户名必须全局唯一，它也是大多数情况下访问数据的凭据。这个键很重要，因为创建对象存储时必须指定一个键
  ls-type:: annotation
  hl-page:: 788
  hl-color:: yellow
  id:: 63d4d36b-8a27-4f50-9d93-ada776e7b402
- 数据库的版本决定了数据库模式，包括数据库中的对象存储和这些对象存储的结构
  ls-type:: annotation
  hl-page:: 789
  hl-color:: yellow
  id:: 63d4d376-3a0b-42c4-8416-e604395fb067
- 如果数据库还不存在，open()操作会创建一个新数据库，然后触发 upgradeneeded 事件
  ls-type:: annotation
  hl-page:: 789
  hl-color:: yellow
  id:: 63d4d398-bae1-407b-a1c9-1117990213c8
- 如果数据库存在，而你指定了一个升级版的版本号，则会立即触发 upgradeneeded 事件，因而可以在事件处理程序中更新数据库模式
  ls-type:: annotation
  hl-page:: 789
  hl-color:: yellow
  id:: 63d4d3c1-2e63-415b-bfee-7c493bf2021b
- 这里第二个参数的 keyPath 属性表示应该用作键的存储对象的属性名
  ls-type:: annotation
  hl-page:: 789
  hl-color:: yellow
  id:: 63d4d3de-252a-470e-9938-4ab887a2dec1
- 事务
  ls-type:: annotation
  hl-page:: 789
  hl-color:: green
  id:: 63d4d3f2-d65d-4d80-80df-8175f3a2ab84
- 事务要通过调用数据库对象的 transaction()方法创建
  ls-type:: annotation
  hl-page:: 789
  hl-color:: yellow
  id:: 63d4d3fe-c3bf-4c1d-bda0-b90c1c582064
- 任何时候，只要想要读取或修改数据，都要通过事务把所有修改操作组织起来
  ls-type:: annotation
  hl-page:: 789
  hl-color:: yellow
  id:: 63d4d454-5905-4218-bf6e-bb1f56e91a38
- 要修改访问模式，可以传入第二个参数。这个参数应该是下列三个字符串之一："readonly"、"readwrite"或"versionchange"
  ls-type:: annotation
  hl-page:: 789
  hl-color:: yellow
  id:: 63d4d46b-a286-4a46-b7e6-f7d7bdafeca7
- 有了事务的引用，就可以使用 objectStore()方法并传入对象存储的名称以访问特定的对象存储
  ls-type:: annotation
  hl-page:: 789
  hl-color:: yellow
  id:: 63d4d479-1983-461f-b7d7-d25797d38056
- 因为一个事务可以完成任意多个请求，所以事务对象本身也有事件处理程序：onerror 和 oncomplete。
  ls-type:: annotation
  hl-page:: 790
  hl-color:: yellow
  id:: 63d4d4a9-d03d-40f9-8d6d-be3c03c6be88
- 插入对象
  ls-type:: annotation
  hl-page:: 790
  hl-color:: green
  id:: 63d4d4c8-9a43-4513-b49d-7b05ec48315a
- 因此，仍然需要通过这些请求的 onsuccess 事件处理程序来获取数据
  ls-type:: annotation
  hl-page:: 790
  hl-color:: yellow
  id:: 63d4d4d8-1a76-4cc5-a094-c31ae03b2981
- add()会导致错误
  ls-type:: annotation
  hl-page:: 790
  hl-color:: yellow
  id:: 63d4d521-4c45-4854-8bb6-482c48b84ba6
- put()会简单地重写该对象
  ls-type:: annotation
  hl-page:: 790
  hl-color:: yellow
  id:: 63d4d526-1abf-4199-bd3b-60c2301d4f1e
- 如果想验证请求成功与否，可以把请求对象保存到一个变量，然后为它添加 onerror 和 onsuccess 事件处理程序
  ls-type:: annotation
  hl-page:: 790
  hl-color:: yellow
  id:: 63d4d53a-35ab-433c-82aa-b6d102a17363
- 通过游标查询
  ls-type:: annotation
  hl-page:: 790
  hl-color:: green
  id:: 63d4d54e-fc26-45ed-b5ca-9cbaeabaeb52
- 如果想取得多条数据，则需要在事务中创建一个游标
  ls-type:: annotation
  hl-page:: 790
  hl-color:: yellow
  id:: 63d4d580-0165-4fb6-bff8-d0461966527c
- 游标指向第一个结果，并在接到指令前不会主动查找下一条数据
  ls-type:: annotation
  hl-page:: 790
  hl-color:: yellow
  id:: 63d4d58e-2301-4798-a6b0-ede575539cca
- 需要在对象存储上调用 openCursor()方法创建游标
  ls-type:: annotation
  hl-page:: 790
  hl-color:: yellow
  id:: 63d4d599-9394-4458-8035-4ec3db1c58a5
- 游标使用的键。可能是对象键或索引键
  ls-type:: annotation
  hl-page:: 791
  hl-color:: yellow
  id:: 63d4d64e-57f6-49a6-b49b-7668d895df64
- update()方法使用指定的对象更新当前游标对应的值
  ls-type:: annotation
  hl-page:: 791
  hl-color:: yellow
  id:: 63d4d6c2-2d2c-4cf2-ad28-db35d52f5e3e
- 调用 delelte()来删除游标位置的记录
  ls-type:: annotation
  hl-page:: 791
  hl-color:: yellow
  id:: 63d4d718-9e7c-44c2-8f7c-e08150aa0aff
- 每个游标只会创建一个请求。要创建另一个请求，必须调用下列中的一个方法
  ls-type:: annotation
  hl-page:: 792
  hl-color:: yellow
  id:: 63d4d728-9a95-4efc-923e-62559241bdf8
- 移动到结果集中的下一条记录
  ls-type:: annotation
  hl-page:: 792
  hl-color:: yellow
  id:: 63d4d995-f95c-48a5-8a81-8b3ad9ca720e
- 游标向前移动指定的 count 条记录
  ls-type:: annotation
  hl-page:: 792
  hl-color:: yellow
  id:: 63d4d9a8-925c-40d0-b18a-1a2c7d9e2fb2
- 键范围
  ls-type:: annotation
  hl-page:: 792
  hl-color:: green
  id:: 63d4d9b5-56b9-411c-92cb-e155c623ff38
- 第一种是使用 only()方法并传入想要获取的键
  ls-type:: annotation
  hl-page:: 792
  hl-color:: yellow
  id:: 63d4d9f6-acb7-4647-9474-23529e02af21
- 第二种键范围可以定义结果集的下限。下限表示游标开始的位置
  ls-type:: annotation
  hl-page:: 792
  hl-color:: yellow
  id:: 63d4da08-81ba-4565-83a9-38d3fbc4be78
- 第三种键范围可以定义结果集的上限，通过调用 upperBound()方法可以指定游标不会越过的记录。
  ls-type:: annotation
  hl-page:: 793
  hl-color:: yellow
  id:: 63d4da1a-3c9e-4467-b2bf-5b615f6853e8
- 要同时指定下限和上限，可以使用 bound()方法。这个方法接收四个参数：下限的键、上限的键、可选的布尔值表示是否跳过下限和可选的布尔值表示是否跳过上限
  ls-type:: annotation
  hl-page:: 793
  hl-color:: yellow
  id:: 63d4dab0-e391-4c19-85ce-1b2e6aabe116
- 定义了范围之后，把它传给 openCursor()方法，就可以得到位于该范围内的游标
  ls-type:: annotation
  hl-page:: 793
  hl-color:: yellow
  id:: 63d4dac4-baf6-4cad-b33c-90e4b536b07d
- 设置游标方向
  ls-type:: annotation
  hl-page:: 793
  hl-color:: green
  id:: 63d4dacd-09a2-48dc-a246-8768808bbcdc
- openCursor()方法实际上可以接收两个参数
  ls-type:: annotation
  hl-page:: 793
  hl-color:: yellow
  id:: 63d4db3e-7cd9-46a6-ac81-b3551cd03290
- 索引
  ls-type:: annotation
  hl-page:: 794
  hl-color:: green
  id:: 63d4db8e-91e4-448c-a3c9-fed98c585463
- 可以考虑将用户 ID 作为主键，然后在用户名上创建索引
  ls-type:: annotation
  hl-page:: 794
  hl-color:: yellow
  id:: 63d4dc0f-8fbe-4db7-b026-24d803d02d10
- 使用 openKeyCursor()方法也可以在索引上创建特殊游标，只返回每条记录的主键
  ls-type:: annotation
  hl-page:: 794
  hl-color:: yellow
  id:: 63d4dd4f-02a4-4dd3-a98d-a1bdcc0a68f2
- createIndex()的第一个参数是索引的名称，第二个参数是索引属性的名称，第三个参数是包含键 unique 的 options 对象
  ls-type:: annotation
  hl-page:: 794
  hl-color:: yellow
  id:: 63d4dd6b-0638-47f5-868f-ca671fccabee
- 最大的不同在于，event.result.key 是索引键，且 event.result.value是主键而不是整个记录
  ls-type:: annotation
  hl-page:: 794
  hl-color:: yellow
  id:: 63d4dd8c-a4c8-4711-a03e-22817469f22d
- 可以使用 get()方法并传入索引键通过索引取得单条记录
  ls-type:: annotation
  hl-page:: 795
  hl-color:: yellow
  id:: 63d4de1f-1799-49a2-9e37-2b3fc3a9c545
- 如果想只取得给定索引键的主键，可以使用 getKey()方法。
  ls-type:: annotation
  hl-page:: 795
  hl-color:: yellow
  id:: 63d4de3f-51a8-46eb-a132-d9331de70a0b
- 都可以使用 IDBIndex 对象的下列属性取得索引的相关信息
  ls-type:: annotation
  hl-page:: 795
  hl-color:: yellow
  id:: 63d4de51-37de-411f-9677-6f8b83294546
- 对象存储自身也有一个 indexNames 属性，保存着与之相关索引的名称
  ls-type:: annotation
  hl-page:: 795
  hl-color:: yellow
  id:: 63d4df2a-884a-40d4-a986-05565f6897ef
- 删除索引不会影响对象存储中的数据，所以这个操作没有回调
  ls-type:: annotation
  hl-page:: 795
  hl-color:: yellow
  id:: 63d4df71-6bec-4d57-9a7d-6b2927f2ac01
- 并发问题
  ls-type:: annotation
  hl-page:: 795
  hl-color:: green
  id:: 63d4df78-c42c-4fc0-9623-0ef09b203ea8
- 有可能出现一个网页尝试升级数据库而另一个尚未就绪的情形
  ls-type:: annotation
  hl-page:: 796
  hl-color:: yellow
  id:: 63d4dfbe-fe9d-4342-b84a-a90827a5966d
- 第一次打开数据库时，添加 onversionchange 事件处理程序非常重要
  ls-type:: annotation
  hl-page:: 796
  hl-color:: yellow
  id:: 63d4dfc5-395b-48dd-8803-cd9efdb37fde
- 应该在每次成功打开数据库后都指定 onversionchange 事件处理程序。记住，onversionchange有可能会被其他标签页触发
  ls-type:: annotation
  hl-page:: 796
  hl-color:: yellow
  id:: 63d4dfde-afc3-4f2f-8a9f-e3642fd2b50c
- 限制
  ls-type:: annotation
  hl-page:: 796
  hl-color:: green
  id:: 63d4dfe3-f712-4183-ad52-7877b7e86221
- IndexedDB 数据库是与页面源（协议、域和端口）绑定的，因此信息不能跨域共享
  ls-type:: annotation
  hl-page:: 796
  hl-color:: yellow
  id:: 63d4e17a-5941-48c3-8b45-c82ef9e6bcee
- 因为 JavaScript 是异步加载的解释型语言，所以得到广泛应用的各种模块实现也表现出不同的形态
  ls-type:: annotation
  hl-page:: 797
  hl-color:: yellow
  id:: 63d4e1ba-2a0a-49ac-9bc5-4446de625724
- 理解模块模式
  ls-type:: annotation
  hl-page:: 797
  hl-color:: green
  id:: 63d4e1bd-ed49-4519-b1fc-d2dbb8b347fa
- 模块标识符
  ls-type:: annotation
  hl-page:: 797
  hl-color:: green
  id:: 63d4e1dd-f674-4f23-96d1-40126ca3e3e6
- 模块系统本质上是键/值实体，其中每个模块都有个可用于引用它的标识符
  ls-type:: annotation
  hl-page:: 797
  hl-color:: yellow
  id:: 63d4e251-b69f-4600-b87d-9c149fdc3d96
- 系统中的任何模块都应该能够无歧义地引用其他模块
  ls-type:: annotation
  hl-page:: 797
  hl-color:: yellow
  id:: 63d4e2c7-4501-4f44-8c2f-9d890045f2a3
- 模块依赖
  ls-type:: annotation
  hl-page:: 798
  hl-color:: green
  id:: 63d4e2d5-b156-4185-90d4-ab885c9ba0ba
- 每个模块都会与某个唯一的标识符关联，该标识符可用于检索模块。
  ls-type:: annotation
  hl-page:: 798
  hl-color:: yellow
  id:: 63d4e2e9-0bf8-411a-9d3f-14e505d042fd
- 模块加载
  ls-type:: annotation
  hl-page:: 798
  hl-color:: green
  id:: 63d4e2ee-a450-4b1d-bb9a-be19e971f9bf
- 当一个外部模块被指定为依赖时，本地模块期望在执行它时，依赖已准备好并已初始化。
  ls-type:: annotation
  hl-page:: 798
  hl-color:: yellow
  id:: 63d4e354-99dc-4b7f-8e04-523fe32c8d72
- 入口
  ls-type:: annotation
  hl-page:: 798
  hl-color:: green
  id:: 63d4e35d-9c3f-4edf-867f-6a25c4d0b672
- 相互依赖的模块必须指定一个模块作为入口（entry point），这也是代码执行的起点
  ls-type:: annotation
  hl-page:: 798
  hl-color:: yellow
  id:: 63d4e369-2b61-45db-8f92-a2cb21b1370b
- 模块化 JavaScript 应用程序的所有模块会构成依赖图
  ls-type:: annotation
  hl-page:: 798
  hl-color:: yellow
  id:: 63d4e3e4-c7ff-42c3-916f-8f15aef34d07
- 模块加载是“阻塞的”，这意味着前置操作必须完成才能执行后续操作
  ls-type:: annotation
  hl-page:: 799
  hl-color:: yellow
  id:: 63d4e400-bc37-4071-974e-b4dd074c6d5a
- 异步依赖
  ls-type:: annotation
  hl-page:: 799
  hl-color:: green
  id:: 63d4e40a-3aa6-437e-94ab-a58832876571
- 如果重写前面的应用程序，只使用动态模块加载，那么使用一个<script>标签即可完成模块 A 的加载
  ls-type:: annotation
  hl-page:: 799
  hl-color:: yellow
  id:: 63d4e4b4-e25e-419f-a5da-0dd0c5b6482e
- 动态依赖
  ls-type:: annotation
  hl-page:: 799
  hl-color:: green
  id:: 63d4e4b6-a538-47ac-80c1-75814a3bd966
- 动态添加的依赖有别于模块开头列出的常规依赖，这些依赖必须在模块执行前加载完毕
  ls-type:: annotation
  hl-page:: 799
  hl-color:: yellow
  id:: 63d4e4d2-a7dd-4c5d-8956-a21a5eeab89e
- 静态分析
  ls-type:: annotation
  hl-page:: 799
  hl-color:: green
  id:: 63d4e4e0-5219-49ca-95d3-2814f69a4d63
- 更复杂的模块行为，例如动态依赖，会导致静态分析更困难。
  ls-type:: annotation
  hl-page:: 800
  hl-color:: yellow
  id:: 63d4e4f8-8516-45ef-b395-cbe7763386a1
- 循环依赖
  ls-type:: annotation
  hl-page:: 800
  hl-color:: green
  id:: 63d4e4fe-ef46-4667-b778-92d2b8254da0
- 要构建一个没有循环依赖的 JavaScript 应用程序几乎是不可能的
  ls-type:: annotation
  hl-page:: 800
  hl-color:: yellow
  id:: 63d4e6b8-9973-4041-90a6-27df2784075d
- 凑合的模块系统
  ls-type:: annotation
  hl-page:: 801
  hl-color:: green
  id:: 63d4e6e8-284a-4e58-90be-fcb1ad3fcfc2
- 如果把这个模块的返回值赋给一个变量，那么实际上就为模块创建了命名空间
  ls-type:: annotation
  hl-page:: 802
  hl-color:: yellow
  id:: 63d4e703-53a7-4c09-b4bc-4cad97821e50
- 模块定义是立即执行的
  ls-type:: annotation
  hl-page:: 801
  hl-color:: yellow
  id:: 63d4e74e-5f03-46ed-89ba-424e7b7c4f96
- 为了暴露公共 API，模块 IIFE 会返回一个对象，其属性就是模块命名空间中的公共成员
  ls-type:: annotation
  hl-page:: 802
  hl-color:: yellow
  id:: 63d4e7a7-a494-4387-b7ac-a08712f46125
- 泄露模块模式”（revealing module pattern）
  ls-type:: annotation
  hl-page:: 802
  hl-color:: yellow
  id:: 63d4e7d3-b2c1-4b2a-b3a6-3f668e30aeb8
- 返回一个对象，其属性是私有数据和成员的引用
  ls-type:: annotation
  hl-page:: 802
  hl-color:: yellow
  id:: 63d4e7eb-1415-495d-9330-0fce6293f39a
- 在模块内部也可以定义模块，这样可以实现命名空间嵌套
  ls-type:: annotation
  hl-page:: 802
  hl-color:: yellow
  id:: 63d4e85a-f2ba-4100-b8dc-27a366a983a2
- 使用函数作用域和立即调用函数表达式（IIFE，Immediately Invoked Function Expression）将模块定义封装在匿名闭包中
  ls-type:: annotation
  hl-page:: 801
  hl-color:: yellow
  id:: 63d4e879-32b6-41a7-8ec3-bf9f687341d0
- 为了让模块正确使用外部的值，可以将它们作为参数传给 IIFE
  ls-type:: annotation
  hl-page:: 803
  hl-color:: yellow
  id:: 63d4e8bc-0cda-4e7b-b36d-5ddbf2cb4712
- 因为这里的模块实现其实就是在创建 JavaScript 对象的实例，所以完全可以在定义之后再扩展模块
  ls-type:: annotation
  hl-page:: 803
  hl-color:: yellow
  id:: 63d4e973-6236-4ee9-8672-8163cd6efd6f
- 无论模块是否存在，配置模块扩展以执行扩展也很有用
  ls-type:: annotation
  hl-page:: 803
  hl-color:: yellow
  id:: 63d4ea09-e1db-44ce-98bc-70c71c8229dd
- 使用 ES6 之前的模块加载器
  ls-type:: annotation
  hl-page:: 804
  hl-color:: green
  id:: 63d4ea1f-6057-41e2-bcbb-327ccf5a9543
- CommonJS
  ls-type:: annotation
  hl-page:: 804
  hl-color:: green
  id:: 63d4eaf9-b075-4042-aeb5-fc8ed59a51b4
- CommonJS 规范概述了同步声明依赖的模块定义
  ls-type:: annotation
  hl-page:: 804
  hl-color:: yellow
  id:: 63d4eb05-3090-4999-9810-a7ca8e03ebe7
- CommonJS 模块定义需要使用 require()指定依赖，而使用 exports 对象定义自己的公共 API
  ls-type:: annotation
  hl-page:: 804
  hl-color:: yellow
  id:: 63d4eb77-6089-423d-83b6-1539158ad229
- 无论一个模块在 require()中被引用多少次，模块永远是单例
  ls-type:: annotation
  hl-page:: 804
  hl-color:: yellow
  id:: 63d4ebbe-4440-4fe4-b9a4-a337a1f8fe10
- 在 CommonJS 中，模块加载是模块系统执行的同步操作
  ls-type:: annotation
  hl-page:: 805
  hl-color:: yellow
  id:: 63d4ebe6-8d7c-470b-8b9b-1fe0ee882777
- 不过，所有 CommonJS 风格的实现共同之处是模块不会指定自己的标识符，它们的标识符由其在模块文件层级中的位置决定。
  ls-type:: annotation
  hl-page:: 805
  hl-color:: yellow
  id:: 63d4ec62-808e-4734-bf4c-b1b35359c7be
- module.exports 对象非常灵活，有多种使用方式。
  ls-type:: annotation
  hl-page:: 805
  hl-color:: yellow
  id:: 63d4ecce-6b50-42f6-92fd-702b13492c8d
- 模块的一个主要用途是托管类定义（这里使用 ES6 风格的类定义，不过 ES5 风格也兼容）：
  ls-type:: annotation
  hl-page:: 806
  hl-color:: yellow
  id:: 63d4ecfb-7521-46fc-9903-97d4473720bb
- CommonJS 依赖几个全局属性如 require 和 module.exports
  ls-type:: annotation
  hl-page:: 806
  hl-color:: yellow
  id:: 63d4ed16-1129-4025-8cbe-14ce1a7bb050
- 异步模块定义
  ls-type:: annotation
  hl-page:: 806
  hl-color:: green
  id:: 63d4ed29-2bd0-4cc3-b7cc-920c672dc268
- 异步模块定义（AMD， Asynchronous Module Definition）的模块定义系统则以浏览器为目标执行环境，这需要考虑网络延迟的问题
  ls-type:: annotation
  hl-page:: 806
  hl-color:: yellow
  id:: 63d4ed44-cd24-47fc-9255-ff219c577015
- 让模块声明自己的依赖，而运行在浏览器中的模块系统会按需获取依赖，并在依赖加载完成后立即执行依赖它们的模块
  ls-type:: annotation
  hl-page:: 806
  hl-color:: yellow
  id:: 63d4ed50-c656-490e-86ef-ca457b21d59f
- AMD 模块实现的核心是用函数包装模块定义
  ls-type:: annotation
  hl-page:: 806
  hl-color:: yellow
  id:: 63d4ed7f-9742-40d9-8415-cc5dd27841ee
- 防止声明全局变量
  ls-type:: annotation
  hl-page:: 806
  hl-color:: yellow
  id:: 63d4ed89-0011-42a1-8ae9-fb8eb9277e7c
- 允许加载器库控制何时加载模块
  ls-type:: annotation
  hl-page:: 806
  hl-color:: yellow
  id:: 63d4ed8f-a075-4258-8c31-0199eae7f582
- 便于模块代码的移植
  ls-type:: annotation
  hl-page:: 806
  hl-color:: yellow
  id:: 63d4ed9d-e539-4bcd-a358-43b0d1038112
- 通用模块定义
  ls-type:: annotation
  hl-page:: 807
  hl-color:: green
  id:: 63d4ee07-3197-4e4d-8754-be627955c7a0
- 通用模块定义（UMD，Universal Module Definition
  ls-type:: annotation
  hl-page:: 807
  hl-color:: yellow
  id:: 63d4ee15-c684-477f-ada1-bf64dd24751d
- 本质上，UMD 定义的模块会在启动时检测要使用哪个模块系统，然后进行适当配置，并把所有逻辑包装在一个立即调用的函数表达式（IIFE）中。
  ls-type:: annotation
  hl-page:: 807
  hl-color:: yellow
  id:: 63d4ee55-7b44-42b8-abb9-29b77a71c40e
- module.exports = factory(require(' moduleB '));
  ls-type:: annotation
  hl-page:: 807
  hl-color:: yellow
  id:: 63d4ee7c-e4fa-4ac0-9d39-c9d9bb56e8c1
- 模块加载器终将没落
  ls-type:: annotation
  hl-page:: 807
  hl-color:: green
  id:: 63d4ee9d-f44e-46da-bf73-f1b78bf0088d
- 使用 ES6 模块
  ls-type:: annotation
  hl-page:: 808
  hl-color:: green
  id:: 63d4eea6-e754-4804-bd16-497f39d55b7d
- 原生浏览器支持意味着加载器及其他预处理都不再必要
  ls-type:: annotation
  hl-page:: 808
  hl-color:: yellow
  id:: 63d4eec4-9062-49f2-9e84-cf046a4c1c04
- 模块标签及定义
  ls-type:: annotation
  hl-page:: 808
  hl-color:: green
  id:: 63d4eeca-6b4a-4894-a9ab-400f37dff5cf
- 带有 type="module"属性的<script>标签会告诉浏览器相关代码应该作为模块执行，而不是作为传统的脚本执行
  ls-type:: annotation
  hl-page:: 808
  hl-color:: yellow
  id:: 63d4ef01-81b3-4fff-acc3-e20bbe1b01a6
- 解析到<script type="module">标签后会立即下载模块文件，但执行会延迟到文档解析完成
  ls-type:: annotation
  hl-page:: 808
  hl-color:: yellow
  id:: 63d4ef33-ea63-446c-9a08-cfea50ca238a
- 也可以给模块标签添加 async 属性
  ls-type:: annotation
  hl-page:: 808
  hl-color:: yellow
  id:: 63d4ef75-e666-4f54-a0f1-f0947e3aa50a
- 不仅模块执行顺序不再与<script>标签在页面中的顺序绑定
  ls-type:: annotation
  hl-page:: 808
  hl-color:: yellow
  id:: 63d4ef7e-ed28-49cf-ba37-59fbb4169c9b
- 模块也不会等待文档完成解析才执行
  ls-type:: annotation
  hl-page:: 808
  hl-color:: yellow
  id:: 63d4ef89-daf8-4c62-966b-d47e67d091a3
- 模块加载
  ls-type:: annotation
  hl-page:: 809
  hl-color:: green
  id:: 63d4efa7-d5af-4a28-a037-870b7c9ddc57
- 模块文件按需加载，且后续模块的请求会因为每个依赖模块的网络延迟而同步延迟
  ls-type:: annotation
  hl-page:: 809
  hl-color:: yellow
  id:: 63d4efd1-468c-4103-b99a-b1067b034826
- 模块行为
  ls-type:: annotation
  hl-page:: 809
  hl-color:: green
  id:: 63d4efec-7b60-4321-9c08-0ba5b0651fbc
- 模块导出
  ls-type:: annotation
  hl-page:: 810
  hl-color:: green
  id:: 63d4f024-b014-4830-a069-01dc26db88e3
- 。ES6 模块支持两种导出：命名导出和默认导出
  ls-type:: annotation
  hl-page:: 810
  hl-color:: yellow
  id:: 63d4f03e-c100-4f7b-a2bc-339944bdc31d
- 因此 export 语句与导出值的相对位置或者 export 关键字在模块中出现的顺序没有限制
  ls-type:: annotation
  hl-page:: 810
  hl-color:: yellow
  id:: 63d4f081-146a-4832-a350-a550fd30eff1
- export 关键字用于声明一个值为命名导出。
  ls-type:: annotation
  hl-page:: 810
  hl-color:: yellow
  id:: 63d4f0af-cba5-46fb-9eba-efc301bb99d5
- 命名导出（named export）就好像模块是被导出值的容器。
  ls-type:: annotation
  hl-page:: 810
  hl-color:: yellow
  id:: 63d4f0dd-cc10-416b-8e83-da4c5dc1a5f7
- 因为 ES6 命名导出可以将模块作为容器，所以可以在一个模块中声明多个命名导出。
  ls-type:: annotation
  hl-page:: 810
  hl-color:: yellow
  id:: 63d4f14d-8073-46d2-847a-78e02399e83c
- 考虑到导出多个值是常见的操作，ES6 模块也支持对导出声明分组，可以同时为部分或全部导出值指定别名
  ls-type:: annotation
  hl-page:: 811
  hl-color:: yellow
  id:: 63d4f17f-2a4f-4c7a-97b0-678c2e026900
- 默认导出（default export）就好像模块与被导出的值是一回事。
  ls-type:: annotation
  hl-page:: 811
  hl-color:: yellow
  id:: 63d4f1a2-7c95-4c33-bedc-1aaf43b2de98
- 每个模块只能有一个默认导出
  ls-type:: annotation
  hl-page:: 811
  hl-color:: yellow
  id:: 63d4f1b4-0ea3-4696-bff0-2ad0161781c7
- 因为命名导出和默认导出不会冲突，所以 ES6 支持在一个模块中同时定义这两种导出
  ls-type:: annotation
  hl-page:: 811
  hl-color:: yellow
  id:: 63d4f1e3-d426-4f8e-9994-21a55a95a513
- 导出时也可以提供别名，别名必须在 export 子句的大括号语法中指定。
  ls-type:: annotation
  hl-page:: 810
  hl-color:: yellow
  id:: 63d4f21d-2212-40b1-8841-6bcd0603335d
- 意，有的形式使用了分号，有的则没有
  ls-type:: annotation
  hl-page:: 811
  hl-color:: yellow
  id:: 63d4f270-893e-4cbc-842c-c9ca71f64bbb
- 模块导入
  ls-type:: annotation
  hl-page:: 812
  hl-color:: green
  id:: 63d4f277-71b5-4ca2-9028-c479f1b61c76
- 模块可以通过使用 import 关键字使用其他模块导出的值。
  ls-type:: annotation
  hl-page:: 812
  hl-color:: yellow
  id:: 63d4f2b2-8379-4e9d-ba00-ef4d28ca29fc
- import 语句被提升到模块顶部。
  ls-type:: annotation
  hl-page:: 812
  hl-color:: yellow
  id:: 63d4f2c0-fe4d-4de9-8abf-a54d60ba656e
- 模块标识符可以是相对于当前模块的相对路径，也可以是指向模块文件的绝对路径。
  ls-type:: annotation
  hl-page:: 812
  hl-color:: yellow
  id:: 63d4f2cf-ec4f-46b8-8cc0-f7054a865ac5
- 命名导出和默认导出的区别也反映在它们的导入上。命名导出可以使用*批量获取并赋值给保存导出集合的别名，而无须列出每个标识符：
  ls-type:: annotation
  hl-page:: 813
  hl-color:: yellow
  id:: 63d4f3bf-3719-4933-84a4-1c640d08491d
- 默认导出就好像整个模块就是导出的值一样。可以使用 default 关键字并提供别名来导入
  ls-type:: annotation
  hl-page:: 813
  hl-color:: yellow
  id:: 63d4f3d6-7a0d-4fef-bd6a-daef9cdcb05d
- 模块转移导出
  ls-type:: annotation
  hl-page:: 814
  hl-color:: green
  id:: 63d4f3ea-6ec2-4aad-8fed-0132c846cb01
- 工作者模块
  ls-type:: annotation
  hl-page:: 814
  hl-color:: green
  id:: 63d4fffe-7dca-4ee1-9a89-3f50746d67c9
- 模块导入的值可以直接通过管道转移到导出
  ls-type:: annotation
  hl-page:: 814
  hl-color:: yellow
  id:: 63d5004a-5c8c-4de9-88a0-435d640ee0ef
- foo.js 中的所有命名导出都会出现在导入 bar.js 的模块中
  ls-type:: annotation
  hl-page:: 814
  hl-color:: yellow
  id:: 63d5005c-2a3c-4738-b5a3-e236fe7c1354
- 如果想把一个模块的所有命名导出集中在一块，可以像下面这样在 bar.js 中使用*导出
  ls-type:: annotation
  hl-page:: 814
  hl-color:: yellow
  id:: 63d50071-a25d-45ec-aae0-162502d5d5d9
- 向后兼容
  ls-type:: annotation
  hl-page:: 815
  hl-color:: green
  id:: 63d5011e-553b-45f5-9a7a-d63af6733126
- 对于想要尽可能在浏览器中原生使用 ECMAScript 6 模块的用户，可以提供两个版本的代码：基于模块的版本与基于脚本的版本。
  ls-type:: annotation
  hl-page:: 815
  hl-color:: yellow
  id:: 63d50133-184e-4430-ba3a-878b35c33913
- 浏览器在遇到<script>标签上无法识别的 type 属性时会拒绝执行其内容
  ls-type:: annotation
  hl-page:: 815
  hl-color:: yellow
  id:: 63d50142-b13e-4fca-975c-86ab7d727d0b
- 工作者线程简介
  ls-type:: annotation
  hl-page:: 816
  hl-color:: green
  id:: 63d50176-05b4-464c-990f-0c2e1bc29698
- 工作者线程与线程
  ls-type:: annotation
  hl-page:: 816
  hl-color:: green
  id:: 63d502e6-ed02-43a9-9071-17c26dae1317
- 使用工作者线程，浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境。
  ls-type:: annotation
  hl-page:: 816
  hl-color:: yellow
  id:: 63d5030e-a9a6-489c-a283-aa3fd7b81d35
- 子环境不能与依赖单线程交互的 API（如 DOM）互操作，但可以与父环境并行执行代码
  ls-type:: annotation
  hl-page:: 816
  hl-color:: yellow
  id:: 63d5031b-0771-4249-8ab1-d17bbacd7745
- 工作者线程的类型
  ls-type:: annotation
  hl-page:: 817
  hl-color:: green
  id:: 63d503bd-6b84-4785-b8d5-70325c9b7390
- WorkerGlobalScope
  ls-type:: annotation
  hl-page:: 818
  hl-color:: green
  id:: 63d5042a-ebf4-4e19-812a-12383bbfae8d
- 专用工作者线程
  ls-type:: annotation
  hl-page:: 818
  hl-color:: green
  id:: 63d50455-0868-481c-bb14-774599386e0a
- 这样的线程可以与父页面交换信息、发送网络请求、执行文件输入/输出、进行密集计算、处理大量数据，以及实现其他不适合在页面执行线程里做的任务（否则会导致页面响应迟钝）
  ls-type:: annotation
  hl-page:: 818
  hl-color:: yellow
  id:: 63d50467-3b8c-4816-bf37-48cb7c739ace
- 专用工作者线程的基本概念
  ls-type:: annotation
  hl-page:: 819
  hl-color:: green
  id:: 63d5046c-1e72-4ab0-b525-780eb0134cbf
- 把文件路径提供给 Worker 构造函数，然后构造函数再在后台异步加载脚本并实例化工作者线程
  ls-type:: annotation
  hl-page:: 819
  hl-color:: yellow
  id:: 63d50486-d0c8-4efb-8356-3ecf6087f600
- 工作者线程的脚本文件只能从与父页面相同的源加载
  ls-type:: annotation
  hl-page:: 819
  hl-color:: yellow
  id:: 63d5049a-b07f-4cd1-838b-948ded5063c3
- Worker()构造函数返回的 Worker 对象是与刚创建的专用工作者线程通信的连接点
  ls-type:: annotation
  hl-page:: 820
  hl-color:: yellow
  id:: 63d504e0-b0ce-487e-a7d9-b5a93af99376
- 在专用工作者线程内部，全局作用域是 DedicatedWorkerGlobalScope 的实例。因为这继承自 WorkerGlobalScope，所以包含它的所有属性和方法
  ls-type:: annotation
  hl-page:: 820
  hl-color:: yellow
  id:: 63d50512-7720-41d8-bde5-50e851302cae
- 可维护性
  ls-type:: annotation
  hl-page:: 867
  hl-color:: green
  id:: 63d50527-8e74-4591-8000-314d852ba0f9
- 性能
  ls-type:: annotation
  hl-page:: 876
  hl-color:: green
  id:: 63d50911-f98f-4ac1-940c-9db3deecf074