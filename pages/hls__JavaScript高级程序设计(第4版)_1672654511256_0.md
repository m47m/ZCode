file:: [JavaScript高级程序设计(第4版)_1672654511256_0.pdf](../assets/JavaScript高级程序设计(第4版)_1672654511256_0.pdf)
file-path:: ../assets/JavaScript高级程序设计(第4版)_1672654511256_0.pdf

- Web 浏览器只是 ECMAScript 实现可能存在的一种宿主环境（host environment）
  ls-type:: annotation
  hl-page:: 27
  hl-color:: yellow
  id:: 63b2b207-d821-4358-9f2c-1a21abc9405a
- ECMAScript，即 ECMA-262 定义的语言
  ls-type:: annotation
  hl-page:: 27
  hl-color:: yellow
  id:: 63b2b220-be98-47f6-a69b-2d5681ef2791
- 第 4 版包括强类型变量、新语句和数据结构、真正的类和经典的继承，以及操作数据的新手段。
  ls-type:: annotation
  hl-page:: 28
  hl-color:: yellow
  id:: 63b2b27d-1381-4bc0-9bb7-3012b6aa3b7f
- 原生的解析和序列化 JSON 数据的 JSON 对象、方便继承和高级属性定义的方法，以及新的增强 ECMAScript 引擎解释和执行代码能力的严格模式
  ls-type:: annotation
  hl-page:: 28
  hl-color:: yellow
  id:: 63b2b293-3f7c-4ee4-8905-3342f73d2b4a
- ES6 正式支持了类、模块、迭代器、生成器、箭头函数、期约、反射、代理和众多新的数据类型。
  ls-type:: annotation
  hl-page:: 28
  hl-color:: yellow
  id:: 63b2b2a7-49e4-49a5-9324-1925efcb0a23
- 增加了异步函数（async/ await）、SharedArrayBuffer 及 Atomics API，以及 Object.values()/Object.entries()/Object. getOwnPropertyDescriptors()和字符串填充方法，另外明确支持对象字面量最后的逗号
  ls-type:: annotation
  hl-page:: 29
  hl-color:: yellow
  id:: 63b2b2ce-c93e-4bf2-bd73-6f10128c3291
- 包括异步迭代、剩余和扩展属性、一组新的正则表达式特性、Promise finally()，以及模板字面量修订
  ls-type:: annotation
  hl-page:: 29
  hl-color:: yellow
  id:: 63b2b2de-2166-4887-a3a6-b6d81dc479b9
- 万维网联盟（W3C，World Wide Web Consortium）开始了制定 DOM 标准的进程
  ls-type:: annotation
  hl-page:: 31
  hl-color:: yellow
  id:: 63b2b3d6-9917-43f7-9ee7-7f8392a46259
- 对（DHTML 早就支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM 节点的方法）的支持，而且通过对象接口支持了层叠样式表（CSS）
  ls-type:: annotation
  hl-page:: 32
  hl-color:: yellow
  id:: 63b2b44b-fd8f-48f0-b372-2abcbe6b9554
- DOM Level 2 
  ls-type:: annotation
  hl-page:: 32
  hl-color:: yellow
  id:: 63b2b484-97f7-4a8b-b4c6-6880f7b695e4
- DOM Level 3 
  ls-type:: annotation
  hl-page:: 32
  hl-color:: yellow
  id:: 63b2b4bc-1173-42da-9698-9ae87a9a792e
- JavaScript 是一门用来与网页交互的脚本语言
  ls-type:: annotation
  hl-page:: 35
  hl-color:: yellow
  id:: 63b2b58a-4c56-4694-9957-a327e17f4a46
- <script>元素
  ls-type:: annotation
  hl-page:: 36
  hl-color:: yellow
  id:: 63b2b5b6-7baf-469b-8940-ba9e1feeb5c8
- <script>元素有下列 8 个属性。
  ls-type:: annotation
  hl-page:: 36
  hl-color:: yellow
  id:: 63b2b632-3923-406f-bc11-55d8bef81d2f
- 值是 module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字
  ls-type:: annotation
  hl-page:: 37
  hl-color:: yellow
  id:: 63b2b807-b7a9-4cee-9ae8-21fa39d50bf7
- 在网页中嵌入 JavaScript 代码
  ls-type:: annotation
  hl-page:: 37
  hl-color:: yellow
  id:: 63b2b848-1988-4c32-898c-f89dcc2d7705
- 在网页中包含外部 JavaScript 文件
  ls-type:: annotation
  hl-page:: 37
  hl-color:: yellow
  id:: 63b2b852-0d55-451f-90c1-664c6c8d3b89
- 在<script>元素中的代码被计算完成之前，页面的其余内容不会被加载，也不会被显示。
  ls-type:: annotation
  hl-page:: 37
  hl-color:: yellow
  id:: 63b2b882-4075-4556-8e7e-c0b775e7fce4
- 第二个<script>元素的代码必须在第一个<script>元素的代码解释完毕才能开始解释
  ls-type:: annotation
  hl-page:: 38
  hl-color:: yellow
  id:: 63b2b945-51a9-4d19-83ea-b59de7a0419e
- 异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded（参见第 17 章）之前或之后
  ls-type:: annotation
  hl-page:: 40
  hl-color:: yellow
  id:: 63b2baa2-90fc-4cc9-a5ce-fd06e5e8b8a8
- CDATA 块表示文档中可以包含任意文本的区块，其内容不作为标签来解析
  ls-type:: annotation
  hl-page:: 41
  hl-color:: yellow
  id:: 63b2bce3-96e7-428a-88d8-e466c155377e
- 行内代码与外部文件
  ls-type:: annotation
  hl-page:: 43
  hl-color:: yellow
  id:: 63b2be3b-1da2-4deb-9e8d-caa480fc8785
- 文档模式
  ls-type:: annotation
  hl-page:: 43
  hl-color:: yellow
  id:: 63b2beaf-d402-4c5d-af7d-b81224b2baa6
- <noscript>元素
  ls-type:: annotation
  hl-page:: 44
  hl-color:: yellow
  id:: 63b2bfb2-2199-4581-89bd-f3576abbcc2e
- 小结
  ls-type:: annotation
  hl-page:: 45
  hl-color:: yellow
  id:: 63b2c01d-5344-40be-8f93-efdd431c2850
- 语法
  ls-type:: annotation
  hl-page:: 46
  hl-color:: yellow
  id:: 63b2c02e-5e10-4c6e-bbcc-09781f20d1c8
- 第一个字符必须是一个字母、下划线（_）或美元符号（$
  ls-type:: annotation
  hl-page:: 46
  hl-color:: yellow
  id:: 63b2c143-f380-449a-9d14-1d0111652505
- 剩下的其他字符可以是字母、下划线、美元符号或数字。
  ls-type:: annotation
  hl-page:: 46
  hl-color:: yellow
  id:: 63b2c14b-cdcd-4d85-8bfc-25c5c35f5344
- 字母可以是扩展 ASCII（Extended ASCII）中的字母，也可以是 Unicode 的字母字符
  ls-type:: annotation
  hl-page:: 46
  hl-color:: yellow
  id:: 63b2c159-be86-44a0-81fa-3335a79dad4c
- 关键字与保留字
  ls-type:: annotation
  hl-page:: 48
  hl-color:: yellow
  id:: 63b2c224-ee25-4295-924d-681baeab0bfc
- 变量
  ls-type:: annotation
  hl-page:: 49
  hl-color:: yellow
  id:: 63b2c2af-586d-48d9-b557-ea2945eeb0df
- 不初始化的情况下，变量会保存一个特殊值 undefined
  ls-type:: annotation
  hl-page:: 49
  hl-color:: yellow
  id:: 63b2c6b3-a8e4-43ef-955c-47b90da7a251
- 去掉之前的 var 操作符之后，message 就变成了全局变量
  ls-type:: annotation
  hl-page:: 49
  hl-color:: yellow
  id:: 63b2c71d-72b8-4d0d-9bed-480fb3a1298b
- 在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 ReferenceError
  ls-type:: annotation
  hl-page:: 50
  hl-color:: yellow
  id:: 63b2c780-7808-4dca-b890-89f48372508d
- 暂时性死区
  ls-type:: annotation
  hl-page:: 51
  hl-color:: yellow
  id:: 63b2ca8d-2353-42a7-bc7c-37a67271640d
- 在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone）
  ls-type:: annotation
  hl-page:: 51
  hl-color:: yellow
  id:: 63b2caeb-3bf4-449b-9dc1-d86bf9e74a59
- 全局声明
  ls-type:: annotation
  hl-page:: 52
  hl-color:: yellow
  id:: 63b2cb48-0aa3-4639-9713-5c741bdbefb8
- 使用 let 在全局作用域中声明的变量不会成为 window 对象的属性
  ls-type:: annotation
  hl-page:: 52
  hl-color:: yellow
  id:: 63b2cb56-8354-47b0-8489-541496027a2d
- 条件声明
  ls-type:: annotation
  hl-page:: 52
  hl-color:: yellow
  id:: 63b2cba1-1a8f-4b1d-91d4-500e2e1b8ca6
- let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它
  ls-type:: annotation
  hl-page:: 52
  hl-color:: yellow
  id:: 63b2cbf9-c5a8-49ff-b3ab-65f72bda1b55
- 使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量
  ls-type:: annotation
  hl-page:: 53
  hl-color:: yellow
  id:: 63b2cc82-b07e-45c4-bddd-e57dc456e8fa
- 数据类型
  ls-type:: annotation
  hl-page:: 55
  hl-color:: yellow
  id:: 63b2ce0b-773e-47c9-9a8d-06723ccd57f5
- 包含 undefined 值的变量跟未定义变量是有区别的
  ls-type:: annotation
  hl-page:: 56
  hl-color:: yellow
  id:: 63b2d02b-ee53-4807-908d-42401e383cc3
- undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等
  ls-type:: annotation
  hl-page:: 57
  hl-color:: yellow
  id:: 63b2d116-477f-467a-98c9-73c1f5b063b9
- 将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数
  ls-type:: annotation
  hl-page:: 58
  hl-color:: yellow
  id:: 63b2d164-21ec-463d-b49b-016d43a404de
- 存储浮点值使用的内存空间是存储整数值的两倍
  ls-type:: annotation
  hl-page:: 59
  hl-color:: yellow
  id:: 63b2d236-e39f-4878-ba54-b165e432fc5d
- 在小数点后面没有数字的情况下，数值就会变成整数
  ls-type:: annotation
  hl-page:: 59
  hl-color:: yellow
  id:: 63b2d240-d46f-4644-9efc-382194f42961
- 默认情况下，ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法
  ls-type:: annotation
  hl-page:: 59
  hl-color:: yellow
  id:: 63b2d2a8-dd78-4795-adef-a467920361f3
- 如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值
  ls-type:: annotation
  hl-page:: 60
  hl-color:: yellow
  id:: 63b2d380-b580-4176-b70b-81ad8a00b250
- 要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用 isFinite()函数
  ls-type:: annotation
  hl-page:: 60
  hl-color:: yellow
  id:: 63b2d39a-d584-45bc-bbbb-542e8b30fbea
- 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。
  ls-type:: annotation
  hl-page:: 61
  hl-color:: yellow
  id:: 63b2d5a3-1649-4e5b-8bc4-145523e4dc59
- 专注于字符串是否包含数值模式
  ls-type:: annotation
  hl-page:: 62
  hl-color:: yellow
  id:: 63b2d5bc-6200-4bab-a417-0f0c59494ebb
- 如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN
  ls-type:: annotation
  hl-page:: 62
  hl-color:: yellow
  id:: 63b2d6c1-19cc-49fd-bb17-07aca65763c0
- 如果你不确定一个值是不是 null 或 undefined，可以使用 String()转型函数，它始终会返回表示相应类型值的字符串
  ls-type:: annotation
  hl-page:: 65
  hl-color:: yellow
  id:: 63b2d858-d53a-4a08-a2ca-b840bd80b9c8
- 模板字面量会保持反引号内部的空格
  ls-type:: annotation
  hl-page:: 66
  hl-color:: yellow
  id:: 63b2d8f4-e69e-4943-ba74-0f539beb636e
- 技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式
  ls-type:: annotation
  hl-page:: 66
  hl-color:: yellow
  id:: 63b2d922-fdd9-46d5-8692-ca070c5df4c5
- 直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示
  ls-type:: annotation
  hl-page:: 68
  hl-color:: yellow
  id:: 63b2dac7-5456-4a3b-a568-4cbe18d9b5d1
- 即字符串数组的.raw 属性取得每个字符串的原始内容
  ls-type:: annotation
  hl-page:: 69
  hl-color:: yellow
  id:: 63b2db65-ce96-4e92-a064-93f2a78c0db2
- 符号需要使用 Symbol()函数初始化
  ls-type:: annotation
  hl-page:: 69
  hl-color:: yellow
  id:: 63b2dba6-e1d5-4e16-b16e-506020667547
- 可以传入一个字符串参数作为对符号的描述（description）
  ls-type:: annotation
  hl-page:: 69
  hl-color:: yellow
  id:: 63b2dbc5-4267-4217-9b93-f2286abbf272
- Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dbfb-4f18-48fe-a535-fdd9adcea9af
- 使用全局符号注册表
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dc64-6d9d-4cec-997e-26fc9331f535
- 字符串键都执行幂等操作
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dc7f-b846-4f2e-9258-701ff3d23e95
- 发现存在与该字符串对应的符号，然后就会返回该符号实例
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dc92-fba9-44fe-af62-ddfc416dfb87
- 即使采用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol()定义的符号也并不等同：
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dca3-cc8a-472e-9930-9e815badfcc1
- 作为参数传给 Symbol.for()的任何值都会被
  ls-type:: annotation
  hl-page:: 70
  hl-color:: yellow
  id:: 63b2dcb5-a383-4d3e-b0b2-c3e4bfc7a0c0
- 转换为字符串
  ls-type:: annotation
  hl-page:: 71
  hl-color:: yellow
  id:: 63b2dcb7-e0ac-49b2-9cf1-f8ce05cbf2f6
- 使用符号作为属性
  ls-type:: annotation
  hl-page:: 71
  hl-color:: yellow
  id:: 63b2dd0b-e24e-4223-908b-3519659a88f7
- Object.getOwnPropertyNames()返回对象实例的常规属性数组
  ls-type:: annotation
  hl-page:: 71
  hl-color:: yellow
  id:: 63b2de45-08d5-44cf-961c-8173f779af1d
- Object.getOwnPropertySymbols()返回对象实例的符号属性数组
  ls-type:: annotation
  hl-page:: 71
  hl-color:: yellow
  id:: 63b2de4f-0594-406c-942b-d22c73908ef3
- Reflect.ownKeys()会返回两种类型的键
  ls-type:: annotation
  hl-page:: 71
  hl-color:: yellow
  id:: 63b2df37-528a-41e6-b5d4-81bb8c11c412
- 常用内置符号
  ls-type:: annotation
  hl-page:: 72
  hl-color:: yellow
  id:: 63b2df6e-5853-49cf-849b-42994aa2362d
- 所有内置符号属性都是不可写、不可枚举、不可配置的
  ls-type:: annotation
  hl-page:: 72
  hl-color:: yellow
  id:: 63b2dfcc-3e24-4925-a808-24830df6ae31
- Symbol.asyncIterator
  ls-type:: annotation
  hl-page:: 73
  hl-color:: yellow
  id:: 63b2dfd3-9011-4aaa-b512-0c5373d2068d
- 由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回 Promise 实例
  ls-type:: annotation
  hl-page:: 73
  hl-color:: yellow
  id:: 63b2e04a-bfc5-4d89-ab2b-906c6875b418
- 可以通过显式地调用 next()方法返回，也可以隐式地通过异步生成器函数返回
  ls-type:: annotation
  hl-page:: 73
  hl-color:: yellow
  id:: 63b2e052-4203-493b-918d-78d0aca430dc
- Symbol.hasInstance
  ls-type:: annotation
  hl-page:: 73
  hl-color:: yellow
  id:: 63b2e05d-97d4-46a9-92bd-3da8a822843f
- 以 Symbol. hasInstance 为键的函数会执行同样的操作，只是操作数对调了一下
  ls-type:: annotation
  hl-page:: 74
  hl-color:: yellow
  id:: 63b2e0f1-04d4-4070-a5f9-4a497a591d66
- Symbol.isConcatSpreadable
  ls-type:: annotation
  hl-page:: 74
  hl-color:: yellow
  id:: 63b2e132-c0f1-4bad-b02e-d740bf26ead5
- 数组对象默认情况下会被打平到已有的数组，false 或假值会导致整个对象被追加到数组末尾
  ls-type:: annotation
  hl-page:: 74
  hl-color:: yellow
  id:: 63b2e1b2-385e-4d8c-aaa0-1a9cd9997fec
- 类数组对象默认情况下会被追加到数组末尾，true 或真值会导致这个类数组对象被打平到数组实例
  ls-type:: annotation
  hl-page:: 74
  hl-color:: yellow
  id:: 63b2e1be-0837-46ba-831b-64e18ae16a90
- Symbol.iterator
  ls-type:: annotation
  hl-page:: 75
  hl-color:: yellow
  id:: 63b2e1d8-dabf-4cee-9f24-52cb3c085e07
- Symbol.match
  ls-type:: annotation
  hl-page:: 76
  hl-color:: yellow
  id:: 63b2e278-90d0-43f2-8af2-38243a38b3e6
- 由 String.prototype.match()方法使用
  ls-type:: annotation
  hl-page:: 76
  hl-color:: yellow
  id:: 63b2e291-390a-4201-a6ea-5349d3244fd8
- 给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象
  ls-type:: annotation
  hl-page:: 76
  hl-color:: yellow
  id:: 63b2e2c1-29f4-4c9a-abb8-02ca7b6f8d33
- Symbol.replace
  ls-type:: annotation
  hl-page:: 76
  hl-color:: yellow
  id:: 63b2e303-fad1-4d25-ba7f-5591e4ab3acf
- Symbol.search
  ls-type:: annotation
  hl-page:: 77
  hl-color:: yellow
  id:: 63b2e30c-64e2-4791-a75b-eb1c92f14700
- Symbol.species
  ls-type:: annotation
  hl-page:: 78
  hl-color:: yellow
  id:: 63b2e314-c257-462f-86e2-fd3c1ff6ecc9
- Symbol.split
  ls-type:: annotation
  hl-page:: 78
  hl-color:: yellow
  id:: 63b2e31c-33fe-4383-9c9c-0e563fed4fd0
- Symbol.toPrimitive
  ls-type:: annotation
  hl-page:: 79
  hl-color:: yellow
  id:: 63b2e326-b3f0-4788-8188-c76e467f7669
- Symbol.toStringTag
  ls-type:: annotation
  hl-page:: 80
  hl-color:: yellow
  id:: 63b2e32d-f7b0-40dd-9feb-656a62b5627e
- Symbol.unscopables
  ls-type:: annotation
  hl-page:: 80
  hl-color:: yellow
  id:: 63b2e33a-5c01-49ca-943d-28de5327e640
- 操作符
  ls-type:: annotation
  hl-page:: 81
  hl-color:: yellow
  id:: 63b2e41a-3d2c-4482-9200-950b5f94ac6b
- 语句
  ls-type:: annotation
  hl-page:: 98
  hl-color:: yellow
  id:: 63b2e434-f487-4760-9c5e-4ecaff09863a
- 函数
  ls-type:: annotation
  hl-page:: 105
  hl-color:: yellow
  id:: 63b2e447-e5b9-444f-8f5c-d921d3e0620f
- ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值。
  ls-type:: annotation
  hl-page:: 81
  hl-color:: yellow
  id:: 63b56867-a1cd-41c8-a2a4-ba4bd7a63c5e
- 一元操作符
  ls-type:: annotation
  hl-page:: 81
  hl-color:: yellow
  id:: 63b56880-ea21-4536-81d1-64b24c3bd484
- 递增/递减操作符
  ls-type:: annotation
  hl-page:: 82
  hl-color:: yellow
  id:: 63b5688f-eb0a-402b-8d6c-d2c8489c0952
- 一元加和减
  ls-type:: annotation
  hl-page:: 83
  hl-color:: yellow
  id:: 63b5695c-1e36-4518-b9bb-5d43cedd7bee
- 位操作符
  ls-type:: annotation
  hl-page:: 84
  hl-color:: yellow
  id:: 63b56a1d-2843-482b-bd41-8bdca0730fb2
- ECMAScript中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32 位整数，再进行位操作，之后再把结果转换为 64 位
  ls-type:: annotation
  hl-page:: 84
  hl-color:: yellow
  id:: 63b56a37-f75d-4ff2-a0ab-1b4cbf926723
- 有符号整数使用 32 位的前 31 位表示整数值
  ls-type:: annotation
  hl-page:: 84
  hl-color:: yellow
  id:: 63b56a43-8c13-41ac-be50-ecc34c72141d
- 负值以一种称为二补数（或补码）的二进制编码存储。
  ls-type:: annotation
  hl-page:: 85
  hl-color:: yellow
  id:: 63b56ada-2d40-4978-ac32-6d46adcd9aed
- 无符号整数来说，第 32 位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了
  ls-type:: annotation
  hl-page:: 85
  hl-color:: yellow
  id:: 63b56b2f-fb7e-4790-8596-5730cd210065
- 特殊值 NaN 和 Infinity在位操作中都会被当成 0 处理
  ls-type:: annotation
  hl-page:: 86
  hl-color:: yellow
  id:: 63b56b7e-3f77-4ca4-a68d-5cc958be6033
- 用波浪符（~）表示
  ls-type:: annotation
  hl-page:: 86
  hl-color:: yellow
  id:: 63b56c2a-55d6-4c24-9c5f-9e5bd784fb5d
- 对数值取反并减 1
  ls-type:: annotation
  hl-page:: 86
  hl-color:: yellow
  id:: 63b56c36-f313-4f94-809b-b58a60e7207f
- 用和号（&）表示
  ls-type:: annotation
  hl-page:: 86
  hl-color:: yellow
  id:: 63b56d01-cff7-4faf-8f55-8953bcf4647f
- 用管道符（|）表示
  ls-type:: annotation
  hl-page:: 86
  hl-color:: yellow
  id:: 63b56db9-61e2-45cb-9890-80a782a1f261
- 用脱字符（^）表示
  ls-type:: annotation
  hl-page:: 87
  hl-color:: yellow
  id:: 63b56ed8-794d-422c-94e9-52f44a343250
- 用两个小于号（<<）表示
  ls-type:: annotation
  hl-page:: 87
  hl-color:: yellow
  id:: 63b56ee6-e3ba-49aa-9c3b-55d67a54e72d
- 左移会保留它所操作数值的符号
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b56f28-3254-402d-b871-c687c177f12d
- 有符号右移
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b56f44-9259-4950-a317-2c739e2227f8
- 由两个大于号（>>）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）。
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b56f50-fe08-4cda-ac42-c64dc84126af
- 无符号右移
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b56fae-3f05-4672-abf9-4cd9f33effba
- ECMAScript 会用符号位的值来填充这些空位，以得到完整的数值
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b56fca-0bcc-4e34-acdc-9397c6764441
- 用 3 个大于号表示（>>>）
  ls-type:: annotation
  hl-page:: 88
  hl-color:: yellow
  id:: 63b5700a-7f95-4ede-a927-1fe327cca27f
- 布尔操作符
  ls-type:: annotation
  hl-page:: 89
  hl-color:: yellow
  id:: 63b571ab-1933-4e99-bc18-af510e70b1db
- 逻辑非
  ls-type:: annotation
  hl-page:: 89
  hl-color:: yellow
  id:: 63b571c0-0583-4399-939b-23011d3c0b09
- 逻辑与
  ls-type:: annotation
  hl-page:: 89
  hl-color:: yellow
  id:: 63b573cd-6484-4c8f-80b5-9a3e911dff55
- 由两个和号（&&）表示
  ls-type:: annotation
  hl-page:: 89
  hl-color:: yellow
  id:: 63b5746e-f392-47f8-99c7-87da08d949b9
- 逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。
  ls-type:: annotation
  hl-page:: 90
  hl-color:: yellow
  id:: 63b574e0-5cca-49af-85d3-7d5d42270248
- 逻辑或
  ls-type:: annotation
  hl-page:: 90
  hl-color:: yellow
  id:: 63b575ca-9c01-4bac-a479-75d1d22dd7f3
- 由两个管道符（||）表示
  ls-type:: annotation
  hl-page:: 90
  hl-color:: yellow
  id:: 63b575e1-8c58-4769-9372-528e7d96dc84
- let myObject = preferredObject || backupObject;
  ls-type:: annotation
  hl-page:: 91
  hl-color:: yellow
  id:: 63b576d2-48cc-47db-854b-0d1112f997d2
- 乘性操作符
  ls-type:: annotation
  hl-page:: 91
  hl-color:: yellow
  id:: 63b578db-a9c5-4434-9165-464e20ca8815
- 乘法操作符
  ls-type:: annotation
  hl-page:: 91
  hl-color:: yellow
  id:: 63b579e6-8fe0-4217-9801-72ae12bc4bb6
- 除法操作符
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b579fa-4898-4ccd-a12a-7a71b2b0a432
- 取模操作符
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b57a0f-9f3f-45ad-94e0-5c558632e5c7
- 由一个百分比符号（%）表示
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b57a1a-5c4f-4511-b005-c8f617d1336c
- 指数操作符
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b57adf-beb6-4c01-9746-4320ce30c8bf
- 操作符**
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b57af8-d0ad-4a66-98f0-086b290dc163
- 指数赋值操作符**=
  ls-type:: annotation
  hl-page:: 92
  hl-color:: yellow
  id:: 63b57aff-38dd-4ce0-8335-f4a0c167564d
- 加性操作符
  ls-type:: annotation
  hl-page:: 93
  hl-color:: yellow
  id:: 63b57b35-eb63-4ec3-843d-1c8a499c46e4
- 加法操作符
  ls-type:: annotation
  hl-page:: 93
  hl-color:: yellow
  id:: 63b57b48-7df0-4a5f-ab16-b9f63052fef7
- 如果是 Infinity 加-Infinity，则返回 NaN；
  ls-type:: annotation
  hl-page:: 93
  hl-color:: yellow
  id:: 63b57bc1-d452-4d08-8f27-b5efa71a3a78
- 如果是-0 加+0，则返回+0；
  ls-type:: annotation
  hl-page:: 93
  hl-color:: yellow
  id:: 63b57c1b-a0a9-4e12-93c5-f80440b5ce97
- 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。
  ls-type:: annotation
  hl-page:: 93
  hl-color:: yellow
  id:: 63b57c56-f1e8-4a0c-910f-7bb789cf9d34
- 减法操作符
  ls-type:: annotation
  hl-page:: 94
  hl-color:: yellow
  id:: 63b57ce7-4317-49d8-b6e8-b9570bdd85e2
- 如果是+0 减-0，则返回-0
  ls-type:: annotation
  hl-page:: 94
  hl-color:: yellow
  id:: 63b57cfa-16d3-4d38-8906-054d36ecc82a
- 如果是-0 减-0，则返回+0
  ls-type:: annotation
  hl-page:: 94
  hl-color:: yellow
  id:: 63b57d14-0d4d-4a87-9272-463165868f47
- 如果是-Infinity 减-Infinity，则返回 NaN。
  ls-type:: annotation
  hl-page:: 94
  hl-color:: yellow
  id:: 63b57d27-24e1-4cf9-bc3b-347242195e80
- 关系操作符
  ls-type:: annotation
  hl-page:: 94
  hl-color:: yellow
  id:: 63b57d6f-81a0-452d-874b-df87a4dde944
- 相等操作符
  ls-type:: annotation
  hl-page:: 95
  hl-color:: yellow
  id:: 63b57fa3-3c9c-4908-9597-586c2b0c5cce
- null 和 undefined 相等。
  ls-type:: annotation
  hl-page:: 96
  hl-color:: yellow
  id:: 63b58071-56c1-46a8-a015-c4233a933ab6
- NaN != NaN true
  ls-type:: annotation
  hl-page:: 96
  hl-color:: yellow
  id:: 63b58093-dff1-4302-9b29-f4abb2898109
- let result2 = ("55" === 55); // false，不相等，因为数据类型不同
  ls-type:: annotation
  hl-page:: 96
  hl-color:: yellow
  id:: 63b580c7-fd7c-4818-858d-92356f01b507
- null === undefined 是 false，因为它们不是相同的数据类型。
  ls-type:: annotation
  hl-page:: 97
  hl-color:: yellow
  id:: 63b580d6-05f3-4713-a027-146e5ffc7363
- 条件操作符
  ls-type:: annotation
  hl-page:: 97
  hl-color:: yellow
  id:: 63b580dd-4b0a-44b4-acde-7f378162f9e9
- 赋值操作符
  ls-type:: annotation
  hl-page:: 97
  hl-color:: yellow
  id:: 63b580f3-c054-4223-bc53-f04577b9a8fc
- 逗号操作符
  ls-type:: annotation
  hl-page:: 98
  hl-color:: yellow
  id:: 63b580fb-16f2-4874-bb47-01a959304e3c
- variable = boolean_expression ? true_value : false_value;
  ls-type:: annotation
  hl-page:: 97
  hl-color:: yellow
  id:: 63b5810f-4e1e-4edd-b792-127271bcf3e5
- 使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：
  ls-type:: annotation
  hl-page:: 98
  hl-color:: yellow
  id:: 63b582cf-eb35-4c15-9337-bf4c081f9d2d
- if 语句
  ls-type:: annotation
  hl-page:: 98
  hl-color:: yellow
  id:: 63b58321-da1c-40e8-b506-5e6d7f3339d7
- do-while 语句
  ls-type:: annotation
  hl-page:: 99
  hl-color:: yellow
  id:: 63b58336-fee9-4ce9-920c-b9e67dce1059
- while 语句
  ls-type:: annotation
  hl-page:: 99
  hl-color:: yellow
  id:: 63b5833e-c903-4938-a353-fb73f3789254
- for 语句
  ls-type:: annotation
  hl-page:: 99
  hl-color:: yellow
  id:: 63b58346-c7ce-4857-930a-7dded1639c4f
- for-in 语句
  ls-type:: annotation
  hl-page:: 100
  hl-color:: yellow
  id:: 63b58352-12a2-4b13-9251-ede479c39ec8
- for-of 语句
  ls-type:: annotation
  hl-page:: 101
  hl-color:: yellow
  id:: 63b58361-8f28-463a-ab1f-2a525e5353f0
- 标签语句
  ls-type:: annotation
  hl-page:: 101
  hl-color:: yellow
  id:: 63b5836c-f673-4414-9de3-9309ff40a6b9
- break 和 continue 语句
  ls-type:: annotation
  hl-page:: 101
  hl-color:: yellow
  id:: 63b58376-a637-4872-805c-61cf3504bc11
- with 语句
  ls-type:: annotation
  hl-page:: 103
  hl-color:: yellow
  id:: 63b58387-dd7e-4b5c-bd34-19956c9b66d4
- switch 语句
  ls-type:: annotation
  hl-page:: 103
  hl-color:: yellow
  id:: 63b58395-70fc-4d6c-b5df-6e394204a48b
- for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体。
  ls-type:: annotation
  hl-page:: 101
  hl-color:: yellow
  id:: 63ba22a7-2d98-405a-860f-8ace3b57b7f2
- break 和 continue 都可以与标签语句一起使用，返回代码中特定的位置。这通常是在嵌套循环中
  ls-type:: annotation
  hl-page:: 102
  hl-color:: yellow
  id:: 63ba2626-24a8-4a18-b487-1c2ffac39fa4
- ECMAScript 中的函数不需要指定是否返回值。任何函数在任何时间都可以使用 return 语句来返回函数的值，用法是后跟要返回的值
  ls-type:: annotation
  hl-page:: 106
  hl-color:: yellow
  id:: 63ba2fb8-5815-483f-8c79-07b7ec2e4123
- 原始值与引用值
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc00e6-7457-464c-b735-9fce29da28e7
- 原始值（primitive value）就是最简单的数据
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc00fb-de43-412c-93f2-e5c74c7f8346
- 引用值（reference value）则是由多个值构成的对象
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc0102-b67e-4721-964a-0707147bb228
- JavaScript 不允许直接访问内存位置
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc0123-30e5-4902-b42e-b18b1be1fb87
- 。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc0133-d23b-4dcf-8537-4ac727b24273
- 在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例。
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc0183-6944-43e0-9cd5-de3cadea3c20
- 动态属性
  ls-type:: annotation
  hl-page:: 108
  hl-color:: yellow
  id:: 63bc018d-50be-4577-917f-7c0f3b8aa5d3
- 原始值不能有属性，尽管尝试给原始值添加属性不会报错
  ls-type:: annotation
  hl-page:: 109
  hl-color:: yellow
  id:: 63bc01c8-546e-4484-8811-6bcbb696e597
- 原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，
  ls-type:: annotation
  hl-page:: 109
  hl-color:: yellow
  id:: 63bc01e8-bef1-4167-bf71-30ab4f9cb180
- 在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象
  ls-type:: annotation
  hl-page:: 110
  hl-color:: yellow
  id:: 63bc0206-c2f8-4455-99ba-ac8b79767fdb
- 参数 num 和变量 count 互不干扰，它们只不过碰巧保存了一样的值
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc0240-8ab0-4374-85ab-e6712dd90fcf
- 果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc0253-1c15-4505-9b70-fc727b7942ec
- 因为 obj 指向的对象保存在全局作用域的堆内存上
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc025c-b408-416c-b4e2-83c2a9e5c353
- 如果 person 是按引用传递的，那么 person 应该自动将指针改为指向 name 为"Greg"的对象。
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc02c7-95ed-43d9-8469-16103eaf13b3
- ECMAScript 中函数的参数就是局部变量。
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc02ca-9e82-45bc-97cb-83f9bd6953d6
- 复制值
  ls-type:: annotation
  hl-page:: 109
  hl-color:: yellow
  id:: 63bc0329-7793-46b6-88a8-74bacb1af594
- 传递参数
  ls-type:: annotation
  hl-page:: 110
  hl-color:: yellow
  id:: 63bc0334-9135-46fa-823d-50197cc6db07
- ECMAScript 中所有函数的参数都是按值传递的
  ls-type:: annotation
  hl-page:: 110
  hl-color:: yellow
  id:: 63bc0347-abea-4a3a-9996-d4c660f72ea8
- 确定类型
  ls-type:: annotation
  hl-page:: 111
  hl-color:: yellow
  id:: 63bc0350-2c24-4ed9-b206-9e7d7062f6e3
- 如果用 instanceof 检测原始值，则始终会返回 false，因为原始值不是对象
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc0411-ef6d-4a96-ad36-6206d2d6837e
- typeof 操作符在用于检测函数时也会返回"function"
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc0428-bec7-4538-b864-d457a1e4311f
- 在 IE 和 Firefox 中，typeof 对正则表达式返回"object"。
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc0438-ea70-4f0e-845a-aef946d8a7e7
- 执行上下文与作用域
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc0452-9e02-4750-acf8-a591f04e3eca
- 每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc04a4-645c-4661-bfc8-e33a0a0edfaa
- 全局上下文是最外层的上下文
  ls-type:: annotation
  hl-page:: 112
  hl-color:: yellow
  id:: 63bc05c8-1af4-423b-8be8-d1ddf1ccde6b
- 每个函数调用都有自己的上下文
  ls-type:: annotation
  hl-page:: 113
  hl-color:: yellow
  id:: 63bc0746-f5a1-46b3-a025-1e6d825d0d3b
- 上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）
  ls-type:: annotation
  hl-page:: 113
  hl-color:: yellow
  id:: 63bc079d-1d56-456c-9361-ebf32137318c
- 如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）
  ls-type:: annotation
  hl-page:: 113
  hl-color:: yellow
  id:: 63bc07af-6caa-4ed9-ac8f-1d50b0b85dd9
- 全局上下文的变量对象始终是作用域链的最后一个变量对象。
  ls-type:: annotation
  hl-page:: 113
  hl-color:: yellow
  id:: 63bc07c4-cb75-47f4-8b43-1d688ef70add
- 这个函数内部之所以能够访问变量 color，就是因为可以在作用域链中找到它。
  ls-type:: annotation
  hl-page:: 113
  hl-color:: yellow
  id:: 63bc0863-6127-4217-ae8f-1a0f1858c348
- 全局上下文、changeColor()的局部上下文和 swapColors()的局部上下文。
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc088e-11af-43a8-8ca1-222f83f972da
- 。全局上下文和 changeColor()的局部上下文都无法访问到 tempColor
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc089b-b1a8-4924-89a3-720a4041840f
- 但外部上下文无法访问内部上下文中的任何东西
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc08c4-f2cf-4318-8519-82f41fba50e2
- 作用域链增强
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc08d5-5485-4359-9a24-1f7e7d232c03
- 某些语句会导致在作用域链前端临时添加一个上下文
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc0913-b2b2-4f86-991f-2483259306bd
- try/catch 语句的 catch 块
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc0923-246e-4534-a835-5b45d1adb370
- with 语句
  ls-type:: annotation
  hl-page:: 114
  hl-color:: yellow
  id:: 63bc0929-a5cc-4993-9d2e-13125171579a
- location 会被添加到作用域链前端
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc097b-86b5-4f3e-8ebe-9735bc15f303
- with 语句中的代码引用变量 href 时，实际上引用的是 location.href，也就是自己变量对象的属性
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc098c-0f66-4e9b-9c2e-7d34d2f7b94b
- 变量声明
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc0a34-2963-402d-ab4c-3ed9c11c6c84
- ES6 不仅增加了 let 和 const 两个关键字，而且还让这两个关键字压倒性地超越 var成为首选。
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc0a47-6c43-4097-9714-6dc2cfded1b8
- 在使用 var 声明变量时，变量会被自动添加到最接近的上下文
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc0ad4-7a11-41bc-9bea-5bd8effd83e5
- 如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文
  ls-type:: annotation
  hl-page:: 115
  hl-color:: yellow
  id:: 63bc0b02-d799-471d-9f4b-659f64cc4686
- var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。
  ls-type:: annotation
  hl-page:: 116
  hl-color:: yellow
  id:: 63bc0be4-bdca-4f6e-9e89-c813c1010c42
- let 与 var 的另一个不同之处是在同一作用域内不能声明两次
  ls-type:: annotation
  hl-page:: 117
  hl-color:: yellow
  id:: 63bc0c2d-e78e-445e-be5a-8893dcf9e022
- 在其生命周期的任何时候都不能再重新赋予新值
  ls-type:: annotation
  hl-page:: 117
  hl-color:: yellow
  id:: 63bc0c8d-0699-4505-85da-64170ce49791
- ，赋值为对象的 const 变量不能再被重新赋值为其他引用值
  ls-type:: annotation
  hl-page:: 118
  hl-color:: yellow
  id:: 63bc0cdb-1f30-426e-b3b6-31d840880b9e
- 垃圾回收
  ls-type:: annotation
  hl-page:: 119
  hl-color:: yellow
  id:: 63bc0db2-6a64-4939-a798-94f1043416b7
- 标记清理
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc0dc5-d9c7-411d-b66a-55ab13e4625a
- 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc0f52-6311-4d99-9bba-e863b361e33e
- 引用计数
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc0f5e-7bef-4c35-91f6-d02818ac434d
- 如果同一个值又被赋给另一个变量，那么引用数加 1
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc1137-3920-4f59-b512-d471262495f2
- 如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc1140-2c06-4469-b08e-bf62922610a3
- 所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A
  ls-type:: annotation
  hl-page:: 120
  hl-color:: yellow
  id:: 63bc115c-f35c-42d7-a1e4-8e43fa7d53bf
- 为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接。
  ls-type:: annotation
  hl-page:: 121
  hl-color:: yellow
  id:: 63bc11cf-c53c-4d11-81be-01171fafb985
- 性能
  ls-type:: annotation
  hl-page:: 121
  hl-color:: yellow
  id:: 63bc11d8-86fd-4c8e-82e8-83f8ab1dc595
- 垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。
  ls-type:: annotation
  hl-page:: 121
  hl-color:: yellow
  id:: 63bc1231-86f5-4e72-8ad3-d132f0d86743
- 一次完整的垃圾回收之后，V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收
  ls-type:: annotation
  hl-page:: 121
  hl-color:: yellow
  id:: 63bc127a-7518-4648-b954-a8b05c39fe44
- IE7 发布后，JavaScript 引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值
  ls-type:: annotation
  hl-page:: 122
  hl-color:: yellow
  id:: 63bc1292-b061-4e55-99f8-d4fe3ef100a3
- 内存管理
  ls-type:: annotation
  hl-page:: 122
  hl-color:: yellow
  id:: 63bc1371-87ef-49b5-b7d7-7db45049d022
- 优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作解除引用
  ls-type:: annotation
  hl-page:: 122
  hl-color:: yellow
  id:: 63bc1386-0ce9-4e25-9402-5312e820eda5
- 但 globalPerson 是一个全局变量，应该在不再需要时手动解除其引用，最后一行就是这么做的
  ls-type:: annotation
  hl-page:: 122
  hl-color:: yellow
  id:: 63bc1433-5260-4691-989f-15529ed2a735
- 解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。
  ls-type:: annotation
  hl-page:: 122
  hl-color:: yellow
  id:: 63bc1436-4560-44ea-8fa9-a7454704f510
- ，localPerson 作为函数值被返回，并被赋值给 globalPerson。localPerson 在 createPerson()执行完成超出上下文后会
  ls-type:: annotation
  hl-page:: 122
  hl-color:: green
  id:: 63bc1496-38a9-4e29-b833-e60c51387f89
- 隐藏类和删除操作
  ls-type:: annotation
  hl-page:: 123
  hl-color:: yellow
  id:: 63bc15e5-dfca-4a4e-95b5-31706aa5c48d
- 最佳实践是把不想要的属性设置为 null。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果
  ls-type:: annotation
  hl-page:: 123
  hl-color:: yellow
  id:: 63bc160b-4f6d-46fd-869a-e6e99031f8a5
- 意外声明全局变量是最常见但也最容易修复的内存泄漏问题
  ls-type:: annotation
  hl-page:: 124
  hl-color:: yellow
  id:: 63bc165a-b480-45c0-a458-5a3e3ff096b1
- 定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量
  ls-type:: annotation
  hl-page:: 124
  hl-color:: yellow
  id:: 63bc1676-162a-4c17-a2c9-ce3fca2948dc
- 使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏
  ls-type:: annotation
  hl-page:: 124
  hl-color:: yellow
  id:: 63bc1782-8e34-468e-a63e-a1e014cae268
- 如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行
  ls-type:: annotation
  hl-page:: 125
  hl-color:: yellow
  id:: 63bc17c1-c32e-42ed-bc4c-f36e4f02be04
- 不要动态创建矢量对象，比如可以修改上面的函数，让它使用一个已有的矢量对象
  ls-type:: annotation
  hl-page:: 125
  hl-color:: yellow
  id:: 63bc17e3-4c7e-4cfb-ba38-bb854d518fef
- 一个策略是使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它
  ls-type:: annotation
  hl-page:: 125
  hl-color:: yellow
  id:: 63bc1808-e17f-4aa7-80ed-fd865338a7ed
- 可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作
  ls-type:: annotation
  hl-page:: 126
  hl-color:: yellow
  id:: 63bc1853-a0b0-4d79-9872-cb88dbb70e15
- 小结
  ls-type:: annotation
  hl-page:: 126
  hl-color:: yellow
  id:: 63bc1876-9120-4818-a83b-7ce170667e05
- 在 ECMAScript 中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”
  ls-type:: annotation
  hl-page:: 128
  hl-color:: yellow
  id:: 63bd5ef7-47b4-4519-a0ef-25e198499ea7
- 引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法
  ls-type:: annotation
  hl-page:: 128
  hl-color:: yellow
  id:: 63bd5f3f-a101-4b6b-86e8-9b427b2a5bdc
- Date
  ls-type:: annotation
  hl-page:: 128
  hl-color:: yellow
  id:: 63bd5f4d-d314-4341-92a2-14522ea031c0
- 创建的对象将保存当前日期和时间
  ls-type:: annotation
  hl-page:: 129
  hl-color:: yellow
  id:: 63bd5f86-b6db-444c-a06c-c050c6b857ed
- 继承的方法
  ls-type:: annotation
  hl-page:: 130
  hl-color:: yellow
  id:: 63bd6093-8db6-4e00-a459-c80320068578
- Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间
  ls-type:: annotation
  hl-page:: 130
  hl-color:: yellow
  id:: 63bd60af-148b-4768-b597-494f86b19a41
- toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的
  ls-type:: annotation
  hl-page:: 130
  hl-color:: yellow
  id:: 63bd60ba-2f68-4c3f-ba46-d3d95815cab6
- Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。
  ls-type:: annotation
  hl-page:: 130
  hl-color:: yellow
  id:: 63bd60c7-b957-485d-b16d-683440657ca6
- 日期格式化方法
  ls-type:: annotation
  hl-page:: 131
  hl-color:: yellow
  id:: 63bd6104-68a8-4f04-a2eb-43c7b50922bc
- 日期/时间组件方法
  ls-type:: annotation
  hl-page:: 131
  hl-color:: yellow
  id:: 63bd6117-1e9b-4b45-9bd3-5a798016310b
- RegExp
  ls-type:: annotation
  hl-page:: 132
  hl-color:: yellow
  id:: 63bd6164-4c6b-47d6-950b-0837a7cdab5d
- 与其他语言中的正则表达式类似，所有元字符在模式中也必须转义
  ls-type:: annotation
  hl-page:: 132
  hl-color:: yellow
  id:: 63bd6233-647d-450b-a7c0-f113e829543f
- 正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串
  ls-type:: annotation
  hl-page:: 133
  hl-color:: yellow
  id:: 63bd629a-232c-4b78-aa1d-0d2b6834b66f
- 所有元字符都必须二次转义，包括转义字符序列
  ls-type:: annotation
  hl-page:: 133
  hl-color:: yellow
  id:: 63bd62d4-33c8-458c-ae9e-638849f676e7
- 使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：
  ls-type:: annotation
  hl-page:: 133
  hl-color:: yellow
  id:: 63bd62fe-148a-497b-8776-72675bf24cf4
- RegExp 实例属性
  ls-type:: annotation
  hl-page:: 134
  hl-color:: yellow
  id:: 63bd6322-68b0-413f-8dc6-150213da96b7
- RegExp 实例方法
  ls-type:: annotation
  hl-page:: 134
  hl-color:: yellow
  id:: 63bd6403-0f59-4930-ab58-1ebaaaff423f
- RegExp 实例的主要方法是 exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串
  ls-type:: annotation
  hl-page:: 134
  hl-color:: yellow
  id:: 63bd6413-93f2-4196-bc7e-a75296d50d5b
- 如果模式设置了全局标记，则每次调用 exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息。
  ls-type:: annotation
  hl-page:: 135
  hl-color:: yellow
  id:: 63bd6493-fbf9-4cd8-ae2c-df77963b1134
- 如果在这个模式上设置了 g 标记，则每次调用 exec()都会在字符串中向前搜索下一个匹配项
  ls-type:: annotation
  hl-page:: 135
  hl-color:: yellow
  id:: 63bd64f1-5131-4966-951e-701a7454ae2e
- 这次模式设置了全局标记，因此每次调用 exec()都会返回字符串中的下一个匹配项，直到搜索到字符串末尾。
  ls-type:: annotation
  hl-page:: 135
  hl-color:: yellow
  id:: 63bd653b-f1c2-4e6c-a8dd-6c6eb5d130bd
- 如果模式设置了粘附标记 y，则每次调用 exec()就只会在 lastIndex 的位置上寻找匹配项
  ls-type:: annotation
  hl-page:: 136
  hl-color:: yellow
  id:: 63bd6544-7206-4ca6-8ec2-f059e9d0cebe
- 包含两个额外的属性：index 和 input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串
  ls-type:: annotation
  hl-page:: 134
  hl-color:: yellow
  id:: 63bd65d2-047d-4cc0-80d4-47a579c66cdb
- 正则表达式的另一个方法是 test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 true，否则返回 false。
  ls-type:: annotation
  hl-page:: 136
  hl-color:: yellow
  id:: 63bd66bf-f9fc-4bb2-af99-799ec906130e
- 正则表达式的 valueOf()方法返回正则表达式本身。
  ls-type:: annotation
  hl-page:: 136
  hl-color:: yellow
  id:: 63bd6711-b721-4cfc-a8a9-b231049b9142
- RegExp 构造函数属性
  ls-type:: annotation
  hl-page:: 136
  hl-color:: yellow
  id:: 63bd6718-34dd-4f80-b598-767393920bf7
- 这些属性名也可以替换成简写形式，只不过要使用中括号语法来访问
  ls-type:: annotation
  hl-page:: 137
  hl-color:: yellow
  id:: 63bd676b-e44a-4767-bc65-921e9b42ef9a
- RegExp 还有其他几个构造函数属性，可以存储最多 9 个捕获组的匹配项。这些属性通过 RegExp.$1~RegExp.$9 来访问，分别包含第 1~9 个捕获组的匹配项
  ls-type:: annotation
  hl-page:: 137
  hl-color:: yellow
  id:: 63bd67aa-2dfc-4afd-8127-b63ef6d2147d
- 模式局限
  ls-type:: annotation
  hl-page:: 138
  hl-color:: yellow
  id:: 63bd67b1-e6ba-4a10-8fa7-8f975400506b
- 原始值包装类型
  ls-type:: annotation
  hl-page:: 138
  hl-color:: yellow
  id:: 63bd67ba-0a2b-482f-9fd5-09c6cb182d81
- 引用类型与原始值包装类型的主要区别在于对象的生命周期。
  ls-type:: annotation
  hl-page:: 139
  hl-color:: yellow
  id:: 63bd6801-621f-408e-959e-d557cbabc10e
- 可以显式地使用 Boolean、Number 和 String 构造函数创建原始值包装对象
  ls-type:: annotation
  hl-page:: 139
  hl-color:: yellow
  id:: 63bd6999-8a01-481c-a537-94228c590cb1
- Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例。
  ls-type:: annotation
  hl-page:: 139
  hl-color:: yellow
  id:: 63bd69ac-334b-4451-ba98-a72577a750df
- 使用 new 调用原始值包装类型的构造函数，与调用同名的转型函数并不一样。
  ls-type:: annotation
  hl-page:: 139
  hl-color:: yellow
  id:: 63bd6a04-7d24-4003-accd-e6665b5d00da
- Boolean
  ls-type:: annotation
  hl-page:: 139
  hl-color:: yellow
  id:: 63bd6a0a-dc55-457c-a315-ec5d89622289
- 理解原始布尔值和 Boolean 对象之间的区别非常重要，强烈建议永远不要使用后者
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6a63-8c6b-4643-aad1-f703c2c085ae
- Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调用时也会被覆盖，返回字符串"true"或"false"。
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6a6d-d599-49b1-8609-bafbd724df91
- Number
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6a7f-15d7-4cc9-a596-b05d2dc03968
- let numberObject = new Number(10);
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6ab1-7547-48a2-95b1-24b1c095c160
- toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6ad1-9fc0-4c28-8865-0c0f13009161
- toFixed()方法返回包含指定小数点位数的数值字符串
  ls-type:: annotation
  hl-page:: 140
  hl-color:: yellow
  id:: 63bd6ae1-44bb-4335-9d78-b47a74738552
- toFixed()方法可以表示有 0~20 个小数位的数值。
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6af4-65ff-4413-9c42-0a6fe884b999
- toExponential()，返回以科学记数法（也称为指数记数法）表示的数值字符串。
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b15-8aa3-48dd-9365-541dfb537a39
- toExponential()也接收一个参数，表示结果中小数的位数
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b32-7871-46d2-a66b-bc35154e7ab8
- toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b4b-d86b-472c-8c8e-b310d49c3326
- 接收一个参数，表示结果中数字的总位数（不包含指数）。
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b52-baf1-4730-8eaa-ffe807fe5cf9
- toPrecision()方法可以表示带 1~21 个小数位的数值
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b60-9df9-4832-862d-f7c178454770
- 处理原始数值和引用数值时，typeof 和 instacnceof操作符会返回不同的结果
  ls-type:: annotation
  hl-page:: 141
  hl-color:: yellow
  id:: 63bd6b8a-6d5e-4c3d-9338-974ee41a26b5
- ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6b97-f89a-4c3d-b542-00cf173a604d
- console.log(Number.isInteger(1.00)); // true
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6ba9-591b-4b1c-9e94-f8be14b6ff20
- EEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从 Number.MIN_SAFE_INTEGER（253 + 1）到 Number.MAX_SAFE_INTEGER（253  1）。
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6bcd-c4c1-45e8-8f07-e167a57da4bd
- 为了鉴别整数是否在这个范围内，可以使用 Number.isSafeInteger()方法：
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6bd7-f3ca-4a6a-a949-0ffa19c877f6
- String
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6bde-64c7-40df-8ba0-f7cd7dec0499
- 每个 String 对象都有一个 length 属性，表示字符串中字符的数量
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6bec-9d16-452b-bce3-5ddf99a15753
- avaScript 字符
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6c20-254d-42d7-8326-db85580185cc
- 对多数字符来说，每 16 位码元对应一个字符
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6c28-715e-482f-9088-c5745b3b26dd
- charAt()方法返回给定索引位置的字符，由传给方法的整数参数指定
  ls-type:: annotation
  hl-page:: 142
  hl-color:: yellow
  id:: 63bd6c2f-aead-4706-b12c-96aaeba6f4c4
- charCodeAt()方法可以查看指定码元的字符编码
  ls-type:: annotation
  hl-page:: 143
  hl-color:: yellow
  id:: 63bd6c3e-7be3-402a-8ec4-8621a88b3a21
- fromCharCode()方法用于根据给定的 UTF-16 码元创建字符串中的字符
  ls-type:: annotation
  hl-page:: 143
  hl-color:: yellow
  id:: 63bd6c5a-415c-4b44-b3f0-e20168a19697
- 接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串
  ls-type:: annotation
  hl-page:: 143
  hl-color:: yellow
  id:: 63bd6c61-2370-4f51-a2c1-0024d751bad6
- 为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个字符使用两个 16 位码元的策略称为代理对。
  ls-type:: annotation
  hl-page:: 143
  hl-color:: yellow
  id:: 63bd6caf-6935-46b9-b6de-a0d5b1433de4
- fromCharCode()方法仍然返回正确的结果，因为它实际上是基于提供的二进制表示直接组合成字符串
  ls-type:: annotation
  hl-page:: 144
  hl-color:: yellow
  id:: 63bd6cd9-655f-4508-b7d1-ef8dd8b1299c
- codePointAt()接收 16 位码元的索引并返回该索引位置上的码点（code point）。
  ls-type:: annotation
  hl-page:: 144
  hl-color:: yellow
  id:: 63bd6cef-29c4-49eb-aaa3-2b5bb42ff382
- fromCodePoint()。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串
  ls-type:: annotation
  hl-page:: 144
  hl-color:: yellow
  id:: 63bd6d4a-a946-4bef-a116-48050f3413ff
- normalize()方法
  ls-type:: annotation
  hl-page:: 144
  hl-color:: yellow
  id:: 63bd6d53-05af-46b3-95ed-22115f33b894
- 有的字符既可以通过一个 BMP 字符表示，也可以通过一个代理对表示
  ls-type:: annotation
  hl-page:: 144
  hl-color:: yellow
  id:: 63bd6d86-c8c8-415a-8b58-6376112a0160
- 比较操作符不在乎字符看起来是什么样的
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6dbb-dcb2-48fd-bf49-a1bbfee2bbed
- Unicode 提供了 4 种规范化形式
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6dc4-9925-415b-850b-fb7a3efbc526
- 这 4 种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、 NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6dcb-36b0-4ed3-ae50-66e66593a256
- 通过比较字符串与其调用 normalize()的返回值，就可以知道该字符串是否已经规范化了
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6dfc-9983-4888-af4f-eb90fa30c196
- 字符串操作方法
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6e09-9c6c-42d9-8ef7-292fedfc5629
- concat()，用于将一个或多个字符串拼接成一个新字
  ls-type:: annotation
  hl-page:: 145
  hl-color:: yellow
  id:: 63bd6e17-7faa-4cee-9dd3-b65cd9f72d1c
- 。concat()方法可以接收任意多个参数，因此可以一次性拼接多个字符串
  ls-type:: annotation
  hl-page:: 146
  hl-color:: yellow
  id:: 63bd6e65-1ff3-464a-bab5-f859c16878c2
- slice()
  ls-type:: annotation
  hl-page:: 146
  hl-color:: yellow
  id:: 63bd7722-a298-465e-8c99-c8742c9f5a1d
- substr()
  ls-type:: annotation
  hl-page:: 146
  hl-color:: yellow
  id:: 63bd7728-e259-483f-945d-c140d6e087a7
- substring()
  ls-type:: annotation
  hl-page:: 146
  hl-color:: yellow
  id:: 63bd772e-1e5b-489f-ba2c-583b1abce325
- 字符串位置方法
  ls-type:: annotation
  hl-page:: 147
  hl-color:: yellow
  id:: 63bd79d1-5d12-4a4a-87ff-ee0c2f4b8035
- 在字符串中定位子字符串：indexOf()和 lastIndexOf()
  ls-type:: annotation
  hl-page:: 147
  hl-color:: yellow
  id:: 63bd79e0-2ef0-48e7-85cb-2071f9ad997f
- indexOf()方法从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串
  ls-type:: annotation
  hl-page:: 147
  hl-color:: yellow
  id:: 63bd7a0c-7d13-4289-85f5-faf46e8c0ab7
- 二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；lastIndexOf()则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符
  ls-type:: annotation
  hl-page:: 147
  hl-color:: yellow
  id:: 63bd7a4a-a98d-427f-b2c5-50c70171490b
- 这样使用第二个参数并循环调用 indexOf()或 lastIndexOf()，就可以在字符串中找到所有的目标子字符串
  ls-type:: annotation
  hl-page:: 147
  hl-color:: yellow
  id:: 63bd7ae4-32ac-4452-b895-abdc557b3015
- 字符串包含方法
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63bd7af0-4b4f-44ca-a540-2fd9b9e58f06
- trim()方法
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63bd7bc6-c59b-455f-8c14-d6bb897aa3ba
- repeat()方法
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63bd7bcd-7768-42df-aebd-5a6d82d3e905
- padStart()和 padEnd()方法
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63bd7ca6-4499-49e6-88f4-deb48f02348b
- 字符串迭代与解构
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63bd7cac-89a6-4023-8e8a-0d27def4de0e
- 字符串大小写转换
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63bd7cb2-d62d-406d-a6de-c00467ca637d
- 字符串模式匹配方法
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63bd7cba-5169-4e17-9405-d279b72e1d3d
- localeCompare()方法
  ls-type:: annotation
  hl-page:: 152
  hl-color:: yellow
  id:: 63bd7cc4-786d-4f47-8d66-db2d6d8e1140
- HTML 方法
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63bd7ccb-ad4c-4763-acd7-dee7d5cbbe20
- 单例内置对象
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63bd7cd1-3ee4-40e1-808d-9d20f3a6b150
- startsWith(
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63be2ae9-fdc7-46d9-94f3-7d54480829c2
- endsWith()
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63be2b4d-1e65-472b-8577-8c5e54fd809a
- includes()
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63be2b52-3344-4fcf-b748-b76e00a30b7e
- 表示要将字符串复制多少次，然后返回拼接所有副本后的结果
  ls-type:: annotation
  hl-page:: 148
  hl-color:: yellow
  id:: 63be2c17-349a-426d-aa45-6ea7a5fdd7d6
- padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63be2c8a-7b23-4d95-8504-41d40f5a3d79
- 第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63be2c98-0aaf-4d07-aded-27f9f4cc0aa5
- 字符串的原型上暴露了一个@@iterator 方法，表示可以迭代字符串的每个字符。
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63be2dd2-6e68-416d-990f-c87a9fe48a56
- toLowerCase()
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63be2e0a-cbd5-4229-aef2-ed270f1e84f3
- toLocaleLowerCase(
  ls-type:: annotation
  hl-page:: 149
  hl-color:: yellow
  id:: 63be2e19-6739-4df2-8bd6-9715848bfeb4
- toUpperCase()
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2e23-4251-4e8e-9769-ee822ef38c75
- toLocaleUpperCase(
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2e2a-86cc-4504-ad30-cf959c4c3f4a
- match()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2e88-441b-4bbe-b244-39f3df385e19
- 第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2eba-e3fa-4ab5-9aea-578a521549f7
- search()
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2ecc-09ac-475c-bfd3-cce188b7540e
- 返回模式第一个匹配的位置索引，如果没找到则返回1
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2f00-75f9-4064-a07e-49d3e044fa35
- replace()方法
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2f1d-4a7b-41ca-9942-337cf0d0b9fe
- 第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。
  ls-type:: annotation
  hl-page:: 150
  hl-color:: yellow
  id:: 63be2f5f-3dd0-45d5-9d36-d330c4bb4b3c
- split(
  ls-type:: annotation
  hl-page:: 151
  hl-color:: yellow
  id:: 63be2fa0-7593-489b-a1eb-33040b3e84b3
- 根据传入的分隔符将字符串拆分
  ls-type:: annotation
  hl-page:: 151
  hl-color:: yellow
  id:: 63be2faa-e1d4-41a0-8a46-8d33ba133610
- 第二个参数，即数组大小，确保返回的数组不会超过指定大
  ls-type:: annotation
  hl-page:: 152
  hl-color:: yellow
  id:: 63be30fa-00a8-4d54-925e-78a73ca3417d
- 比较两个字符串
  ls-type:: annotation
  hl-page:: 152
  hl-color:: yellow
  id:: 63be310f-5468-4c56-a6e6-8edd906a61ad
- 如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值
  ls-type:: annotation
  hl-page:: 152
  hl-color:: yellow
  id:: 63be3147-06d2-48a3-aa8b-512c79f40dc4
- localeCompare()的独特之处在于，实现所在的地区（国家和语言）决定了这个方法如何比较字符串
  ls-type:: annotation
  hl-page:: 152
  hl-color:: yellow
  id:: 63be31c8-f575-42ef-a0a8-c21fe2a3b534
- 何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript程序开始执行时就存在的对象
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be322b-67ca-4c3e-b71a-ad21f7f4f56f
- 内置对象，包括 Object、Array 和 String
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be58df-f3a1-4e5d-9ee5-6514262aeca9
- Global
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be59e9-4919-4e4a-8dfc-82fb95e63f1d
- 在全局作用域中定义的变量和函数都会变成 Global 对象的属性 
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5a1c-b75a-432b-bfc7-59702810f4ff
- 函数，包括 isNaN()、isFinite()、parseInt()和 parseFloat()
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5a39-18ab-4cb0-86dd-e25d5809ffde
- URL 编码方法
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5ad5-2f51-46c4-aca7-771c4c251af6
- encodeURI()和 encodeURIComponent()方法用于编码统一资源标识符（URI），以便传给浏览器
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5af2-9544-48bf-afde-4e44dd9e02fb
- ecnodeURI()方法用于对整个 URI 进行编码
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5b02-3cc1-4f0d-b68c-c5f32fc13fb8
- 而 encodeURIComponent()方法用于编码 URI 中单独的组件，比如前面 URL 中的"illegal value.js"
  ls-type:: annotation
  hl-page:: 153
  hl-color:: yellow
  id:: 63be5b83-86bb-4872-9549-bb333ad15fc5
- 而 encodeURIComponent()方法将所有非字母字符都替换成了相应的编码形式
  ls-type:: annotation
  hl-page:: 154
  hl-color:: yellow
  id:: 63be5c2c-7742-492a-a077-87954f3a8952
- 用 encodeURIComponent()应该比使用 encodeURI()的频率更高，这是因为编码查询字符串参数比编码基准 URI 的次数更多
  ls-type:: annotation
  hl-page:: 154
  hl-color:: yellow
  id:: 63be5c37-bc4b-4c8d-bfb9-b1b59950fde5
- decodeURI()和 decodeURIComponent
  ls-type:: annotation
  hl-page:: 154
  hl-color:: yellow
  id:: 63be5d96-1618-4940-a73e-dbbc322046e7
- eval()方法
  ls-type:: annotation
  hl-page:: 154
  hl-color:: yellow
  id:: 63be5daf-c659-4aa6-a5e5-195a662dc8fe
- 接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串
  ls-type:: annotation
  hl-page:: 154
  hl-color:: yellow
  id:: 63be5dbb-3a95-43e6-8fe1-ea641aa3bca8
- 在 eval()内部创建的变量和函数无法被外部访问
  ls-type:: annotation
  hl-page:: 155
  hl-color:: yellow
  id:: 63be5ddc-95d0-4aab-bf99-5f0bd7fa85a8
- Global 对象属性
  ls-type:: annotation
  hl-page:: 155
  hl-color:: yellow
  id:: 63be5de7-4030-436e-bb0d-fc0aebd1384f
- window 对象
  ls-type:: annotation
  hl-page:: 156
  hl-color:: yellow
  id:: 63be5e2e-0cf3-40a8-ad3e-98adb55884e5
- window 对象实现为 Global对象的代理
  ls-type:: annotation
  hl-page:: 156
  hl-color:: yellow
  id:: 63be5e36-6b11-4d07-a157-3ec112b076c5
- Math
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5e3d-c43f-4c8d-8c04-73ec445eff13
- Math 对象属性
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5e85-9610-45e5-97de-6866f8260090
- min()和 max()方法
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5e97-1aa4-4eb0-80ff-0f66ef1d394e
- 要知道数组中的最大值和最小值，可以像下面这样使用扩展操作符： let values = [1, 2, 3, 4, 5, 6, 7, 8]; let max = Math.max(...val);
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5ea7-d264-4875-81fc-4a66f17afda3
- 舍入方法
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5eb3-41cc-4eca-999c-23752957789a
- random()方法
  ls-type:: annotation
  hl-page:: 158
  hl-color:: yellow
  id:: 63be5ebd-7214-4a97-a64e-c5f463378358
- 其他方法
  ls-type:: annotation
  hl-page:: 159
  hl-color:: yellow
  id:: 63be5ec4-1654-4aa3-ba2c-6ce691196fac
- Math.ceil()方法始终向上舍入为最接近的整数。
  ls-type:: annotation
  hl-page:: 157
  hl-color:: yellow
  id:: 63be5ed7-72e9-4d66-b495-017a4dcfc916
- Math.floor()方法始终向下舍入为最接近的整数。
  ls-type:: annotation
  hl-page:: 158
  hl-color:: yellow
  id:: 63be5eea-0dfd-469b-8e88-55937e05c4c4
- Math.round()方法执行四舍五入
  ls-type:: annotation
  hl-page:: 158
  hl-color:: yellow
  id:: 63be5ef2-d47e-484d-9344-55dac5f6db2e
- Math.fround()方法返回数值最接近的单精度（32 位）浮点值表示
  ls-type:: annotation
  hl-page:: 158
  hl-color:: yellow
  id:: 63be5ef7-372d-4b4c-91e6-d398edee49a4
- 返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1
  ls-type:: annotation
  hl-page:: 158
  hl-color:: yellow
  id:: 63be5fbf-7926-4187-b883-730d523b141e
- Object
  ls-type:: annotation
  hl-page:: 161
  hl-color:: green
  id:: 63be5ffb-0403-4793-a0a9-4df65b6dabc1
  hl-stamp:: 1673420799849
- 表达式上下文指的是期待返回值的上下文
  ls-type:: annotation
  hl-page:: 161
  hl-color:: yellow
  id:: 63be61ab-f742-4988-884e-2244fdbfb7f0
- 对象字面量表示法中，属性名可以是字符串或数值
  ls-type:: annotation
  hl-page:: 161
  hl-color:: yellow
  id:: 63be61f0-889b-4835-9c76-54bb2e69091a
- 函数内部会使用 typeof 操作符测试每个属性是否存在，然后根据属性有无构造并显示一条消息
  ls-type:: annotation
  hl-page:: 162
  hl-color:: yellow
  id:: 63be6229-c4ba-4ca8-9cb6-c66eb070d130
- Array
  ls-type:: annotation
  hl-page:: 163
  hl-color:: green
  id:: 63be6267-9bbe-4767-abed-355875869d86
- 创建数组
  ls-type:: annotation
  hl-page:: 163
  hl-color:: green
  id:: 63be62c0-c47a-46da-a1e9-bc013b0b9c6b
  hl-stamp:: 1673421509131
- from()用于将类数组结构转换为数组实例
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be6385-8a48-4253-aabf-b893d03e4d9d
- of()用于将一组参数转换为数组实例
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be638c-129a-4609-91eb-f5e9b7845b1b
- 字符串会被拆分为单字符数组
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be644d-9337-4d0e-ab21-d834b4a155b8
- 可以使用 from()将集合和映射转换为一个新数组
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be6455-ebda-475a-8faf-26e11b1efd6a
- Array.from()对现有数组执行浅复制
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be645c-544b-4f4c-b25d-92a14ca2f754
- 可以使用任何可迭代对象
  ls-type:: annotation
  hl-page:: 164
  hl-color:: yellow
  id:: 63be6462-4669-4baf-8497-d15634c33d7f
- arguments 对象可以被轻松地转换为数组
  ls-type:: annotation
  hl-page:: 165
  hl-color:: yellow
  id:: 63be6468-2990-4970-914e-98f5732a0e78
- rom()也能转换带有必要属性的自定义对象
  ls-type:: annotation
  hl-page:: 165
  hl-color:: yellow
  id:: 63be6484-ba49-4c2a-854d-9807df101535
- 数组空位
  ls-type:: annotation
  hl-page:: 165
  hl-color:: green
  id:: 63be64bd-7bba-4547-a690-799f00a62f50
- const options = [,,,,,]; // 创建包含 5 个元素的数组
  ls-type:: annotation
  hl-page:: 165
  hl-color:: yellow
  id:: 63be64e0-9bc8-4dd1-beac-8b2f4800e640
- ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined
  ls-type:: annotation
  hl-page:: 165
  hl-color:: yellow
  id:: 63be64f6-06cf-4ba9-a1a0-f3f2ff2c4301
- 数组索引
  ls-type:: annotation
  hl-page:: 166
  hl-color:: green
  id:: 63be65c2-3cef-4a1f-96b7-3e08982f9348
- 数组 length 属性的独特之处在于，它不是只读的
  ls-type:: annotation
  hl-page:: 166
  hl-color:: yellow
  id:: 63be65e6-2f5b-468e-b6e9-5885c63f6020
- 数组最多可以包含 4 294 967 295 个元素
  ls-type:: annotation
  hl-page:: 167
  hl-color:: yellow
  id:: 63be6612-ae52-49d9-8052-8496625017b1
- 检测数组
  ls-type:: annotation
  hl-page:: 167
  hl-color:: green
  id:: 63be6619-d53d-47c8-a734-adfa5a858c2a
- 在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符
  ls-type:: annotation
  hl-page:: 167
  hl-color:: yellow
  id:: 63be67fa-8b8e-4d98-8ed1-a8dfd366eaab
- Array.isArray()方法
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be680d-867c-45c8-81ae-46116253d9de
- 迭代器方法
  ls-type:: annotation
  hl-page:: 168
  hl-color:: green
  id:: 63be6819-06c4-40a7-b655-124019baf173
- keys()返回数组索引的迭代器
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be682d-0853-4744-844c-777efbcf076d
- values()返回数组元素的迭代器
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be6834-26ad-4fa3-976c-ecbf117e25ac
- entries()返回索引/值对的迭代器
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be683a-5110-4b28-b35e-d445c73535ce
- 使用 ES6 的解构可以非常容易地在循环中拆分键/值对
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be6848-95a1-4015-9984-14fb9ad436ea
- 复制和填充方法
  ls-type:: annotation
  hl-page:: 168
  hl-color:: green
  id:: 63be6850-f1bc-44e8-b76e-aedf880a39f0
  hl-stamp:: 1673422935065
- fill()方法可以向一个已有的数组中插入全部或部分相同的值
  ls-type:: annotation
  hl-page:: 168
  hl-color:: yellow
  id:: 63be6860-a1ff-4428-a389-3026daffae0e
- copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置
  ls-type:: annotation
  hl-page:: 169
  hl-color:: yellow
  id:: 63be68a3-53ee-422a-b914-dc7c02dca9fe
- 用 7 填充索引大于等于 1 且小于 3 的元素
  ls-type:: annotation
  hl-page:: 169
  hl-color:: yellow
  id:: 63be6961-64f7-4980-becc-97b6fb07916a
- 转换方法
  ls-type:: annotation
  hl-page:: 170
  hl-color:: green
  id:: 63be69b1-634e-4812-ab69-303f4d211c69
- 栈方法
  ls-type:: annotation
  hl-page:: 172
  hl-color:: green
  id:: 63be69b9-7167-4a3c-b82c-6db9e4d80646
- 队列方法
  ls-type:: annotation
  hl-page:: 172
  hl-color:: green
  id:: 63be69be-cb53-4d8e-b49f-dab7fd687af7
- 排序方法
  ls-type:: annotation
  hl-page:: 173
  hl-color:: green
  id:: 63be69c4-b681-4ad8-b3cc-ab81d331709e
- 操作方法
  ls-type:: annotation
  hl-page:: 175
  hl-color:: green
  id:: 63be69d0-436c-4d19-ac9f-87aeb37c7bb4
- 搜索和位置方法
  ls-type:: annotation
  hl-page:: 176
  hl-color:: green
  id:: 63be69d9-6fe8-4dcd-81d3-208a6b29c739
- 迭代方法
  ls-type:: annotation
  hl-page:: 178
  hl-color:: green
  id:: 63be69e1-882f-4190-8326-70212b9e3937
- 归并方法
  ls-type:: annotation
  hl-page:: 179
  hl-color:: green
  id:: 63be69e7-1040-486d-a71d-d579ec3cbdb1
- 定型数组
  ls-type:: annotation
  hl-page:: 180
  hl-color:: green
  id:: 63be6a08-fb0d-4102-91dc-de90944e1ae6
- Map
  ls-type:: annotation
  hl-page:: 188
  hl-color:: green
  id:: 63be6a22-4b5f-422e-a201-13babab8dd75
- WeakMap
  ls-type:: annotation
  hl-page:: 193
  hl-color:: green
  id:: 63be6a30-3d34-4f5e-a995-cc8d644c6c67
- Set
  ls-type:: annotation
  hl-page:: 198
  hl-color:: green
  id:: 63be6a3f-9238-435f-b044-c399dd08dc80
- WeakSet
  ls-type:: annotation
  hl-page:: 203
  hl-color:: green
  id:: 63be6a52-728f-428b-a100-de15e47fa9dc
- 迭代与扩展操作
  ls-type:: annotation
  hl-page:: 205
  hl-color:: green
  id:: 63be6a5d-63a1-415d-8e5d-b58fda46ccaa
- toLocaleString()方法时，会得到一个逗号分隔的数组值的字符串
  ls-type:: annotation
  hl-page:: 171
  hl-color:: yellow
  id:: 63be6c10-625b-4dd3-b909-401a942f2312
- 会调用数组每个值的 toLocaleString()方法
  ls-type:: annotation
  hl-page:: 171
  hl-color:: yellow
  id:: 63be6c15-490e-4c1d-b7c9-e19afe5338bf
- alert()期待字符串，所以会在后台调用数组的 toString()方法
  ls-type:: annotation
  hl-page:: 171
  hl-color:: yellow
  id:: 63be6c1b-0f91-4b35-9917-d648ca947704
- join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串
  ls-type:: annotation
  hl-page:: 171
  hl-color:: yellow
  id:: 63be6c5d-4be7-4e0c-8f34-48d0f4f48a6e
- push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度
  ls-type:: annotation
  hl-page:: 172
  hl-color:: yellow
  id:: 63be71cd-9d87-4f96-aeea-731b79761aca
- pop()方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项
  ls-type:: annotation
  hl-page:: 172
  hl-color:: yellow
  id:: 63be7332-53b9-4338-a3dd-0c555a2289d6
- shift()，它会删除数组的第一项并返回它，然后数组长度减 1
  ls-type:: annotation
  hl-page:: 172
  hl-color:: yellow
  id:: 63be7366-89d7-4ccd-afc6-fe6769452595
- 使用 shift()和 push()，可以把数组当成队列来使用
  ls-type:: annotation
  hl-page:: 172
  hl-color:: yellow
  id:: 63be7372-1c4f-472b-abd5-4716f2fe3942
- unshift()就是执行跟 shift()相反的操作：在数组开头添加任意多个值，然后返回新的数组长度
  ls-type:: annotation
  hl-page:: 173
  hl-color:: yellow
  id:: 63be76e5-fa0c-4e5b-a317-77fd39ada962
- reverse()方法就是将数组元素反向排列
  ls-type:: annotation
  hl-page:: 173
  hl-color:: yellow
  id:: 63be76f2-9861-408c-88c1-dae1053b0d32
- sort()会按照升序重新排列数组元素
  ls-type:: annotation
  hl-page:: 173
  hl-color:: yellow
  id:: 63be774b-dd42-4a63-b01f-ce071a7f890f
- sort()方法可以接收一个比较函数
  ls-type:: annotation
  hl-page:: 173
  hl-color:: yellow
  id:: 63be776f-de22-435b-8f39-7bd438fda891
- 比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值
  ls-type:: annotation
  hl-page:: 174
  hl-color:: yellow
  id:: 63be77aa-4eef-41e1-b4d9-341814f7a161
- concat()方法
  ls-type:: annotation
  hl-page:: 175
  hl-color:: yellow
  id:: 63be787a-a0f8-41b7-b5a2-752bbe933c73
- Symbol.isConcatSpreadable
  ls-type:: annotation
  hl-page:: 175
  hl-color:: yellow
  id:: 63be78a5-6759-42cb-81a9-5fb204caba7b
- 方法 slice()用于创建一个包含原有数组中一个或多个元素的新数组
  ls-type:: annotation
  hl-page:: 175
  hl-color:: yellow
  id:: 63be7942-cfbc-487e-a1b1-f9bc384307f9
- find()返回第一个匹配的元素
  ls-type:: annotation
  hl-page:: 177
  hl-color:: yellow
  id:: 63be7c46-4081-4b5c-8830-9e94ad4dd4ec
- findIndex()返回第一个匹配元素的索引
  ls-type:: annotation
  hl-page:: 177
  hl-color:: yellow
  id:: 63be7c4e-8b3b-4870-a60d-a0088c3ce20a
- alert(people.find((element, index, array) => element.age < 28));
  ls-type:: annotation
  hl-page:: 177
  hl-color:: yellow
  id:: 63be7ca0-5ded-405a-af45-ad5e49dcd4b1
- 找到匹配后，永远不会检查数组的最后一个元素
  ls-type:: annotation
  hl-page:: 178
  hl-color:: yellow
  id:: 63be7cb9-6d53-426f-b756-7fa27b50eb36
- 每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值
  ls-type:: annotation
  hl-page:: 178
  hl-color:: yellow
  id:: 63be7cd3-abe0-4e38-9373-2c2c86a34721
- 传给每个方法的函数接收 3个参数：数组元素、元素索引和数组本身
  ls-type:: annotation
  hl-page:: 178
  hl-color:: yellow
  id:: 63be7cdc-89aa-4c0e-84ca-8019251a531c
- 返回由每次函数调用的结果构成的数组
  ls-type:: annotation
  hl-page:: 178
  hl-color:: yellow
  id:: 63be7f2d-9234-4923-9654-5a701d25ee23
- let mapResult = numbers.map((item, index, array) => item * 2);
  ls-type:: annotation
  hl-page:: 179
  hl-color:: yellow
  id:: 63be7fc0-eae6-411a-a490-388ff18ab7fd
- forEach()方法。这个方法只会对每一项运行传入的函数，没有返回值
  ls-type:: annotation
  hl-page:: 179
  hl-color:: yellow
  id:: 63be7fdf-bc96-4d9a-9932-fea0980a62ba
- reduce()方法从数组第一项开始遍历到最后一项
  ls-type:: annotation
  hl-page:: 179
  hl-color:: yellow
  id:: 63be800b-f488-4335-8f24-6e0226778428
- reduceRight()从最后一项开始遍历至第一项
  ls-type:: annotation
  hl-page:: 179
  hl-color:: yellow
  id:: 63be8010-73b7-439f-9a06-e832ffc2bfba
- 上一个归并值、当前项、当前项的索引和数组本身
  ls-type:: annotation
  hl-page:: 179
  hl-color:: yellow
  id:: 63be8105-562d-431a-a28c-f0d0879fee48
- ArrayBuffer 是所有定型数组及视图引用的基本单位。
  ls-type:: annotation
  hl-page:: 180
  hl-color:: yellow
  id:: 63bea918-b9a5-494d-8ac1-e1acc48efb6b
- ArrayBuffer 某种程度上类似于 C++的 malloc()
  ls-type:: annotation
  hl-page:: 181
  hl-color:: yellow
  id:: 63bea92c-62f3-4a5a-b63b-818756fe52da
- ArrayBuffer分配的内存不能超过 Number.MAX_SAFE_INTEGER（253  1）字节。
  ls-type:: annotation
  hl-page:: 181
  hl-color:: yellow
  id:: 63bea936-f176-410b-84a8-52e29b8146c8
- 创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。
  ls-type:: annotation
  hl-page:: 184
  hl-color:: yellow
  id:: 63bea9f5-6afa-4353-972e-3f8d28e56a3c
- 可以使用任何 JavaScript 数据类型作为键
  ls-type:: annotation
  hl-page:: 190
  hl-color:: yellow
  id:: 63beac71-af4d-4c45-89c4-66f754545e5f
- 基本 API
  ls-type:: annotation
  hl-page:: 189
  hl-color:: green
  id:: 63beac7e-e044-43cd-8088-6bdbf4d37148
  hl-stamp:: 1673440384071
- 顺序与迭代
  ls-type:: annotation
  hl-page:: 191
  hl-color:: green
  id:: 63beac8c-49fb-4927-ab83-10deec98e9f1
- Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作
  ls-type:: annotation
  hl-page:: 191
  hl-color:: yellow
  id:: 63beacaa-bd51-4299-be85-fb036e40b3a3
- entries()）取得这个迭代器
  ls-type:: annotation
  hl-page:: 191
  hl-color:: yellow
  id:: 63beacc6-cd03-4068-a720-d5564d546571
- 或者 Symbol.iterator 属性
  ls-type:: annotation
  hl-page:: 191
  hl-color:: yellow
  id:: 63beacd4-cd9b-44b1-92a0-3cacc3f37fc1
- keys()和 values()分别返回以插入顺序生成键和值的迭代器
  ls-type:: annotation
  hl-page:: 192
  hl-color:: yellow
  id:: 63bead95-c27a-4a33-a6f9-d929b7667259
- 调用映射的 forEach(callback, opt_thisArg)方法并传入回调，依次迭代每个键/值对
  ls-type:: annotation
  hl-page:: 191
  hl-color:: yellow
  id:: 63beadaa-b7b6-4a0a-aa95-e1a44fcfed1d
- 键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改
  ls-type:: annotation
  hl-page:: 192
  hl-color:: yellow
  id:: 63beaecf-7965-44bb-9b1f-79aca1ef3b3d
- 选择 Object 还是 Ma
  ls-type:: annotation
  hl-page:: 193
  hl-color:: green
  id:: 63beaefe-542d-4db0-a239-f3f754e03111
- 给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对
  ls-type:: annotation
  hl-page:: 193
  hl-color:: yellow
  id:: 63beaf0c-e895-4107-80aa-764f72356357
- 插入 Map 在所有浏览器中一般会稍微快一点儿
  ls-type:: annotation
  hl-page:: 193
  hl-color:: yellow
  id:: 63beafa7-ba78-483f-bac3-4041047eb57d
- 如果代码涉及大量查找操作，那么某些情况下可能选择 Object 更好一些
  ls-type:: annotation
  hl-page:: 193
  hl-color:: yellow
  id:: 63beafb7-443a-40f4-bdfb-0791eed57a3e
- Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map
  ls-type:: annotation
  hl-page:: 193
  hl-color:: yellow
  id:: 63beafcc-b7ba-4a9e-998f-b4fd109b716c
- 基本 API
  ls-type:: annotation
  hl-page:: 193
  hl-color:: green
  id:: 63beafd8-f73f-4426-b8f4-74f44257858a
- const wm = new WeakMap();
  ls-type:: annotation
  hl-page:: 193
  hl-color:: yellow
  id:: 63beb026-805f-4267-b455-f43c5c8180b4
- 弱键
  ls-type:: annotation
  hl-page:: 195
  hl-color:: green
  id:: 63beb1c7-02b5-4070-aecf-68f0a1e98c6b
- 映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收
  ls-type:: annotation
  hl-page:: 195
  hl-color:: yellow
  id:: 63beb1d5-f29a-42e4-8625-eea2a65aba35
- 不可迭代键
  ls-type:: annotation
  hl-page:: 195
  hl-color:: green
  id:: 63beb214-e271-49e3-8655-6b42ec2b15f8
- 使用弱映射
  ls-type:: annotation
  hl-page:: 196
  hl-color:: green
  id:: 63beb294-8369-4334-8bb2-5b932d743636
- WeakMap 实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值
  ls-type:: annotation
  hl-page:: 195
  hl-color:: yellow
  id:: 63beb2da-e319-4684-a191-ab8daa677169
- 基本 API
  ls-type:: annotation
  hl-page:: 198
  hl-color:: green
  id:: 63beb368-5074-47f1-90ad-114328dda759
- const m = new Set();
  ls-type:: annotation
  hl-page:: 198
  hl-color:: yellow
  id:: 63beb37c-f64b-4174-8555-a667080690fa
- 顺序与迭代
  ls-type:: annotation
  hl-page:: 200
  hl-color:: green
  id:: 63beb534-1098-42e1-a16b-c595426f301d
  hl-stamp:: 1673442614151
- Set 会维护值插入时的顺序，因此支持按顺序迭代
  ls-type:: annotation
  hl-page:: 200
  hl-color:: yellow
  id:: 63beb573-943c-425c-92c6-a7651807ee96
- 集合的 entries()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现
  ls-type:: annotation
  hl-page:: 200
  hl-color:: yellow
  id:: 63beb591-e55e-4009-8e29-9944a11aa44f
- values()是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组
  ls-type:: annotation
  hl-page:: 200
  hl-color:: yellow
  id:: 63beb5b3-db3a-4018-9837-3159c0a42b7b
- 定义正式集合操作
  ls-type:: annotation
  hl-page:: 201
  hl-color:: green
  id:: 63beb602-dcb6-45b2-bf6e-ed79df318abe
  hl-stamp:: 1673442821913
- 弱集合中的值只能是 Object 或者继承自 Object 的类型，
  ls-type:: annotation
  hl-page:: 203
  hl-color:: yellow
  id:: 63beb6bf-7356-4f24-8af1-16524da3c8c7
- ，container 对象维护着一个对弱集合值的引用，因此这个对象值不会成为垃圾回收的目标
  ls-type:: annotation
  hl-page:: 204
  hl-color:: yellow
  id:: 63beb7de-9134-46b7-90c6-c1239c0959ca
- 只要 WeakSet 中任何元素从 DOM 树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存（假设没有其他地方引用这个对象）。
  ls-type:: annotation
  hl-page:: 205
  hl-color:: yellow
  id:: 63beb83d-ee81-472f-adbe-8ce629cf4acd
- 所有类型都支持顺序迭代，都可以传入 for-of 循环
  ls-type:: annotation
  hl-page:: 206
  hl-color:: yellow
  id:: 63beb8b9-8bc8-406c-b3e5-617884384140
- 对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制
  ls-type:: annotation
  hl-page:: 206
  hl-color:: yellow
  id:: 63beb8fa-a0bd-4313-9aa1-9734ff48394e
- 理解迭代
  ls-type:: annotation
  hl-page:: 208
  hl-color:: green
  id:: 63c7b6f7-8409-4620-999e-f6a0cdfa2c98
- 在 JavaScript 中，计数循环就是一种最简单的迭代
  ls-type:: annotation
  hl-page:: 208
  hl-color:: yellow
  id:: 63c7d77d-5947-49c4-8a94-fd1508cc8d46
- 循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作
  ls-type:: annotation
  hl-page:: 208
  hl-color:: yellow
  id:: 63c7d840-cf6f-44ac-80b6-40423bb0226b
- ES5 新增了 Array.prototype.forEach()方法，向通用迭代需求迈进了一步
  ls-type:: annotation
  hl-page:: 208
  hl-color:: yellow
  id:: 63c7d8d9-52be-4e94-84f7-298891427021
- 没有办法标识迭代何时终
  ls-type:: annotation
  hl-page:: 209
  hl-color:: yellow
  id:: 63c7d934-edb4-4ff8-9d6f-8dc32ff49123
- 迭代器模式
  ls-type:: annotation
  hl-page:: 209
  hl-color:: green
  id:: 63c7d947-e12a-4d13-b77e-d044beacf856
- 它们包含的元素都是有限的，而且都具有无歧义的遍历顺
  ls-type:: annotation
  hl-page:: 209
  hl-color:: yellow
  id:: 63c7db27-2ba2-446e-a723-e7eab2540167
- 可迭代协议
  ls-type:: annotation
  hl-page:: 209
  hl-color:: green
  id:: 63c7db97-e0ef-4c59-922b-ca268a8205d5
- ：支持迭代的自我识别能力和创建实现 Iterator 接口的对象的能力
  ls-type:: annotation
  hl-page:: 209
  hl-color:: yellow
  id:: 63c7dbdd-45f5-486f-98ef-c85b7e04051b
- 必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 Symbol.iterator 作为键
  ls-type:: annotation
  hl-page:: 209
  hl-color:: yellow
  id:: 63c7dbf5-36a1-4d12-b509-48c35dc05528
- 。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性
  ls-type:: annotation
  hl-page:: 210
  hl-color:: yellow
  id:: 63c7dc37-bbe2-400f-aa81-a622b9c9cbd4
- 这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代
  ls-type:: annotation
  hl-page:: 210
  hl-color:: yellow
  id:: 63c7dc3f-1ccb-40e0-b49d-5ffd60051e9e
- 接收可迭代对象的原生语言特性包括：
  ls-type:: annotation
  hl-page:: 210
  hl-color:: yellow
  id:: 63c7dc4f-7e8b-4559-91f1-222929027339
- 迭代器协议
  ls-type:: annotation
  hl-page:: 211
  hl-color:: green
  id:: 63c7dca8-0715-45aa-a45d-1d89c0a2046a
- 。迭代器 API 使用 next()方法在可迭代对象中遍历数据。每次成功调用 next()，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值
  ls-type:: annotation
  hl-page:: 211
  hl-color:: yellow
  id:: 63c7dcb9-333e-459c-a3ff-b83c489aa07a
- 只要迭代器到达 done: true 状态，后续调用 next()就一直返回同样的值了
  ls-type:: annotation
  hl-page:: 212
  hl-color:: yellow
  id:: 63c7dd43-ec40-46f1-b128-c5617af7181f
- 不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象
  ls-type:: annotation
  hl-page:: 212
  hl-color:: yellow
  id:: 63c7dd92-4138-41c7-a004-13b908e543a9
- 如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化
  ls-type:: annotation
  hl-page:: 212
  hl-color:: yellow
  id:: 63c7ddca-417e-4858-a800-59e07590aa64
- 迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象
  ls-type:: annotation
  hl-page:: 212
  hl-color:: yellow
  id:: 63c7ddeb-dc9e-42f0-8c9b-606cd5f783a8
- 自定义迭代器
  ls-type:: annotation
  hl-page:: 213
  hl-color:: green
  id:: 63c7de4b-4e64-4ceb-a3fe-6107134c2421
- 是因为它的每个实例只能被迭代一次
  ls-type:: annotation
  hl-page:: 213
  hl-color:: yellow
  id:: 63c7df22-4bf9-4f2a-b053-617c633522b4
- 因为每个迭代器也实现了 Iterable 接口，所以它们可以用在任何期待可迭代对象的地方，比如 for-of 循环
  ls-type:: annotation
  hl-page:: 214
  hl-color:: yellow
  id:: 63c7df6f-a42a-421f-b01b-b3a469a80d74
- 提前终止迭代器
  ls-type:: annotation
  hl-page:: 215
  hl-color:: green
  id:: 63c7dfda-af10-486a-8bdd-57511caf6895
  hl-stamp:: 1674043356569
- 可选的 return()方法用于指定在迭代器提前关闭时执行的逻辑。
  ls-type:: annotation
  hl-page:: 215
  hl-color:: yellow
  id:: 63c7dfe6-1cba-4007-83d2-67f3c6139cc1
- return()方法必须返回一个有效的 IteratorResult 对象。简单情况下，可以只返回{ done: true }。
  ls-type:: annotation
  hl-page:: 215
  hl-color:: yellow
  id:: 63c7e01f-63b5-45a0-b581-45f8b65d354b
- 调用 return()不会强制迭代器进入关闭状态
  ls-type:: annotation
  hl-page:: 216
  hl-color:: yellow
  id:: 63c7e0bb-57bc-4c1d-b549-d7df7d4fd96f
- 生成器
  ls-type:: annotation
  hl-page:: 217
  hl-color:: green
  id:: 63c7e0d5-25a0-4970-a940-a306aee2fc32
- 拥有在一个函数块内暂停和恢复代码执行的能力
  ls-type:: annotation
  hl-page:: 217
  hl-color:: yellow
  id:: 63c7e0f6-5840-4f36-83f8-c365e3f1e48c
- 使用生成器可以自定义迭代器和实现协程
  ls-type:: annotation
  hl-page:: 217
  hl-color:: yellow
  id:: 63c7e0fe-a75f-46f0-98d2-0de4352004be
- 生成器基础
  ls-type:: annotation
  hl-page:: 217
  hl-color:: green
  id:: 63c7e1ec-785e-4e9b-96d6-36d26f0f5afb
- 只要是可以定义函数的地方，就可以定义生成器
  ls-type:: annotation
  hl-page:: 217
  hl-color:: yellow
  id:: 63c7e1ff-bdbb-4129-9ae6-a6ffbf899c41
- 调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态
  ls-type:: annotation
  hl-page:: 218
  hl-color:: yellow
  id:: 63c7e21e-6c04-45af-956f-2c435b31bdb0
- next()方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性
  ls-type:: annotation
  hl-page:: 218
  hl-color:: yellow
  id:: 63c7e224-8e7e-445e-b0af-0cfbae4512cf
- 生成器函数只会在初次调用 next()方法后开始执行
  ls-type:: annotation
  hl-page:: 218
  hl-color:: yellow
  id:: 63c7e307-ecf5-401d-b30b-22aaf0010079
- 生成器对象实现了 Iterable 接口，它们默认的迭代器是自引用的
  ls-type:: annotation
  hl-page:: 218
  hl-color:: yellow
  id:: 63c7e3b8-85b5-4de3-9488-e5232b70fbd3
- 通过 yield 中断执行
  ls-type:: annotation
  hl-page:: 219
  hl-color:: green
  id:: 63c7e460-596c-47ca-b4ec-1803eb4c8a63
- 生成器函数在遇到 yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留
  ls-type:: annotation
  hl-page:: 219
  hl-color:: yellow
  id:: 63c7e487-d662-41d5-a48e-54e446be2188
- yield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误。
  ls-type:: annotation
  hl-page:: 220
  hl-color:: yellow
  id:: 63c7e4d0-ebeb-409d-baf5-5b4dc60e55aa
- 出现在嵌套的非生成器函数中会抛出语法错
  ls-type:: annotation
  hl-page:: 220
  hl-color:: yellow
  id:: 63c7e50d-74cd-420a-ac96-7d3c4e7d2d07
- 生成器对象作为可迭代对象
  ls-type:: annotation
  hl-page:: 220
  hl-color:: yellow
  id:: 63c7e521-748d-48db-9203-2b281fbfc354
- 使用 yield 实现输入和输出
  ls-type:: annotation
  hl-page:: 221
  hl-color:: yellow
  id:: 63c7e5b8-68be-47bb-b0ba-718a0467ccd7
- 下一次调用 next()传入了"bar"，作为交给同一个 yield 的值
  ls-type:: annotation
  hl-page:: 221
  hl-color:: yellow
  id:: 63c7e611-e7f1-4771-9530-edd7b463a16e
- 它会根据配置的值迭代相应次数并产生迭代的索引。初始化一个新数组可以实现这个需求，但不用数组也可以实现同样的行为
  ls-type:: annotation
  hl-page:: 222
  hl-color:: yellow
  id:: 63c7e6db-64b9-41cc-9e49-ca9ef98fafc4
- 产生可迭代对象
  ls-type:: annotation
  hl-page:: 222
  hl-color:: yellow
  id:: 63c7e706-91c4-4030-878d-947e2e5a700a
- 使用星号增强 yield 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值
  ls-type:: annotation
  hl-page:: 222
  hl-color:: yellow
  id:: 63c7e773-14db-47a6-ac7b-1bf2e5c56dea
- 使用 yield*实现递归算法
  ls-type:: annotation
  hl-page:: 224
  hl-color:: yellow
  id:: 63c7e7a6-a6e5-4fc5-849c-99720e501d3e
- 生成器作为默认迭代器
  ls-type:: annotation
  hl-page:: 226
  hl-color:: green
  id:: 63c7e876-91d0-4635-97f1-e2e84e9109c2
- 提前终止生成器
  ls-type:: annotation
  hl-page:: 227
  hl-color:: green
  id:: 63c7e87f-d1cd-4c56-928a-0f8438ce76fa
- return()和 throw()方法都可以用于强制生成器进入关闭状态
  ls-type:: annotation
  hl-page:: 227
  hl-color:: yellow
  id:: 63c7e894-4930-47d3-9a70-4541a97302e0
- throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：
  ls-type:: annotation
  hl-page:: 228
  hl-color:: yellow
  id:: 63c7e937-c50a-4255-935e-7f44e3e34ae0
- 理解对象
  ls-type:: annotation
  hl-page:: 230
  hl-color:: green
  id:: 63c7e9fb-fd45-41cc-a9e4-5cbeedbb9a54
- 属性分两种：数据属性和访问器属性。
  ls-type:: annotation
  hl-page:: 231
  hl-color:: yellow
  id:: 63c7ea13-cfc3-4ecd-923f-93977ada5bed
- [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义
  ls-type:: annotation
  hl-page:: 231
  hl-color:: yellow
  id:: 63c7ea96-b811-431d-b225-f18bed68e8a4
- [[Enumerable]]：表示属性是否可以通过 for-in 循环返回
  ls-type:: annotation
  hl-page:: 231
  hl-color:: yellow
  id:: 63c7eaa5-2e31-49da-a8ca-caac905e8d94
- [Writable]]：表示属性的值是否可以被修改
  ls-type:: annotation
  hl-page:: 231
  hl-color:: yellow
  id:: 63c7eaf8-21f1-4377-864a-1cd308187ba9
- [[Value]]：包含属性实际的值
  ls-type:: annotation
  hl-page:: 231
  hl-color:: yellow
  id:: 63c7eb04-a564-4e20-bb2d-7d73734609ef
- 个例子把 configurable 设置为 false，意味着这个属性不能从对象上删除
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7eb9f-04db-44ac-ba0f-ee6c502b8071
- 包含一个获取（getter）函数和一个设置（setter）函数
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7ed25-8d22-4213-baa9-0744131e61bd
- [[Configurable]]：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7ed30-998c-4ccb-93bc-555709003ddd
- [[Enumerable]]：表示属性是否可以通过 for-in 循环返回
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7ed38-2b4c-4ee7-b58b-86e749a205fc
- [[Get]]：获取函数，在读取属性时调用。默认值为 undefined。
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7ed42-9895-4d6b-b124-f6776353c15e
- [[Set]]：设置函数，在写入属性时调用。默认值为 undefined。
  ls-type:: annotation
  hl-page:: 232
  hl-color:: yellow
  id:: 63c7ed4d-f416-427d-8524-e64f3cb70279
- year_中的下划线常用来表示该属性并不希望在对象方法的外部被访问
  ls-type:: annotation
  hl-page:: 233
  hl-color:: yellow
  id:: 63c7eda1-1209-4c0f-bec2-74970771d713
- 定义多个属性
  ls-type:: annotation
  hl-page:: 233
  hl-color:: green
  id:: 63c7ee31-e7fe-4138-87f5-9dff19f27c2d
- 这是访问器属性的典型使用场景，即设置一个属性值会导致一些其他变化发生。
  ls-type:: annotation
  hl-page:: 233
  hl-color:: yellow
  id:: 63c7eea0-1bee-482b-979d-2b2343ef723d
- 读取属性的特性
  ls-type:: annotation
  hl-page:: 234
  hl-color:: green
  id:: 63c7ef09-5664-46cc-a5cb-ce5057241c5e
- 使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符
  ls-type:: annotation
  hl-page:: 234
  hl-color:: yellow
  id:: 63c7ef54-bbd4-438b-a5a3-35ca1cb49dfd
- Object.getOwnPropertyDescriptors()静态方法
  ls-type:: annotation
  hl-page:: 235
  hl-color:: yellow
  id:: 63c7efc4-843d-47ad-9bb4-de91278230dd
- 合并对象
  ls-type:: annotation
  hl-page:: 235
  hl-color:: green
  id:: 63c7f060-3b20-4c4a-a4c6-dea47a34148c
- 就是把源对象所有的本地属性一起复制到目标对象上
  ls-type:: annotation
  hl-page:: 235
  hl-color:: yellow
  id:: 63c7f070-b079-4030-a514-9f3a13fefff9
- ECMAScript 6 专门为合并对象提供了 Object.assign()方法
  ls-type:: annotation
  hl-page:: 236
  hl-color:: yellow
  id:: 63c7f097-3717-46a2-848c-1db9c31c2a5d
- Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。
  ls-type:: annotation
  hl-page:: 237
  hl-color:: yellow
  id:: 63c7f0bb-53b5-48bc-89e2-02106f01e8c3
- 如果赋值期间出错，则操作会中止并退出，同时抛出错误。Object.assign()没有“回滚”之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。
  ls-type:: annotation
  hl-page:: 237
  hl-color:: yellow
  id:: 63c7f19f-3c83-4260-b87d-a51ac2ed6ae7
- 对象标识及相等判定
  ls-type:: annotation
  hl-page:: 238
  hl-color:: green
  id:: 63c7f1ab-76aa-4a71-acc7-54fee3880cc6
- Object.is()，这个方法与===很像
  ls-type:: annotation
  hl-page:: 238
  hl-color:: yellow
  id:: 63c7f2c4-8707-4222-82eb-c917cad7ea7c
- 要检查超过两个值，递归地利用相等性传递即可：
  ls-type:: annotation
  hl-page:: 238
  hl-color:: yellow
  id:: 63c7f32e-e1fa-43bd-81e0-f0eda9e17bc7
- 增强的对象语法
  ls-type:: annotation
  hl-page:: 238
  hl-color:: green
  id:: 63c7f335-22de-4d85-9320-4f570779a814
- 属性值简写
  ls-type:: annotation
  hl-page:: 239
  hl-color:: yellow
  id:: 63c7f409-a9d3-499c-8299-45a88003fe83
- 可计算属性
  ls-type:: annotation
  hl-page:: 239
  hl-color:: yellow
  id:: 63c7f430-3f34-4695-8145-913c60026db8
- 简写方法名
  ls-type:: annotation
  hl-page:: 240
  hl-color:: yellow
  id:: 63c7f437-8de1-4bee-8a9f-449473c0543e
- 句话说，不能在对象字面量中直接动态命名属性
  ls-type:: annotation
  hl-page:: 239
  hl-color:: yellow
  id:: 63c7f462-70cc-45e5-acf0-cf6c284b761c
- 中括号包围的对象属性键告诉运行时将其作为 JavaScript 表达式而不是字符串来求值：
  ls-type:: annotation
  hl-page:: 240
  hl-color:: yellow
  id:: 63c7f4c0-8b06-4a2f-843d-ea7a9d6cbc3a
- 对象解构
  ls-type:: annotation
  hl-page:: 241
  hl-color:: green
  id:: 63c7f4d1-2bf3-491e-b0fa-e5ea9508efb3
- 创建对象
  ls-type:: annotation
  hl-page:: 245
  hl-color:: green
  id:: 63c7f50a-5a57-4e0d-bf87-700a14aa05f0
- 可以在一条语句中使用嵌套数据实现一个或多个赋值操作
  ls-type:: annotation
  hl-page:: 241
  hl-color:: yellow
  id:: 63c7f53b-719b-4b73-8bc0-5da06313733e
- 使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。
  ls-type:: annotation
  hl-page:: 242
  hl-color:: yellow
  id:: 63c7f5e3-008b-4a22-b9ea-3d98b960ef18
- 也可以在解构赋值的同时定义默认值，这适用于前面刚提到的引用的属性不存在于源对象中的情况
  ls-type:: annotation
  hl-page:: 242
  hl-color:: yellow
  id:: 63c7f6ad-c781-4e06-8d88-82d50aa5f359