- 浅拷贝
	- 创建一个新对象，这个对象有原始对象属性值的一份精确拷贝。基本类型则直接拷贝值，而引用类型拷贝的是内存地址，会互相影响
- 使用递归来解决对象深度的问题
	- 原始类型无需拷贝，直接返回
	- 引用类型递归到属性为原始类型
		- 对象可以简单递归到新函数内，用空对象进行存储
		- 考虑数组则需要，进行判断，是创建空对象还是空数组
	- 循环引用问题
		- `target.target = target`
		- 额外开辟一个对象，存储当前对象和拷贝对象的对应关系
			- 使用map或者是weakmap
- ```
  functon clone(target , map = new Map()){
  	if(typeof target == "object"){
      	let cloneTarget = Array.isArray(target) ? [] : {};
          
          if(map.get(target)){
          	return map.get(target);
          }
          
          map.set(target,clonetarget);
          
          for(const key in target){
          	cloneTarget[key] = clone(target[key],map);
          }
      }else {
      	return target;
      }
  }
  ```
-
- 还可能需要考虑map和set这两种可遍历情况
	- ```
	  if (type === setTag) {
	          target.forEach(value => {
	              cloneTarget.add(clone(value,map));
	          });
	          return cloneTarget;
	      }
	  ```
	- ```
	  // 克隆map
	      if (type === mapTag) {
	          target.forEach((value, key) => {
	              cloneTarget.set(key, clone(value,map));
	          });
	          return cloneTarget;
	      }
	  ```
-
-