- ## 是什么
	- 对特定资源的访问许可
	- 路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 `4xx` 提示页
	- 视图方面，用户只能看到自己有权浏览的内容和有权操作的控件
	- 最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截
- ## 如何做
	- 接口权限
		- 没有权限一般返回401
		- 存储token
	- 按钮权限
	- 菜单权限
	- 路由权限
		- 方案一
			- 初始设置全部路由和权限，并在路由上标记权限信息，每次路由跳转前做校验
			- ```
			  const routerMap = [
			  	{
			      	path:'/permission',
			          component:Layout,
			          redirect:'permission/index'
			          alwaysShow:'true'
			          meta:{
			          	title:'permission',
			              icon:'lock',
			              roles:['admin','editor']
			          }
			      }
			  ]
			  ```
			- 缺点：
				- 会加载所有的路由
				- 全局路由守卫里，每次路由跳转都要做权限判断
				- 菜单信息写死，修改时需要重新编译
				- 菜单和路由耦合
		- 方案二
			- 初始时先挂载不需要权限控制的路由，如登录页，404页
			- 登陆后，获取用户权限，在全局路由守卫中调用addRoutes添加路由
			- 缺点
				- 全局路由守卫里，每次路由跳转都要做判断
				- 菜单信息写死
				- 菜单和路由耦合
	- 菜单权限
	  collapsed:: true
		- 将页面和路由进行解耦
		- 方案一
			- 菜单和路由分离，菜单由后端返回
			- ```
			  //前端定义路由信息
			  {
			  	name:'login',
			      path:'/login',
			      component:()=> import("@/pages/Login.vue"})
			  }
			  ```
			- 全局路由守卫里做判断
			- 缺点
				- 菜单需要与路由做一一对应
				- 全局路由守卫里，每次路由跳转都要做判断
		- 方案二
			- 菜单和路由都由后端返回
			- 前端定义统一的路由组件
			- ```
			  const Home =()=>import("../pages/Home.vue");
			  const UserInfo =()=>("../pages/UserInfo.vue");
			  export default{
			  	home:Home,
			      userInfo:UserInfo
			  }
			  ```
			- 后端返回格式
			- ```
			  [
			      {
			          name: "home",
			          path: "/",
			          component: "home"
			      },
			      {
			          name: "home",
			          path: "/userinfo",
			          component: "userInfo"
			      }
			  ]
			  ```
		- 在将后端返回路由通过`addRoutes`动态挂载之间，需要将数据处理一下，将`component`字段换为真正的组件
		- 缺点
			- 前后端的配合要求更高
			- 全局路由守卫里，每次路由跳转都要做判断
	- 按钮权限
		- 方案一：使用v-if
		- 方案二
			- 通过自定义指令进行权限按钮的判断
			- ```
			  import Vue from 'vue'
			  /**权限指令**/
			  const has = Vue.directive('has', {
			      bind: function (el, binding, vnode) {
			          // 获取页面按钮权限
			          let btnPermissionsArr = [];
			          if(binding.value){
			              // 如果指令传值，获取指令参数，根据指令参数和当前登录人按钮权限做比较。
			              btnPermissionsArr = Array.of(binding.value);
			          }else{
			              // 否则获取路由中的参数，根据路由的btnPermissionsArr和当前登录人按钮权限做比较。
			              btnPermissionsArr = vnode.context.$route.meta.btnPermissions;
			          }
			          if (!Vue.prototype.$_has(btnPermissionsArr)) {
			              el.parentNode.removeChild(el);
			          }
			      }
			  });
			  // 权限检查方法
			  Vue.prototype.$_has = function (value) {
			      let isExist = false;
			      // 获取用户按钮权限
			      let btnPermissionsStr = sessionStorage.getItem("btnPermissions");
			      if (btnPermissionsStr == undefined || btnPermissionsStr == null) {
			          return false;
			      }
			      if (value.indexOf(btnPermissionsStr) > -1) {
			          isExist = true;
			      }
			      return isExist;
			  };
			  export {has}
			  ```
			- ```
			  <el-button @click='editClick' type="primary" v-has>编辑</el-button>
			  ```